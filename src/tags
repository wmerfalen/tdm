!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABORT	telnet.h	59;"	d
ACMD	act.comm.cpp	/^ACMD(do_gen_comm) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_gsay) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_qcomm) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_reply) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_say) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_spec_comm) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_tell) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_write) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_color) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_commands) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_consider) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_diagnose) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_drone) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_equipment) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_examine) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_exits) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_gen_ps) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_givemegold) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_gold) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_help) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_inventory) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_js) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_jstest) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_levels) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_look) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_newjs) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_preferences) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_quest) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_recall) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_score) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_time) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_toggle) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_users) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_weather) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_where) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_who) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_drink) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_drop) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_eat) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_get) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_give) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_grab) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_pour) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_put) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_remove) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_wear) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_wield) {$/;"	f
ACMD	act.medic.cpp	/^ACMD(do_heal) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_enter) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_follow) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_gen_door) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_leave) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_move) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_rest) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_sit) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_sleep) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_stand) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_wake) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_ammo) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_assist) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_backstab) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_bash) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_breach) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_flee) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_hit) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_kick) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_kill) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_order) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_reload) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_rescue) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_rnum) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_scan) { \/* !mods *\/$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_snipe) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_thermite) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_throw) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_display) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_gen_tog) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_gen_write) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_group) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_hide) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_not_here) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_practice) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_quit) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_report) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_save) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_sneak) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_split) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_steal) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_title) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_ungroup) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_use) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_visible) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_wimpy) {$/;"	f
ACMD	act.social.cpp	/^ACMD(do_action) {$/;"	f
ACMD	act.social.cpp	/^ACMD(do_insult) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_advance) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_at) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_date) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_dc) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_echo) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_force) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_gecho) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_goto) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_invis) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_last) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_load) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_poofset) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_purge) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_restore) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_return) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_send) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_set) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_show) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_shutdown){$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_snoop) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_stat) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_switch) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_syslog) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_teleport) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_trans) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_vnum) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_vstat) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wizlock) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wiznet) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wizutil) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_zreset) {$/;"	f
ACMD	ban.cpp	/^ACMD(do_ban) {$/;"	f
ACMD	ban.cpp	/^ACMD(do_unban) {$/;"	f
ACMD	db.cpp	/^ACMD(do_reboot) {$/;"	f
ACMD	graph.cpp	/^ACMD(do_track) {$/;"	f
ACMD	house.cpp	/^ACMD(do_hcontrol) {$/;"	f
ACMD	house.cpp	/^ACMD(do_house) {$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_alias) {$/;"	f
ACMD	interpreter.h	14;"	d
ACMD	limits.cpp	/^ACMD(do_idle){$/;"	f
ACMD	modify.cpp	/^ACMD(do_skillset) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_mbuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_obuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_rbuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_sbuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_zbuild) {$/;"	f
ACMD	mods/chat.cpp	/^ACMD(do_chanmgr) {$/;"	f
ACMD	mods/immortal.cpp	/^ACMD(do_rnumlist) {$/;"	f
ACMD	mods/immortal.cpp	/^ACMD(do_rnumtele) {$/;"	f
ACMD	mods/prefs.cpp	/^ACMD(do_pref) {$/;"	f
ACMD	olc.cpp	/^ACMD(do_olc) {$/;"	f
ACMD	spell_parser.cpp	/^ACMD(do_cast) {$/;"	f
ACMD_EXAMINE	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_LOOK	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_READ	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_REMOVE	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_WRITE	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACTNULL	comm.cpp	/^const char *ACTNULL = "<NULL>";$/;"	v
AFF_BLIND	structs.h	256;"	d
AFF_CHARM	structs.h	277;"	d
AFF_CURSE	structs.h	265;"	d
AFF_DETECT_ALIGN	structs.h	258;"	d
AFF_DETECT_INVIS	structs.h	259;"	d
AFF_DETECT_MAGIC	structs.h	260;"	d
AFF_FLAGGED	utils.h	229;"	d
AFF_FLAGS	utils.h	215;"	d
AFF_FLAG_BIT_COUNT	mods/player.cpp	/^	constexpr static int16_t AFF_FLAG_BIT_COUNT = 22;$/;"	m	namespace:mods	file:
AFF_GROUP	structs.h	264;"	d
AFF_HIDE	structs.h	275;"	d
AFF_INFRAVISION	structs.h	266;"	d
AFF_INVISIBLE	structs.h	257;"	d
AFF_NOTRACK	structs.h	271;"	d
AFF_POISON	structs.h	267;"	d
AFF_PROTECT_EVIL	structs.h	268;"	d
AFF_PROTECT_GOOD	structs.h	269;"	d
AFF_SANCTUARY	structs.h	263;"	d
AFF_SENSE_LIFE	structs.h	261;"	d
AFF_SLEEP	structs.h	270;"	d
AFF_SNEAK	structs.h	274;"	d
AFF_UNUSED16	structs.h	272;"	d
AFF_UNUSED17	structs.h	273;"	d
AFF_UNUSED20	structs.h	276;"	d
AFF_WATERWALK	structs.h	262;"	d
AGGRESSIVE_PROTECT	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
AI_EVENT_ATTACKER_FOUND	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
AI_EVENT_SNIPED	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
AI_EVENT_WANDER	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
AI_WITNESS_ATTACK	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
ALIAS_COMPLEX	interpreter.h	70;"	d
ALIAS_FILE	utils.h	117;"	d
ALIAS_GLOB_CHAR	interpreter.h	74;"	d
ALIAS_SEP_CHAR	interpreter.h	72;"	d
ALIAS_SIMPLE	interpreter.h	69;"	d
ALIAS_VAR_CHAR	interpreter.h	73;"	d
AMMO	mods/weapon.hpp	7;"	d
AN	utils.h	153;"	d
ANA	utils.h	423;"	d
AND_THEN	mods/catch.hpp	12218;"	d
AND_WHEN	mods/catch.hpp	12216;"	d
AO	telnet.h	52;"	d
APPLY_AC	structs.h	410;"	d
APPLY_AGE	structs.h	402;"	d
APPLY_CHA	structs.h	399;"	d
APPLY_CHAR_HEIGHT	structs.h	404;"	d
APPLY_CHAR_WEIGHT	structs.h	403;"	d
APPLY_CLASS	structs.h	400;"	d
APPLY_CON	structs.h	398;"	d
APPLY_DAMROLL	structs.h	412;"	d
APPLY_DEX	structs.h	395;"	d
APPLY_EXP	structs.h	409;"	d
APPLY_GOLD	structs.h	408;"	d
APPLY_HIT	structs.h	406;"	d
APPLY_HITROLL	structs.h	411;"	d
APPLY_INT	structs.h	396;"	d
APPLY_LEVEL	structs.h	401;"	d
APPLY_MANA	structs.h	405;"	d
APPLY_MOVE	structs.h	407;"	d
APPLY_NONE	structs.h	393;"	d
APPLY_SAVING_BREATH	structs.h	416;"	d
APPLY_SAVING_PARA	structs.h	413;"	d
APPLY_SAVING_PETRI	structs.h	415;"	d
APPLY_SAVING_ROD	structs.h	414;"	d
APPLY_SAVING_SPELL	structs.h	417;"	d
APPLY_STR	structs.h	394;"	d
APPLY_WIS	structs.h	397;"	d
ASPELL	spells.cpp	/^ASPELL(spell_charm) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_create_water) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_detect_poison) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_enchant_weapon) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_identify) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_locate_object) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_recall) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_summon) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_teleport) {$/;"	f
ASPELL	spells.h	212;"	d
ASSIGNMOB	spec_assign.cpp	/^void ASSIGNMOB(mob_vnum mob, SPECIAL(fname)) {$/;"	f
ASSIGNOBJ	spec_assign.cpp	/^void ASSIGNOBJ(obj_vnum obj, SPECIAL(fname)) {$/;"	f
ASSIGNROOM	spec_assign.cpp	/^void ASSIGNROOM(room_vnum room, SPECIAL(fname)) {$/;"	f
AUTHTYPE_CNT	telnet.h	265;"	d
AUTHTYPE_KERBEROS_V4	telnet.h	261;"	d
AUTHTYPE_KERBEROS_V5	telnet.h	262;"	d
AUTHTYPE_MINK	telnet.h	264;"	d
AUTHTYPE_NAME	telnet.h	278;"	d
AUTHTYPE_NAME_OK	telnet.h	277;"	d
AUTHTYPE_NULL	telnet.h	260;"	d
AUTHTYPE_SPX	telnet.h	263;"	d
AUTHTYPE_TEST	telnet.h	267;"	d
AUTH_HOW_MASK	telnet.h	258;"	d
AUTH_HOW_MUTUAL	telnet.h	257;"	d
AUTH_HOW_ONE_WAY	telnet.h	256;"	d
AUTH_WHO_CLIENT	telnet.h	249;"	d
AUTH_WHO_MASK	telnet.h	251;"	d
AUTH_WHO_SERVER	telnet.h	250;"	d
AWAKE	utils.h	356;"	d
AYT	telnet.h	51;"	d
AllOf	mods/catch.hpp	/^		inline Impl::MatchAllOf<T> AllOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2) {$/;"	f	namespace:Catch::Matchers
AllOf	mods/catch.hpp	/^		inline Impl::MatchAllOf<T> AllOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3) {$/;"	f	namespace:Catch::Matchers
AnyOf	mods/catch.hpp	/^		inline Impl::MatchAnyOf<T> AnyOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2) {$/;"	f	namespace:Catch::Matchers
AnyOf	mods/catch.hpp	/^		inline Impl::MatchAnyOf<T> AnyOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3) {$/;"	f	namespace:Catch::Matchers
AssertionInfo	mods/catch.hpp	/^		AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo
AssertionInfo	mods/catch.hpp	/^	struct AssertionInfo {$/;"	s	namespace:Catch
AssertionResult	mods/catch.hpp	/^	class AssertionResult {$/;"	c	namespace:Catch
AssertionResultData	mods/catch.hpp	/^		AssertionResultData() : decomposedExpression(CATCH_NULL)$/;"	f	struct:Catch::AssertionResultData
AssertionResultData	mods/catch.hpp	/^	struct AssertionResultData {$/;"	s	namespace:Catch
AutoReg	mods/catch.hpp	/^			AutoReg$/;"	f	struct:Catch::AutoReg
AutoReg	mods/catch.hpp	/^	struct AutoReg {$/;"	s	namespace:Catch
BACKGROUND_FILE	db.h	85;"	d
BANNED_SITE_LENGTH	db.h	229;"	d
BAN_ALL	db.h	227;"	d
BAN_FILE	db.h	98;"	d
BAN_LIST_FORMAT	ban.cpp	116;"	d	file:
BAN_LIST_FORMAT	ban.cpp	198;"	d	file:
BAN_NEW	db.h	225;"	d
BAN_NOT	db.h	224;"	d
BAN_SELECT	db.h	226;"	d
BFS_ALREADY_THERE	utils.h	121;"	d
BFS_ERROR	utils.h	120;"	d
BFS_NO_PATH	utils.h	122;"	d
BINARY	act.wizard.cpp	2300;"	d	file:
BLOCK_SIZE	mail.h	29;"	d
BOARD_MAGIC	boards.h	17;"	d
BOARD_RNUM	boards.h	41;"	d
BOARD_VNUM	boards.h	36;"	d
BOOL_CASE	db.cpp	1583;"	d	file:
BOOL_CASE	db.cpp	1647;"	d	file:
BOOT_DB	globals.hpp	/^		enum boot_type_t { BOOT_DB,BOOT_HELL };$/;"	e	enum:mods::globals::boot_type_t
BOOT_HELL	globals.hpp	/^		enum boot_type_t { BOOT_DB,BOOT_HELL };$/;"	e	enum:mods::globals::boot_type_t
BOTH	act.wizard.cpp	2297;"	d	file:
BREACHED_EAST	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_EAST	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_NORTH	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_SOUTH	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_WEST	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_NORTH	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_SOUTH	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_WEST	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREAK	telnet.h	54;"	d
BRF	utils.h	110;"	d
BUG_FILE	db.h	91;"	d
BUY_TYPE	shop.h	20;"	d
BUY_WORD	shop.h	21;"	d
Board_clear_all	boards.cpp	/^void Board_clear_all(void) {$/;"	f
Board_clear_board	boards.cpp	/^void Board_clear_board(int board_type) {$/;"	f
Board_display_msg	boards.cpp	/^int Board_display_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board) {$/;"	f
Board_load_board	boards.cpp	/^void Board_load_board(int board_type) {$/;"	f
Board_remove_msg	boards.cpp	/^int Board_remove_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board) {$/;"	f
Board_reset_board	boards.cpp	/^void Board_reset_board(int board_type) {$/;"	f
Board_save_board	boards.cpp	/^void Board_save_board(int board_type) {$/;"	f
Board_show_board	boards.cpp	/^int Board_show_board(int board_type, struct char_data *ch, char *arg, struct obj_data *board) {$/;"	f
Board_write_message	boards.cpp	/^int Board_write_message(int board_type, struct char_data *ch, char *arg, struct obj_data *board) {$/;"	f
BorgType	mods/catch.hpp	/^		struct BorgType {$/;"	s	namespace:Catch::Detail
CAN_CARRY_N	utils.h	355;"	d
CAN_CARRY_OBJ	utils.h	465;"	d
CAN_CARRY_W	utils.h	354;"	d
CAN_GET_OBJ	utils.h	469;"	d
CAN_GO	utils.h	484;"	d
CAN_SEE	utils.h	444;"	d
CAN_SEE_IN_DARK	utils.h	357;"	d
CAN_SEE_OBJ	utils.h	462;"	d
CAN_SEE_OBJ_CARRIER	utils.h	455;"	d
CAN_WEAR	utils.h	407;"	d
CAP	utils.cpp	/^char *CAP(char *txt) {$/;"	f
CASE	db.cpp	1580;"	d	file:
CASE	db.cpp	1646;"	d	file:
CAST_POTION	spells.h	16;"	d
CAST_SCROLL	spells.h	19;"	d
CAST_SPELL	spells.h	15;"	d
CAST_STAFF	spells.h	18;"	d
CAST_UNDEFINED	spells.h	14;"	d
CAST_WAND	spells.h	17;"	d
CATCH_AND_THEN	mods/catch.hpp	12145;"	d
CATCH_AND_WHEN	mods/catch.hpp	12143;"	d
CATCH_ANON_TEST_CASE	mods/catch.hpp	12126;"	d
CATCH_ARC_ENABLED	mods/catch.hpp	1548;"	d
CATCH_ARC_STRONG	mods/catch.hpp	1568;"	d
CATCH_ARC_STRONG	mods/catch.hpp	1587;"	d
CATCH_AUTO_PTR	mods/catch.hpp	361;"	d
CATCH_AUTO_PTR	mods/catch.hpp	363;"	d
CATCH_BREAK_INTO_DEBUGGER	mods/catch.hpp	2180;"	d
CATCH_CAPTURE	mods/catch.hpp	12106;"	d
CATCH_CHECK	mods/catch.hpp	12089;"	d
CATCH_CHECKED_ELSE	mods/catch.hpp	12092;"	d
CATCH_CHECKED_IF	mods/catch.hpp	12091;"	d
CATCH_CHECK_FALSE	mods/catch.hpp	12090;"	d
CATCH_CHECK_NOFAIL	mods/catch.hpp	12093;"	d
CATCH_CHECK_NOTHROW	mods/catch.hpp	12098;"	d
CATCH_CHECK_THAT	mods/catch.hpp	12100;"	d
CATCH_CHECK_THROWS	mods/catch.hpp	12095;"	d
CATCH_CHECK_THROWS_AS	mods/catch.hpp	12096;"	d
CATCH_CHECK_THROWS_WITH	mods/catch.hpp	12097;"	d
CATCH_CONFIG_COLOUR_WINDOWS	mods/catch.hpp	8229;"	d
CATCH_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4039;"	d
CATCH_CONFIG_COUNTER	mods/catch.hpp	315;"	d
CATCH_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	291;"	d
CATCH_CONFIG_CPP11_IS_ENUM	mods/catch.hpp	294;"	d
CATCH_CONFIG_CPP11_LONG_LONG	mods/catch.hpp	303;"	d
CATCH_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	288;"	d
CATCH_CONFIG_CPP11_NULLPTR	mods/catch.hpp	285;"	d
CATCH_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	306;"	d
CATCH_CONFIG_CPP11_SHUFFLE	mods/catch.hpp	318;"	d
CATCH_CONFIG_CPP11_TUPLE	mods/catch.hpp	297;"	d
CATCH_CONFIG_CPP11_TYPE_TRAITS	mods/catch.hpp	321;"	d
CATCH_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	309;"	d
CATCH_CONFIG_POSIX_SIGNALS	mods/catch.hpp	328;"	d
CATCH_CONFIG_VARIADIC_MACROS	mods/catch.hpp	300;"	d
CATCH_CONFIG_WINDOWS_SEH	mods/catch.hpp	324;"	d
CATCH_CPP11_OR_GREATER	mods/catch.hpp	107;"	d
CATCH_CPP14_OR_GREATER	mods/catch.hpp	111;"	d
CATCH_FAIL	mods/catch.hpp	12115;"	d
CATCH_GCC_HAS_NEW_PRAGMA	mods/catch.hpp	173;"	d
CATCH_GENERATE	mods/catch.hpp	12131;"	d
CATCH_GIVEN	mods/catch.hpp	12141;"	d
CATCH_IMPL	mods/catch.hpp	53;"	d
CATCH_INFO	mods/catch.hpp	12103;"	d
CATCH_INTERNAL_CONFIG_COUNTER	mods/catch.hpp	230;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	206;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	249;"	d
CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM	mods/catch.hpp	253;"	d
CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG	mods/catch.hpp	265;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	123;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	205;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	245;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	119;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	177;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	200;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	241;"	d
CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	269;"	d
CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE	mods/catch.hpp	207;"	d
CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE	mods/catch.hpp	275;"	d
CATCH_INTERNAL_CONFIG_CPP11_TUPLE	mods/catch.hpp	257;"	d
CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS	mods/catch.hpp	208;"	d
CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS	mods/catch.hpp	278;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	201;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	272;"	d
CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS	mods/catch.hpp	141;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	mods/catch.hpp	221;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	mods/catch.hpp	261;"	d
CATCH_INTERNAL_CONFIG_WINDOWS_SEH	mods/catch.hpp	197;"	d
CATCH_INTERNAL_ERROR	mods/catch.hpp	508;"	d
CATCH_INTERNAL_LINEINFO	mods/catch.hpp	507;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	127;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	181;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	332;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	130;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	184;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	333;"	d
CATCH_METHOD_AS_TEST_CASE	mods/catch.hpp	12112;"	d
CATCH_NOEXCEPT	mods/catch.hpp	/^			virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException
CATCH_NOEXCEPT	mods/catch.hpp	338;"	d
CATCH_NOEXCEPT	mods/catch.hpp	341;"	d
CATCH_NOEXCEPT_IS	mods/catch.hpp	339;"	d
CATCH_NOEXCEPT_IS	mods/catch.hpp	342;"	d
CATCH_NOT_IMPLEMENTED	mods/catch.hpp	529;"	d
CATCH_NULL	mods/catch.hpp	347;"	d
CATCH_NULL	mods/catch.hpp	349;"	d
CATCH_OVERRIDE	mods/catch.hpp	/^			virtual void reconstructExpression(std::string& dest) const CATCH_OVERRIDE;$/;"	m	class:Catch::ResultBuilder
CATCH_OVERRIDE	mods/catch.hpp	354;"	d
CATCH_OVERRIDE	mods/catch.hpp	356;"	d
CATCH_PLATFORM_MAC	mods/catch.hpp	2126;"	d
CATCH_REGISTER_LEGACY_REPORTER	mods/catch.hpp	12129;"	d
CATCH_REGISTER_REPORTER	mods/catch.hpp	12128;"	d
CATCH_REGISTER_TAG_ALIAS	mods/catch.hpp	3154;"	d
CATCH_REGISTER_TEST_CASE	mods/catch.hpp	12113;"	d
CATCH_REQUIRE	mods/catch.hpp	12081;"	d
CATCH_REQUIRE_FALSE	mods/catch.hpp	12082;"	d
CATCH_REQUIRE_NOTHROW	mods/catch.hpp	12087;"	d
CATCH_REQUIRE_THAT	mods/catch.hpp	12101;"	d
CATCH_REQUIRE_THROWS	mods/catch.hpp	12084;"	d
CATCH_REQUIRE_THROWS_AS	mods/catch.hpp	12085;"	d
CATCH_REQUIRE_THROWS_WITH	mods/catch.hpp	12086;"	d
CATCH_SCENARIO	mods/catch.hpp	12135;"	d
CATCH_SCENARIO_METHOD	mods/catch.hpp	12136;"	d
CATCH_SCOPED_CAPTURE	mods/catch.hpp	12107;"	d
CATCH_SCOPED_INFO	mods/catch.hpp	12105;"	d
CATCH_SECTION	mods/catch.hpp	12114;"	d
CATCH_SUCCEED	mods/catch.hpp	12116;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4224;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	5432;"	d
CATCH_TEST_CASE	mods/catch.hpp	12110;"	d
CATCH_TEST_CASE_METHOD	mods/catch.hpp	12111;"	d
CATCH_THEN	mods/catch.hpp	12144;"	d
CATCH_TRANSLATE_EXCEPTION	mods/catch.hpp	12204;"	d
CATCH_TRAP	mods/catch.hpp	2154;"	d
CATCH_UNSAFE_UNRETAINED	mods/catch.hpp	1567;"	d
CATCH_UNSAFE_UNRETAINED	mods/catch.hpp	1586;"	d
CATCH_WARN	mods/catch.hpp	12104;"	d
CATCH_WHEN	mods/catch.hpp	12142;"	d
CCBLU	screen.h	33;"	d
CCCYN	screen.h	35;"	d
CCGRN	screen.h	31;"	d
CCMAG	screen.h	34;"	d
CCNRM	screen.h	29;"	d
CCRED	screen.h	30;"	d
CCWHT	screen.h	36;"	d
CCYEL	screen.h	32;"	d
CHAOTIC	mods/ai_state.hpp	/^				MANIC,CHAOTIC,RESERVED$/;"	e	enum:mods::ai_state::state
CHECK_NULL	comm.cpp	2264;"	d	file:
CHECK_PLAYER_SPECIAL	utils.h	206;"	d
CHECK_PLAYER_SPECIAL	utils.h	209;"	d
CHECK_WAIT	utils.h	367;"	d
CIRCLEMUD_VERSION	utils.h	416;"	d
CIRCLE_CRYPT	conf.h	35;"	d
CIRCLE_GNU_LIBC_MEMORY_TRACK	sysdep.h	118;"	d
CIRCLE_UNIX	conf.h	32;"	d
CIRCLE_UNSIGNED_INDEX	structs.h	69;"	d
CLARA_AUTO_PTR	mods/catch.hpp	4573;"	d
CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4225;"	d
CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4227;"	d
CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	5431;"	d
CLARA_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	4539;"	d
CLARA_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4536;"	d
CLARA_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4533;"	d
CLARA_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	4542;"	d
CLARA_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	4545;"	d
CLARA_CONFIG_MAIN	mods/catch.hpp	12073;"	d
CLARA_CONFIG_MAIN	mods/catch.hpp	59;"	d
CLARA_CONFIG_MAIN_NOT_DEFINED	mods/catch.hpp	58;"	d
CLARA_CPP11_OR_GREATER	mods/catch.hpp	4508;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	4497;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	4519;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4468;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4496;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4515;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4464;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4478;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4491;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4511;"	d
CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	4523;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	4492;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	4526;"	d
CLARA_NOEXCEPT	mods/catch.hpp	4550;"	d
CLARA_NOEXCEPT_IS	mods/catch.hpp	4551;"	d
CLARA_NULL	mods/catch.hpp	4559;"	d
CLARA_OVERRIDE	mods/catch.hpp	4566;"	d
CLARA_PLATFORM_WINDOWS	mods/catch.hpp	4588;"	d
CLASS_ABBR	utils.h	489;"	d
CLASS_ANIMAL	structs.h	163;"	d
CLASS_CLERIC	structs.h	147;"	d
CLASS_DRAGON	structs.h	164;"	d
CLASS_ENGINEER	structs.h	151;"	d
CLASS_GIANT	structs.h	165;"	d
CLASS_HUMANOID	structs.h	162;"	d
CLASS_MAGIC_USER	structs.h	146;"	d
CLASS_MARINE	structs.h	154;"	d
CLASS_MEDIC	structs.h	152;"	d
CLASS_OTHER	structs.h	160;"	d
CLASS_SNIPER	structs.h	148;"	d
CLASS_SNIPER	structs.h	153;"	d
CLASS_SUPPORT	structs.h	155;"	d
CLASS_UNDEAD	structs.h	161;"	d
CLASS_UNDEFINED	structs.h	145;"	d
CLASS_WARRIOR	structs.h	149;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	mods/catch.hpp	5663;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	mods/catch.hpp	5848;"	d
CLOSE_DOOR	act.movement.cpp	345;"	d	file:
CLOSE_SOCKET	sysdep.h	392;"	d
CMD_IS	interpreter.h	20;"	d
CMD_NAME	interpreter.h	19;"	d
CMP	utils.h	112;"	d
COLOR_LEV	screen.h	38;"	d
CONTAINER	mods/object.hpp	/^		CONTAINER,$/;"	e	enum:mods::object::type
CONT_CLOSEABLE	structs.h	421;"	d
CONT_CLOSED	structs.h	423;"	d
CONT_LOCKED	structs.h	424;"	d
CONT_PICKPROOF	structs.h	422;"	d
CON_CHPWD_GETNEW	structs.h	294;"	d
CON_CHPWD_GETOLD	structs.h	293;"	d
CON_CHPWD_VRFY	structs.h	295;"	d
CON_CLOSE	structs.h	282;"	d
CON_CNFPASSWD	structs.h	287;"	d
CON_DELCNF1	structs.h	296;"	d
CON_DELCNF2	structs.h	297;"	d
CON_DISCONNECT	structs.h	298;"	d
CON_EXDESC	structs.h	292;"	d
CON_GET_NAME	structs.h	283;"	d
CON_MENU	structs.h	291;"	d
CON_NAME_CNFRM	structs.h	284;"	d
CON_NEWPASSWD	structs.h	286;"	d
CON_PASSWORD	structs.h	285;"	d
CON_PLAYING	structs.h	281;"	d
CON_QCLASS	structs.h	289;"	d
CON_QSEX	structs.h	288;"	d
CON_RMOTD	structs.h	290;"	d
COULDNT_FIND_USER_ID	mods/meta_utils.cpp	/^		COULDNT_FIND_USER_ID = -1$/;"	e	enum:mods::meta_utils::return_codes	file:
CRASH_FILE	utils.h	115;"	d
CREATE	utils.h	159;"	d
CREATE_ARG	globals.hpp	35;"	d
CREATE_CHAR	globals.hpp	41;"	d
CREDITS_FILE	db.h	76;"	d
CRYO_FACTOR	objsave.cpp	26;"	d	file:
CRYPT	utils.h	535;"	d
CRYPT	utils.h	537;"	d
C_CMP	screen.h	25;"	d
C_NRM	screen.h	24;"	d
C_OFF	screen.h	22;"	d
C_SPR	screen.h	23;"	d
CaseSensitive	mods/catch.hpp	/^	struct CaseSensitive {$/;"	s	namespace:Catch
CastleGuard	castle.cpp	/^SPECIAL(CastleGuard);$/;"	v
Catch	mods/catch.hpp	/^namespace Catch {$/;"	n
Choice	mods/catch.hpp	/^		enum Choice {$/;"	g	struct:Catch::CaseSensitive
ContinueOnFailure	mods/catch.hpp	/^			ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
CopyableStream	mods/catch.hpp	/^		CopyableStream() {}$/;"	f	struct:Catch::CopyableStream
CopyableStream	mods/catch.hpp	/^		CopyableStream(CopyableStream const& other) {$/;"	f	struct:Catch::CopyableStream
CopyableStream	mods/catch.hpp	/^	struct CopyableStream {$/;"	s	namespace:Catch
Crash_calculate_rent	objsave.cpp	/^void Crash_calculate_rent(struct obj_data *obj, int *cost) {$/;"	f
Crash_clean_file	objsave.cpp	/^int Crash_clean_file(char *name) {$/;"	f
Crash_crashsave	objsave.cpp	/^void Crash_crashsave(struct char_data *ch) {$/;"	f
Crash_cryosave	objsave.cpp	/^void Crash_cryosave(struct char_data *ch, int cost) {$/;"	f
Crash_delete_crashfile	objsave.cpp	/^int Crash_delete_crashfile(struct char_data *ch) {$/;"	f
Crash_delete_file	objsave.cpp	/^int Crash_delete_file(char *name) {$/;"	f
Crash_extract_expensive	objsave.cpp	/^void Crash_extract_expensive(struct obj_data *obj) {$/;"	f
Crash_extract_norent_eq	objsave.cpp	/^void Crash_extract_norent_eq(struct char_data *ch) {$/;"	f
Crash_extract_norents	objsave.cpp	/^void Crash_extract_norents(struct obj_data *obj) {$/;"	f
Crash_extract_objs	objsave.cpp	/^void Crash_extract_objs(struct obj_data *obj) {$/;"	f
Crash_idlesave	objsave.cpp	/^void Crash_idlesave(struct char_data *ch) {$/;"	f
Crash_is_unrentable	objsave.cpp	/^int Crash_is_unrentable(struct obj_data *obj) {$/;"	f
Crash_listrent	objsave.cpp	/^void Crash_listrent(struct char_data *ch, char *name) {$/;"	f
Crash_load	objsave.cpp	/^int Crash_load(struct char_data *ch) {$/;"	f
Crash_offer_rent	objsave.cpp	/^int Crash_offer_rent(struct char_data *ch, struct char_data *recep,$/;"	f
Crash_rent_deadline	objsave.cpp	/^void Crash_rent_deadline(struct char_data *ch, struct char_data *recep,$/;"	f
Crash_rentsave	objsave.cpp	/^void Crash_rentsave(struct char_data *ch, int cost) {$/;"	f
Crash_report_rent	objsave.cpp	/^void Crash_report_rent(struct char_data *ch, struct char_data *recep,$/;"	f
Crash_report_unrentables	objsave.cpp	/^int Crash_report_unrentables(struct char_data *ch, struct char_data *recep,$/;"	f
Crash_restore_weight	objsave.cpp	/^void Crash_restore_weight(struct obj_data *obj) {$/;"	f
Crash_save	objsave.cpp	/^int Crash_save(struct obj_data *obj, FILE *fp, int location) {$/;"	f
Crash_save_all	objsave.cpp	/^void Crash_save_all(void) {$/;"	f
Crash_write_rentcode	objsave.cpp	/^int Crash_write_rentcode(struct char_data *ch, FILE *fl, struct rent_info *rent) {$/;"	f
DATA_BLOCK_DATASIZE	mail.h	75;"	d
DBGET	globals.hpp	34;"	d
DBSET	globals.hpp	33;"	d
DB_BOOT_HLP	db.h	20;"	d
DB_BOOT_MOB	db.h	16;"	d
DB_BOOT_OBJ	db.h	17;"	d
DB_BOOT_SHP	db.h	19;"	d
DB_BOOT_WLD	db.h	15;"	d
DB_BOOT_ZON	db.h	18;"	d
DEFAULT_STAFF_LVL	spells.h	11;"	d
DEFAULT_WAND_LVL	spells.h	12;"	d
DELETED_BLOCK	mail.h	55;"	d
DESCRIBE_TESTING_SUITE	mods/testing_index.hpp	4;"	d
DFLT_DIR	config.cpp	/^const char *DFLT_DIR = "lib";$/;"	v
DFLT_IP	config.cpp	/^const char *DFLT_IP = NULL; \/* bind to all interfaces *\/$/;"	v
DFLT_PORT	config.cpp	/^ush_int DFLT_PORT = 4000;$/;"	v
DM	telnet.h	55;"	d
DO	telnet.h	44;"	d
DONT	telnet.h	43;"	d
DOOR_IS_BREACHED	act.movement.cpp	480;"	d	file:
DOOR_IS_CLOSED	act.movement.cpp	484;"	d	file:
DOOR_IS_LOCKED	act.movement.cpp	485;"	d	file:
DOOR_IS_OPEN	act.movement.cpp	471;"	d	file:
DOOR_IS_OPENABLE	act.movement.cpp	467;"	d	file:
DOOR_IS_PICKPROOF	act.movement.cpp	477;"	d	file:
DOOR_IS_THERMITE	act.movement.cpp	482;"	d	file:
DOOR_IS_UNLOCKED	act.movement.cpp	474;"	d	file:
DOOR_KEY	act.movement.cpp	486;"	d	file:
DOWN	structs.h	96;"	d
DP_C_LDOUBLE	bsd-snprintf.cpp	151;"	d	file:
DP_C_LONG	bsd-snprintf.cpp	150;"	d	file:
DP_C_LONG_LONG	bsd-snprintf.cpp	152;"	d	file:
DP_C_SHORT	bsd-snprintf.cpp	149;"	d	file:
DP_F_MINUS	bsd-snprintf.cpp	140;"	d	file:
DP_F_NUM	bsd-snprintf.cpp	143;"	d	file:
DP_F_PLUS	bsd-snprintf.cpp	141;"	d	file:
DP_F_SPACE	bsd-snprintf.cpp	142;"	d	file:
DP_F_UNSIGNED	bsd-snprintf.cpp	146;"	d	file:
DP_F_UP	bsd-snprintf.cpp	145;"	d	file:
DP_F_ZERO	bsd-snprintf.cpp	144;"	d	file:
DP_S_CONV	bsd-snprintf.cpp	136;"	d	file:
DP_S_DEFAULT	bsd-snprintf.cpp	130;"	d	file:
DP_S_DONE	bsd-snprintf.cpp	137;"	d	file:
DP_S_DOT	bsd-snprintf.cpp	133;"	d	file:
DP_S_FLAGS	bsd-snprintf.cpp	131;"	d	file:
DP_S_MAX	bsd-snprintf.cpp	134;"	d	file:
DP_S_MIN	bsd-snprintf.cpp	132;"	d	file:
DP_S_MOD	bsd-snprintf.cpp	135;"	d	file:
DRONE	mods/player.hpp	/^				PLAYER, MOB, DRONE,$/;"	e	enum:mods::player::player_type_enum_t
DRONE_MUTED_DESCRIPTOR	mods/player.hpp	/^				DRONE_MUTED_DESCRIPTOR$/;"	e	enum:mods::player::player_type_enum_t
DRONE_OWNER_KEY	mods/drone.cpp	12;"	d	file:
DRONE_WEAPON_SET_NUM	mods/drone.hpp	14;"	d
DRUNK	structs.h	450;"	d
DT_FORMAT	mods/js.cpp	8;"	d	file:
DT_FORMAT	mods/js.hpp	19;"	d
DYNAMIC_FORMAT_STRING	mods/prefs.hpp	16;"	d
DYN_DB_GET	mods/prefs.hpp	18;"	d
DYN_DB_SET	mods/prefs.hpp	17;"	d
DecomposedExpression	mods/catch.hpp	/^	struct DecomposedExpression {$/;"	s	namespace:Catch
Detail	mods/catch.hpp	/^	namespace Detail {$/;"	n	namespace:Catch
DicknDavid	castle.cpp	/^SPECIAL(DicknDavid);$/;"	v
DidntThrowException	mods/catch.hpp	/^			DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
EAST	structs.h	92;"	d
EC	telnet.h	50;"	d
EL	telnet.h	49;"	d
ENCRYPT_CNT	telnet.h	292;"	d
ENCRYPT_DEC_KEYID	telnet.h	291;"	d
ENCRYPT_ENC_KEYID	telnet.h	290;"	d
ENCRYPT_END	telnet.h	287;"	d
ENCRYPT_IS	telnet.h	283;"	d
ENCRYPT_NAME	telnet.h	315;"	d
ENCRYPT_NAME_OK	telnet.h	314;"	d
ENCRYPT_REPLY	telnet.h	285;"	d
ENCRYPT_REQEND	telnet.h	289;"	d
ENCRYPT_REQSTART	telnet.h	288;"	d
ENCRYPT_START	telnet.h	286;"	d
ENCRYPT_SUPPORT	telnet.h	284;"	d
ENCTYPE_ANY	telnet.h	294;"	d
ENCTYPE_CNT	telnet.h	297;"	d
ENCTYPE_DES_CFB64	telnet.h	295;"	d
ENCTYPE_DES_OFB64	telnet.h	296;"	d
ENCTYPE_NAME	telnet.h	318;"	d
ENCTYPE_NAME_OK	telnet.h	317;"	d
END_OF	shop.h	57;"	d
ENV_ESC	telnet.h	239;"	d
ENV_USERVAR	telnet.h	240;"	d
EOR	telnet.h	58;"	d
ETEXT_FILE	utils.h	116;"	d
EXDSCR_LENGTH	structs.h	540;"	d
EXEC	mods/lmdb.hpp	/^		EXEC, UPDATE, INSERT $/;"	e	enum:mods::lmdb::transact_type_t
EXIT	utils.h	482;"	d
EXITN	act.movement.cpp	341;"	d	file:
EXIT_FLAGGED	utils.h	232;"	d
EXP_MAX	class.cpp	3711;"	d	file:
EXTERN_ACT	types.hpp	9;"	d
EX_BREACHED	structs.h	125;"	d
EX_CLOSED	structs.h	121;"	d
EX_ISDOOR	structs.h	120;"	d
EX_LOCKED	structs.h	122;"	d
EX_PICKPROOF	structs.h	123;"	d
EX_REINFORCED	structs.h	124;"	d
EnumStringMaker	mods/catch.hpp	/^		struct EnumStringMaker {$/;"	s	namespace:Catch::Detail
EnumStringMaker	mods/catch.hpp	/^		struct EnumStringMaker<T,true> {$/;"	s	namespace:Catch::Detail
Evaluator	mods/catch.hpp	/^		class Evaluator {};$/;"	c	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Exception	mods/catch.hpp	/^			Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
ExplicitFailure	mods/catch.hpp	/^			ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
ExpressionFailed	mods/catch.hpp	/^			ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
FAILURE	mods/behaviour_tree_status.hpp	/^		FAILURE,$/;"	e	enum:mods::behaviour_tree_status
FALSE	utils.h	514;"	d
FASTBOOT_FILE	db.h	53;"	d
FASTBOOT_FILE	db.h	57;"	d
FASTBOOT_FILE	db.h	61;"	d
FD_CLR	comm.cpp	219;"	d	file:
FD_CLR	comm.cpp	223;"	d	file:
FD_ISSET	comm.cpp	218;"	d	file:
FD_ISSET	comm.cpp	222;"	d	file:
FD_SET	comm.cpp	217;"	d	file:
FD_SET	comm.cpp	221;"	d	file:
FD_SETSIZE	sysdep.h	371;"	d
FD_ZERO	comm.cpp	216;"	d	file:
FD_ZERO	comm.cpp	220;"	d	file:
FIGHT	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
FIGHTING	utils.h	316;"	d
FILENAME	boards.h	40;"	d
FIND_ALL	handler.h	76;"	d
FIND_ALLDOT	handler.h	77;"	d
FIND_CHAR_ROOM	handler.h	85;"	d
FIND_CHAR_WORLD	handler.h	86;"	d
FIND_INDIV	handler.h	75;"	d
FIND_OBJ_EQUIP	handler.h	90;"	d
FIND_OBJ_INV	handler.h	87;"	d
FIND_OBJ_ROOM	handler.h	88;"	d
FIND_OBJ_WORLD	handler.h	89;"	d
FULL	structs.h	451;"	d
FailureBit	mods/catch.hpp	/^			FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
FalseTest	mods/catch.hpp	/^			FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
FalseType	mods/catch.hpp	/^		struct FalseType {$/;"	s	namespace:Catch::Detail
FatalErrorCondition	mods/catch.hpp	/^			FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Flags	mods/catch.hpp	/^		enum Flags {$/;"	g	struct:Catch::ResultDisposition
Free_Invalid_List	ban.cpp	/^void Free_Invalid_List(void) {$/;"	f
GA	telnet.h	48;"	d
GARBAGE_SPACE	structs.h	526;"	d
GET_AC	utils.h	300;"	d
GET_ADD	utils.h	292;"	d
GET_AGE	utils.h	267;"	d
GET_ALIASES	utils.h	330;"	d
GET_ALIGNMENT	utils.h	319;"	d
GET_BAD_PWS	utils.h	326;"	d
GET_BANK_GOLD	utils.h	308;"	d
GET_CHA	utils.h	297;"	d
GET_CLASS	utils.h	285;"	d
GET_CON	utils.h	296;"	d
GET_COND	utils.h	321;"	d
GET_DAMROLL	utils.h	310;"	d
GET_DEFAULT_POS	utils.h	343;"	d
GET_DEX	utils.h	293;"	d
GET_EQ	utils.h	336;"	d
GET_EXP	utils.h	299;"	d
GET_FREEZE_LEV	utils.h	325;"	d
GET_GOLD	utils.h	307;"	d
GET_HEIGHT	utils.h	287;"	d
GET_HIT	utils.h	301;"	d
GET_HITROLL	utils.h	309;"	d
GET_HOME	utils.h	286;"	d
GET_IDNUM	utils.h	313;"	d
GET_INT	utils.h	294;"	d
GET_INVIS_LEV	utils.h	323;"	d
GET_LAST_OLC_MODE	utils.h	329;"	d
GET_LAST_OLC_TARG	utils.h	328;"	d
GET_LAST_TELL	utils.h	331;"	d
GET_LEVEL	utils.h	273;"	d
GET_LOADROOM	utils.h	322;"	d
GET_MANA	utils.h	305;"	d
GET_MAX_HIT	utils.h	302;"	d
GET_MAX_MANA	utils.h	306;"	d
GET_MAX_MOVE	utils.h	304;"	d
GET_MOB_RNUM	utils.h	339;"	d
GET_MOB_SPEC	utils.h	338;"	d
GET_MOB_VNUM	utils.h	340;"	d
GET_MOB_WAIT	utils.h	368;"	d
GET_MOVE	utils.h	303;"	d
GET_NAME	utils.h	270;"	d
GET_OBJ_AFFECT	utils.h	392;"	d
GET_OBJ_COST	utils.h	390;"	d
GET_OBJ_EXTRA	utils.h	393;"	d
GET_OBJ_RENT	utils.h	391;"	d
GET_OBJ_RNUM	utils.h	398;"	d
GET_OBJ_SPEC	utils.h	401;"	d
GET_OBJ_TIMER	utils.h	397;"	d
GET_OBJ_TYPE	utils.h	389;"	d
GET_OBJ_VAL	utils.h	395;"	d
GET_OBJ_VNUM	utils.h	399;"	d
GET_OBJ_WEAR	utils.h	394;"	d
GET_OBJ_WEIGHT	utils.h	396;"	d
GET_PASSWD	utils.h	274;"	d
GET_PC_NAME	utils.h	269;"	d
GET_PFILEPOS	utils.h	275;"	d
GET_POS	utils.h	312;"	d
GET_REAL_LEVEL	utils.h	281;"	d
GET_ROOM_SPEC	utils.h	258;"	d
GET_ROOM_VNUM	utils.h	256;"	d
GET_SAVE	utils.h	318;"	d
GET_SEX	utils.h	289;"	d
GET_SKILL	utils.h	333;"	d
GET_STR	utils.h	291;"	d
GET_TALK	utils.h	327;"	d
GET_TITLE	utils.h	272;"	d
GET_WAIT_STATE	utils.h	370;"	d
GET_WAS_IN	utils.h	266;"	d
GET_WEIGHT	utils.h	288;"	d
GET_WIMP_LEV	utils.h	324;"	d
GET_WIS	utils.h	295;"	d
GIVEN	mods/catch.hpp	12214;"	d
GREETINGS	db.cpp	/^std::string GREETINGS = "";		\/* opening credits screen	*\/$/;"	v
GREETINGS_FILE	db.h	80;"	d
GRENADE	mods/player.hpp	/^		enum mask_type { SMG, SNIPE, SHOTGUN, GRENADE };$/;"	e	enum:mods::weapon::mask_type
GRENADE_EXPLOSION	mods/ai_state.hpp	/^				GRENADE_FLIES_BY,GRENADE_EXPLOSION,$/;"	e	enum:mods::ai_state::event_type_t
GRENADE_FLIES_BY	mods/ai_state.hpp	/^				GRENADE_FLIES_BY,GRENADE_EXPLOSION,$/;"	e	enum:mods::ai_state::event_type_t
HANDBOOK_FILE	db.h	87;"	d
HAS_RLIMIT	sysdep.h	407;"	d
HAS_SPELL_ROUTINE	utils.h	237;"	d
HAVE_ARPA_INET_H	conf.h	92;"	d
HAVE_ARPA_TELNET_H	conf.h	95;"	d
HAVE_ASSERT_H	conf.h	98;"	d
HAVE_CRYPT_H	conf.h	101;"	d
HAVE_ERRNO_H	conf.h	104;"	d
HAVE_FCNTL_H	conf.h	107;"	d
HAVE_GETTIMEOFDAY	conf.h	50;"	d
HAVE_INET_ADDR	conf.h	53;"	d
HAVE_INET_ATON	conf.h	56;"	d
HAVE_LIMITS_H	conf.h	110;"	d
HAVE_MCHECK_H	conf.h	113;"	d
HAVE_MEMORY_H	conf.h	116;"	d
HAVE_NETDB_H	conf.h	122;"	d
HAVE_NETINET_IN_H	conf.h	125;"	d
HAVE_SELECT	conf.h	59;"	d
HAVE_SIGNAL_H	conf.h	128;"	d
HAVE_SNPRINTF	bsd-snprintf.cpp	101;"	d	file:
HAVE_SNPRINTF	conf.h	62;"	d
HAVE_STRCASECMP	conf.h	65;"	d
HAVE_STRDUP	conf.h	68;"	d
HAVE_STRERROR	conf.h	71;"	d
HAVE_STRINGS_H	conf.h	134;"	d
HAVE_STRING_H	conf.h	131;"	d
HAVE_STRNCASECMP	conf.h	80;"	d
HAVE_STRSTR	conf.h	86;"	d
HAVE_STRUCT_IN_ADDR	conf.h	41;"	d
HAVE_SYS_FCNTL_H	conf.h	137;"	d
HAVE_SYS_RESOURCE_H	conf.h	140;"	d
HAVE_SYS_SELECT_H	conf.h	143;"	d
HAVE_SYS_SOCKET_H	conf.h	146;"	d
HAVE_SYS_STAT_H	conf.h	149;"	d
HAVE_SYS_TIME_H	conf.h	152;"	d
HAVE_SYS_TYPES_H	conf.h	155;"	d
HAVE_SYS_UIO_H	conf.h	158;"	d
HAVE_SYS_WAIT_H	conf.h	11;"	d
HAVE_UNISTD_H	conf.h	161;"	d
HAVE_VPRINTF	conf.h	14;"	d
HAVE_VSNPRINTF	bsd-snprintf.cpp	102;"	d	file:
HAVE_VSNPRINTF	conf.h	89;"	d
HCONTROL_FILE	db.h	99;"	d
HCONTROL_FORMAT	house.cpp	/^const char *HCONTROL_FORMAT =$/;"	v
HEADER_BLOCK	mail.h	53;"	d
HEADER_BLOCK_DATASIZE	mail.h	71;"	d
HELP_PAGE_FILE	db.h	81;"	d
HISTORY_SIZE	structs.h	531;"	d
HLP_PREFIX	db.h	74;"	d
HMHR	utils.h	421;"	d
HOST_LENGTH	structs.h	539;"	d
HOUSE_PRIVATE	house.h	4;"	d
HSHR	utils.h	419;"	d
HSSH	utils.h	420;"	d
HUNTING	utils.h	317;"	d
House_boot	house.cpp	/^void House_boot(void) {$/;"	f
House_boot	mods/hell.hpp	/^	constexpr inline bool House_boot = false;$/;"	m	namespace:mods::hell
House_can_enter	house.cpp	/^int House_can_enter(struct char_data *ch, room_vnum house) {$/;"	f
House_crashsave	house.cpp	/^void House_crashsave(room_vnum vnum) {$/;"	f
House_delete_file	house.cpp	/^void House_delete_file(room_vnum vnum) {$/;"	f
House_get_filename	house.cpp	/^int House_get_filename(room_vnum vnum, char *filename, size_t maxlen) {$/;"	f
House_list_guests	house.cpp	/^void House_list_guests(struct char_data *ch, int i, int quiet) {$/;"	f
House_listrent	house.cpp	/^void House_listrent(struct char_data *ch, room_vnum vnum) {$/;"	f
House_load	house.cpp	/^int House_load(room_vnum vnum) {$/;"	f
House_restore_weight	house.cpp	/^void House_restore_weight(struct obj_data *obj) {$/;"	f
House_save	house.cpp	/^int House_save(struct obj_data *obj, FILE *fp) {$/;"	f
House_save_all	house.cpp	/^void House_save_all(void) {$/;"	f
House_save_control	house.cpp	/^void House_save_control(void) {$/;"	f
IAC	telnet.h	42;"	d
IContext	mods/catch.hpp	/^	struct IContext {$/;"	s	namespace:Catch
IDEA_FILE	db.h	89;"	d
IDLE	config.hpp	/^		constexpr static room_type_t IDLE = 5;$/;"	m	namespace:config::rooms
IDXTYPE	structs.h	72;"	d
IGNORE_ALL	structs.h	/^			IGNORE_ALL,$/;"	e	enum:mods::descriptor_data::queue_behaviour_enum_t
IGeneratorInfo	mods/catch.hpp	/^	struct IGeneratorInfo {$/;"	s	namespace:Catch
IGeneratorsForTest	mods/catch.hpp	/^	struct IGeneratorsForTest {$/;"	s	namespace:Catch
IMMLIST_FILE	db.h	84;"	d
IMM_CAN_SEE	utils.h	438;"	d
IMOTD_FILE	db.h	79;"	d
IMutableContext	mods/catch.hpp	/^	struct IMutableContext : IContext {$/;"	s	namespace:Catch
INDEX_FILE	db.h	67;"	d
INDEX_SIZE	boards.h	15;"	d
INFO_FILE	db.h	82;"	d
INSERT	mods/lmdb.hpp	/^		EXEC, UPDATE, INSERT $/;"	e	enum:mods::lmdb::transact_type_t
INTERNAL_CATCH_ELSE	mods/catch.hpp	2276;"	d
INTERNAL_CATCH_GENERATE	mods/catch.hpp	2706;"	d
INTERNAL_CATCH_IF	mods/catch.hpp	2271;"	d
INTERNAL_CATCH_INFO	mods/catch.hpp	2351;"	d
INTERNAL_CATCH_LINESTR	mods/catch.hpp	2704;"	d
INTERNAL_CATCH_LINESTR2	mods/catch.hpp	2703;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	mods/catch.hpp	806;"	d
INTERNAL_CATCH_MSG	mods/catch.hpp	2333;"	d
INTERNAL_CATCH_NO_THROW	mods/catch.hpp	2281;"	d
INTERNAL_CATCH_REACT	mods/catch.hpp	2241;"	d
INTERNAL_CATCH_REGISTER_LEGACY_REPORTER	mods/catch.hpp	10386;"	d
INTERNAL_CATCH_REGISTER_LISTENER	mods/catch.hpp	10392;"	d
INTERNAL_CATCH_REGISTER_REPORTER	mods/catch.hpp	10389;"	d
INTERNAL_CATCH_REGISTER_TESTCASE	mods/catch.hpp	822;"	d
INTERNAL_CATCH_SECTION	mods/catch.hpp	2521;"	d
INTERNAL_CATCH_STRINGIFY	mods/catch.hpp	375;"	d
INTERNAL_CATCH_STRINGIFY2	mods/catch.hpp	374;"	d
INTERNAL_CATCH_TEST	mods/catch.hpp	2255;"	d
INTERNAL_CATCH_TESTCASE	mods/catch.hpp	802;"	d
INTERNAL_CATCH_TESTCASE2	mods/catch.hpp	798;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	mods/catch.hpp	818;"	d
INTERNAL_CATCH_TEST_CASE_METHOD2	mods/catch.hpp	810;"	d
INTERNAL_CATCH_THROWS	mods/catch.hpp	2295;"	d
INTERNAL_CATCH_THROWS_AS	mods/catch.hpp	2312;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION	mods/catch.hpp	2809;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION2	mods/catch.hpp	2804;"	d
INTERNAL_CATCH_UNIQUE_NAME	mods/catch.hpp	369;"	d
INTERNAL_CATCH_UNIQUE_NAME	mods/catch.hpp	371;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE	mods/catch.hpp	367;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE2	mods/catch.hpp	366;"	d
INTERNAL_CHECK_THAT	mods/catch.hpp	2355;"	d
INVALID_SOCKET	comm.cpp	73;"	d	file:
INVIS_OK	utils.h	432;"	d
INVIS_OK_OBJ	utils.h	451;"	d
IN_ROOM	utils.h	265;"	d
IP	telnet.h	53;"	d
ISNEWL	utils.h	150;"	d
IS_AFFECTED	utils.h	240;"	d
IS_CARRYING_N	utils.h	315;"	d
IS_CARRYING_W	utils.h	314;"	d
IS_CLERIC	utils.h	493;"	d
IS_CLOSED	graph.cpp	57;"	d	file:
IS_CORPSE	utils.h	404;"	d
IS_DARK	utils.h	252;"	d
IS_DIRECTION	globals.hpp	30;"	d
IS_EVIL	utils.h	361;"	d
IS_GOD	shop.h	56;"	d
IS_GOOD	utils.h	360;"	d
IS_LIGHT	utils.h	253;"	d
IS_MAGIC_USER	utils.h	491;"	d
IS_MARKED	graph.cpp	55;"	d	file:
IS_MOB	utils.h	224;"	d
IS_MOVE	interpreter.h	21;"	d
IS_NEUTRAL	utils.h	362;"	d
IS_NPC	utils.h	223;"	d
IS_SET	utils.h	192;"	d
IS_SUPPORT	utils.h	499;"	d
IS_THIEF	utils.h	495;"	d
IS_WARRIOR	utils.h	497;"	d
IS_WEAPON	fight.cpp	88;"	d	file:
IS_WEAPON_LOADED	mods/weapon.hpp	9;"	d
IShared	mods/catch.hpp	/^	struct IShared : NonCopyable {$/;"	s	namespace:Catch
ITEM_ANTI_CLERIC	structs.h	386;"	d
ITEM_ANTI_EVIL	structs.h	383;"	d
ITEM_ANTI_GOOD	structs.h	382;"	d
ITEM_ANTI_MAGIC_USER	structs.h	385;"	d
ITEM_ANTI_NEUTRAL	structs.h	384;"	d
ITEM_ANTI_THIEF	structs.h	387;"	d
ITEM_ANTI_WARRIOR	structs.h	388;"	d
ITEM_ARMOR	structs.h	337;"	d
ITEM_BLESS	structs.h	381;"	d
ITEM_BOAT	structs.h	350;"	d
ITEM_CONTAINER	structs.h	343;"	d
ITEM_DRINKCON	structs.h	345;"	d
ITEM_FIREWEAPON	structs.h	334;"	d
ITEM_FOOD	structs.h	347;"	d
ITEM_FOUNTAIN	structs.h	351;"	d
ITEM_GLOW	structs.h	373;"	d
ITEM_HUM	structs.h	374;"	d
ITEM_INVISIBLE	structs.h	378;"	d
ITEM_KEY	structs.h	346;"	d
ITEM_LIGHT	structs.h	329;"	d
ITEM_MAGIC	structs.h	379;"	d
ITEM_MISSILE	structs.h	335;"	d
ITEM_MONEY	structs.h	348;"	d
ITEM_NODONATE	structs.h	376;"	d
ITEM_NODROP	structs.h	380;"	d
ITEM_NOINVIS	structs.h	377;"	d
ITEM_NORENT	structs.h	375;"	d
ITEM_NOSELL	structs.h	389;"	d
ITEM_NOTE	structs.h	344;"	d
ITEM_OTHER	structs.h	340;"	d
ITEM_PEN	structs.h	349;"	d
ITEM_POTION	structs.h	338;"	d
ITEM_SCROLL	structs.h	330;"	d
ITEM_STAFF	structs.h	332;"	d
ITEM_TRAP	structs.h	342;"	d
ITEM_TRASH	structs.h	341;"	d
ITEM_TREASURE	structs.h	336;"	d
ITEM_WAND	structs.h	331;"	d
ITEM_WEAPON	structs.h	333;"	d
ITEM_WEAR_ABOUT	structs.h	365;"	d
ITEM_WEAR_ARMS	structs.h	363;"	d
ITEM_WEAR_BODY	structs.h	358;"	d
ITEM_WEAR_FEET	structs.h	361;"	d
ITEM_WEAR_FINGER	structs.h	356;"	d
ITEM_WEAR_HANDS	structs.h	362;"	d
ITEM_WEAR_HEAD	structs.h	359;"	d
ITEM_WEAR_HOLD	structs.h	369;"	d
ITEM_WEAR_LEGS	structs.h	360;"	d
ITEM_WEAR_NECK	structs.h	357;"	d
ITEM_WEAR_SHIELD	structs.h	364;"	d
ITEM_WEAR_TAKE	structs.h	355;"	d
ITEM_WEAR_WAIST	structs.h	366;"	d
ITEM_WEAR_WIELD	structs.h	368;"	d
ITEM_WEAR_WRIST	structs.h	367;"	d
ITEM_WORN	structs.h	339;"	d
ITestCase	mods/catch.hpp	/^	struct ITestCase : IShared {$/;"	s	namespace:Catch
ITestCaseRegistry	mods/catch.hpp	/^	struct ITestCaseRegistry {$/;"	s	namespace:Catch
Impl	mods/catch.hpp	/^		namespace Impl {$/;"	n	namespace:Catch::Matchers
Info	mods/catch.hpp	/^			Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Internal	mods/catch.hpp	/^	namespace Internal {$/;"	n	namespace:Catch
IsEqualTo	mods/catch.hpp	/^			IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThan	mods/catch.hpp	/^			IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThanOrEqualTo	mods/catch.hpp	/^			IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
IsLessThan	mods/catch.hpp	/^			IsLessThan,$/;"	e	enum:Catch::Internal::Operator
IsLessThanOrEqualTo	mods/catch.hpp	/^			IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsNotEqualTo	mods/catch.hpp	/^			IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsStreamInsertable	mods/catch.hpp	/^		struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
JS_PATH	mods/js.cpp	/^		constexpr static const char * JS_PATH = "..\/lib\/js\/";$/;"	m	namespace:mods::js	file:
JS_PROFILES_PATH	mods/js.cpp	/^		constexpr static const char * JS_PROFILES_PATH = "..\/lib\/js\/profiles\/";$/;"	m	namespace:mods::js	file:
JS_READ_CHUNK_SIZE	mods/js.hpp	18;"	d
JS_TEST_PATH	mods/js.cpp	/^		constexpr static const char * JS_TEST_PATH = "..\/lib\/js\/tests\/";$/;"	m	namespace:mods::js	file:
James	castle.cpp	/^SPECIAL(James);$/;"	v
KBLU	screen.h	15;"	d
KCYN	screen.h	17;"	d
KEY_FETCHED_OKAY	mods/lmdb.hpp	/^		constexpr static int KEY_FETCHED_OKAY = 1;$/;"	m	struct:mods::lmdb::_db_handle
KEY_NOT_FOUND	mods/lmdb.hpp	/^		constexpr static int KEY_NOT_FOUND = 0;$/;"	m	struct:mods::lmdb::_db_handle
KGRN	screen.h	13;"	d
KILLSCRIPT_FILE	db.h	54;"	d
KILLSCRIPT_FILE	db.h	58;"	d
KILLSCRIPT_FILE	db.h	62;"	d
KMAG	screen.h	16;"	d
KNRM	screen.h	11;"	d
KNUL	screen.h	19;"	d
KRED	screen.h	12;"	d
KWHT	screen.h	18;"	d
KYEL	screen.h	14;"	d
LARGE_BUFSIZE	structs.h	529;"	d
LAST_BLOCK	mail.h	54;"	d
LEAF	mods/behaviour_tree_node.hpp	/^		enum node_type_t { SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
LEARNED	spec_procs.cpp	132;"	d	file:
LEARNED_LEVEL	spec_procs.cpp	124;"	d	file:
LFLOW_OFF	telnet.h	153;"	d
LFLOW_ON	telnet.h	154;"	d
LFLOW_RESTART_ANY	telnet.h	155;"	d
LFLOW_RESTART_XON	telnet.h	156;"	d
LIB_ETC	db.h	27;"	d
LIB_ETC	db.h	38;"	d
LIB_HOUSE	db.h	31;"	d
LIB_HOUSE	db.h	42;"	d
LIB_MISC	db.h	26;"	d
LIB_MISC	db.h	37;"	d
LIB_PLRALIAS	db.h	30;"	d
LIB_PLRALIAS	db.h	41;"	d
LIB_PLROBJS	db.h	29;"	d
LIB_PLROBJS	db.h	40;"	d
LIB_PLRTEXT	db.h	28;"	d
LIB_PLRTEXT	db.h	39;"	d
LIB_TEXT	db.h	24;"	d
LIB_TEXT	db.h	35;"	d
LIB_TEXT_HELP	db.h	25;"	d
LIB_TEXT_HELP	db.h	36;"	d
LIB_WORLD	db.h	23;"	d
LIB_WORLD	db.h	34;"	d
LIGHT_OK	utils.h	429;"	d
LIQ_ALE	structs.h	431;"	d
LIQ_BEER	structs.h	429;"	d
LIQ_BLOOD	structs.h	441;"	d
LIQ_CLEARWATER	structs.h	443;"	d
LIQ_COFFE	structs.h	440;"	d
LIQ_DARKALE	structs.h	432;"	d
LIQ_FIREBRT	structs.h	435;"	d
LIQ_LEMONADE	structs.h	434;"	d
LIQ_LOCALSPC	structs.h	436;"	d
LIQ_MILK	structs.h	438;"	d
LIQ_SALTWATER	structs.h	442;"	d
LIQ_SLIME	structs.h	437;"	d
LIQ_TEA	structs.h	439;"	d
LIQ_WATER	structs.h	428;"	d
LIQ_WHISKY	structs.h	433;"	d
LIQ_WINE	structs.h	430;"	d
LIST_PRODUCE	shop.h	68;"	d
LIST_ROOM	shop.h	70;"	d
LIST_TRADE	shop.h	69;"	d
LM_FORWARDMASK	telnet.h	163;"	d
LM_MODE	telnet.h	162;"	d
LM_SLC	telnet.h	164;"	d
LOADED	mods/weapon.hpp	8;"	d
LOCK_DOOR	act.movement.cpp	348;"	d	file:
LOC_INVENTORY	objsave.cpp	28;"	d	file:
LOGNAME	config.cpp	/^const char *LOGNAME = NULL;$/;"	v
LONG_STRING	bsd-snprintf.cpp	815;"	d	file:
LOWER	utils.h	147;"	d
LVL_FREEZE	structs.h	496;"	d
LVL_GOD	structs.h	492;"	d
LVL_GRGOD	structs.h	491;"	d
LVL_IMMORT	structs.h	493;"	d
LVL_IMPL	structs.h	490;"	d
MAGIC_NUMBER	structs.h	499;"	d
MAG_AFFECTS	spells.h	22;"	d
MAG_ALTER_OBJS	spells.h	25;"	d
MAG_AREAS	spells.h	28;"	d
MAG_CREATIONS	spells.h	30;"	d
MAG_DAMAGE	spells.h	21;"	d
MAG_GROUPS	spells.h	26;"	d
MAG_MANUAL	spells.h	31;"	d
MAG_MASSES	spells.h	27;"	d
MAG_POINTS	spells.h	24;"	d
MAG_SUMMONS	spells.h	29;"	d
MAG_UNAFFECTS	spells.h	23;"	d
MAIL_FILE	db.h	97;"	d
MAIN_PLAYER_INDEX	mods/player-scaffolding.hpp	/^		constexpr static std::size_t MAIN_PLAYER_INDEX = 0;$/;"	m	struct:mods::player_scaffolding
MANIC	mods/ai_state.hpp	/^				MANIC,CHAOTIC,RESERVED$/;"	e	enum:mods::ai_state::state
MANUAL_SPELL	spells.h	216;"	d
MARK	graph.cpp	53;"	d	file:
MAX	bsd-snprintf.cpp	97;"	d	file:
MAX	utils.cpp	/^int MAX(int a, int b) {$/;"	f
MAX	utils.h	68;"	d
MAXGAIN	spec_procs.cpp	134;"	d	file:
MAX_AFFECT	structs.h	543;"	d
MAX_BAG_ROWS	objsave.cpp	29;"	d	file:
MAX_BOARD_MESSAGES	boards.h	12;"	d
MAX_GUESTS	house.h	2;"	d
MAX_HOUSES	house.h	1;"	d
MAX_INPUT_LENGTH	structs.h	533;"	d
MAX_INVALID_NAMES	ban.cpp	243;"	d	file:
MAX_MAIL_SIZE	mail.h	26;"	d
MAX_MESSAGES	structs.h	535;"	d
MAX_MESSAGE_LENGTH	boards.h	13;"	d
MAX_MOB_DESC	olc.h	18;"	d
MAX_MOB_NAME	olc.h	15;"	d
MAX_NAME_LENGTH	structs.h	536;"	d
MAX_NOTE_LENGTH	structs.h	545;"	d
MAX_OBJ_AFFECT	structs.h	544;"	d
MAX_OBJ_DESC	olc.h	19;"	d
MAX_OBJ_NAME	olc.h	16;"	d
MAX_OPER	shop.h	98;"	d
MAX_OUTSIDE_BANK	shop.h	138;"	d
MAX_PER_PRAC	spec_procs.cpp	125;"	d	file:
MAX_PROD	shop.h	50;"	d
MAX_PROMPT_LENGTH	structs.h	525;"	d
MAX_PWD_LENGTH	structs.h	537;"	d
MAX_RAW_INPUT_LENGTH	structs.h	534;"	d
MAX_ROOM_DESC	olc.h	17;"	d
MAX_ROOM_NAME	olc.h	14;"	d
MAX_SHOP_OBJ	shop.h	52;"	d
MAX_SKILLS	structs.h	542;"	d
MAX_SOCK_BUF	structs.h	524;"	d
MAX_SPELLS	spells.h	91;"	d
MAX_SPELL_AFFECTS	magic.cpp	319;"	d	file:
MAX_STRING_LENGTH	structs.h	532;"	d
MAX_TITLE_LENGTH	structs.h	538;"	d
MAX_TONGUE	structs.h	541;"	d
MAX_TRADE	shop.h	49;"	d
MEMORY	utils.h	344;"	d
MENTOC_ABIL_SET	db.cpp	946;"	d	file:
MENTOC_BITVECTOR	mods/builder.cpp	2348;"	d	file:
MENTOC_CHK_OBJ	mods/builder.cpp	711;"	d	file:
MENTOC_DEFER	globals.hpp	29;"	d
MENTOC_OBI	mods/builder.cpp	16;"	d	file:
MENTOC_OBI2	mods/builder.cpp	17;"	d	file:
MENTOC_OBS	mods/builder.cpp	18;"	d	file:
MENTOC_OBS2	mods/builder.cpp	19;"	d	file:
MENTOC_PLAYER_NULL_CHECK	mods/builder.cpp	625;"	d	file:
MENTOC_PREAMBLE	globals.hpp	28;"	d
MENTOC_SHOW_FLAG	mods/builder.cpp	2383;"	d	file:
MENTOC_SHOW_OBJ	mods/builder.cpp	1255;"	d	file:
MENTOC_SHOW_OBJ_BITVECTOR	mods/builder.cpp	1247;"	d	file:
MENTOC_SHOW_OBJ_FLAGS	mods/builder.cpp	1239;"	d	file:
MENTOC_STR	db.cpp	1049;"	d	file:
MENTOC_T	mods/lmdb.hpp	66;"	d
MENTOC_T	mods/lmdb.hpp	81;"	d
MENTOC_TYPE	mods/builder.cpp	2323;"	d	file:
MENTOC_WEAR	mods/builder.cpp	2306;"	d	file:
MENU	config.cpp	/^const char *MENU =$/;"	v
MESS_FILE	db.h	92;"	d
MIN	utils.cpp	/^int MIN(int a, int b) {$/;"	f
MIN	utils.h	72;"	d
MINDEX_FILE	db.h	68;"	d
MINGAIN	spec_procs.cpp	133;"	d	file:
MIN_MAIL_LEVEL	mail.h	20;"	d
MIN_OUTSIDE_BANK	shop.h	137;"	d
MIN_PER_PRAC	spec_procs.cpp	126;"	d	file:
MISC	act.wizard.cpp	2299;"	d	file:
MOB	mods/player.hpp	/^				PLAYER, MOB, DRONE,$/;"	e	enum:mods::player::player_type_enum_t
MOB_AERIALSERVANT	magic.cpp	802;"	d	file:
MOB_AGGRESSIVE	structs.h	212;"	d
MOB_AGGR_EVIL	structs.h	215;"	d
MOB_AGGR_GOOD	structs.h	216;"	d
MOB_AGGR_NEUTRAL	structs.h	217;"	d
MOB_AGGR_TO_ALIGN	mobact.cpp	39;"	d	file:
MOB_AWARE	structs.h	211;"	d
MOB_CLONE	magic.cpp	800;"	d	file:
MOB_ELEMENTAL_BASE	magic.cpp	799;"	d	file:
MOB_FLAGGED	utils.h	227;"	d
MOB_FLAGS	utils.h	212;"	d
MOB_GATE_I	magic.cpp	794;"	d	file:
MOB_GATE_II	magic.cpp	795;"	d	file:
MOB_GATE_III	magic.cpp	796;"	d	file:
MOB_HAS_TREE	structs.h	226;"	d
MOB_HELPER	structs.h	219;"	d
MOB_ISNPC	structs.h	210;"	d
MOB_MEMORY	structs.h	218;"	d
MOB_MONSUM_I	magic.cpp	791;"	d	file:
MOB_MONSUM_II	magic.cpp	792;"	d	file:
MOB_MONSUM_III	magic.cpp	793;"	d	file:
MOB_MUTED_DESCRIPTOR	mods/player.hpp	/^				MOB_MUTED_DESCRIPTOR,$/;"	e	enum:mods::player::player_type_enum_t
MOB_NOBASH	structs.h	223;"	d
MOB_NOBLIND	structs.h	224;"	d
MOB_NOCHARM	structs.h	220;"	d
MOB_NOSLEEP	structs.h	222;"	d
MOB_NOSUMMON	structs.h	221;"	d
MOB_NOTDEADYET	structs.h	225;"	d
MOB_PREFIX	db.h	70;"	d
MOB_SCAVENGER	structs.h	209;"	d
MOB_SENTINEL	structs.h	208;"	d
MOB_SPEC	structs.h	207;"	d
MOB_STAY_ZONE	structs.h	213;"	d
MOB_WIMPY	structs.h	214;"	d
MOB_ZOMBIE	magic.cpp	801;"	d	file:
MODE_ACK	telnet.h	168;"	d
MODE_ECHO	telnet.h	176;"	d
MODE_EDIT	telnet.h	166;"	d
MODE_FLOW	telnet.h	175;"	d
MODE_FORCE	telnet.h	179;"	d
MODE_INBIN	telnet.h	177;"	d
MODE_LIT_ECHO	telnet.h	170;"	d
MODE_MASK	telnet.h	172;"	d
MODE_OUTBIN	telnet.h	178;"	d
MODE_SOFT_TAB	telnet.h	169;"	d
MODE_TRAPSIG	telnet.h	167;"	d
MODS_BREACH_DISORIENT	globals.cpp	22;"	d	file:
MODS_GRENADE_BASE_DAMAGE	globals.cpp	23;"	d	file:
MOD_AGGRESSION_CHANCE	mods/ai_state.cpp	17;"	d	file:
MOD_AGGRESSION_MODIFIER	mods/ai_state.cpp	16;"	d	file:
MOD_LENIENT_MAX	mods/ai_state.hpp	17;"	d
MOD_SNIPE_AGGRESSION	mods/ai_state.cpp	14;"	d	file:
MOD_SNIPE_DISTANCE_THACO	fight.cpp	28;"	d	file:
MOD_SNIPE_SAME_ROOM_THACO	fight.cpp	27;"	d	file:
MOD_SNIPE_THRESHOLD	mods/ai_state.cpp	15;"	d	file:
MOD_SUSPICIOUS_MAX	mods/ai_state.hpp	18;"	d
MOD_WANDER_SAY_DIVISOR	mods/ai_state.cpp	18;"	d	file:
MOD_WANDER_SAY_TOP	mods/ai_state.cpp	19;"	d	file:
MORTAL_START	config.hpp	/^		constexpr static room_type_t MORTAL_START = 5;$/;"	m	namespace:config::rooms
MORT_CAN_SEE	utils.h	436;"	d
MORT_CAN_SEE_OBJ	utils.h	459;"	d
MOTD_FILE	db.h	78;"	d
MSG_CANT_KILL_KEEPER	shop.h	148;"	d
MSG_CLOSED_FOR_DAY	shop.h	142;"	d
MSG_HEADING	boards.h	44;"	d
MSG_LEVEL	boards.h	46;"	d
MSG_NOT_OPEN_YET	shop.h	140;"	d
MSG_NOT_REOPEN_YET	shop.h	141;"	d
MSG_NO_SEE_CHAR	shop.h	144;"	d
MSG_NO_SELL_ALIGN	shop.h	145;"	d
MSG_NO_SELL_CLASS	shop.h	146;"	d
MSG_NO_STEAL_HERE	shop.h	143;"	d
MSG_NO_USED_WANDSTAFF	shop.h	147;"	d
MSG_SLOTNUM	boards.h	45;"	d
MatchAllOf	mods/catch.hpp	/^			struct MatchAllOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatchAnyOf	mods/catch.hpp	/^			struct MatchAnyOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatchNotOf	mods/catch.hpp	/^				MatchNotOf(MatcherBase<ArgT> const& underlyingMatcher) : m_underlyingMatcher(underlyingMatcher) {}$/;"	f	struct:Catch::Matchers::Impl::MatchNotOf
MatchNotOf	mods/catch.hpp	/^			struct MatchNotOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatcherBase	mods/catch.hpp	/^			struct MatcherBase : MatcherUntypedBase {$/;"	s	namespace:Catch::Matchers::Impl
MatcherUntypedBase	mods/catch.hpp	/^			class MatcherUntypedBase {$/;"	c	namespace:Catch::Matchers::Impl
Matchers	mods/catch.hpp	/^	namespace Matchers {$/;"	n	namespace:Catch
MethodTestCase	mods/catch.hpp	/^			MethodTestCase(void (C::*method)()) : m_method(method) {}$/;"	f	class:Catch::MethodTestCase
MethodTestCase	mods/catch.hpp	/^	class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch
NEED_CLOSED	act.movement.cpp	320;"	d	file:
NEED_LOCKED	act.movement.cpp	322;"	d	file:
NEED_OPEN	act.movement.cpp	319;"	d	file:
NEED_STRICMP_PROTO	conf.h	308;"	d
NEED_STRLCPY_PROTO	conf.h	311;"	d
NEED_STRNICMP_PROTO	conf.h	317;"	d
NEED_UNLOCKED	act.movement.cpp	321;"	d	file:
NEWEST_AT_TOP	boards.cpp	60;"	d	file:
NEWS_FILE	db.h	77;"	d
NEW_ENV_VALUE	telnet.h	238;"	d
NEW_ENV_VAR	telnet.h	237;"	d
NEW_MSG_INDEX	boards.h	43;"	d
NO	config.cpp	21;"	d	file:
NOBODY	structs.h	75;"	d
NOEFFECT	config.cpp	/^const char *NOEFFECT = "Nothing seems to happen.\\r\\n";$/;"	v
NOMINMAX	mods/catch.hpp	6779;"	d
NOMINMAX	mods/catch.hpp	6792;"	d
NONE	mods/behaviour_tree.hpp	/^		static constexpr int NONE = -1;$/;"	m	struct:mods::behaviour_tree
NONE	mods/behaviour_tree_impl.hpp	/^			NONE = node_wrapper::NONE,$/;"	e	enum:mods::behaviour_tree_impl::type
NOP	telnet.h	56;"	d
NOPERSON	config.cpp	/^const char *NOPERSON = "No-one by that name here.\\r\\n";$/;"	v
NORMAL	structs.h	/^			NORMAL = 0,$/;"	e	enum:mods::descriptor_data::queue_behaviour_enum_t
NORTH	structs.h	91;"	d
NOTHING	structs.h	74;"	d
NOTRADE_CLERIC	shop.h	124;"	d
NOTRADE_EVIL	shop.h	121;"	d
NOTRADE_GOOD	shop.h	120;"	d
NOTRADE_MAGIC_USER	shop.h	123;"	d
NOTRADE_NEUTRAL	shop.h	122;"	d
NOTRADE_THIEF	shop.h	125;"	d
NOTRADE_WARRIOR	shop.h	126;"	d
NOWHERE	structs.h	73;"	d
NO_ATTACK_TYPE	mods/ai_state.cpp	20;"	d	file:
NO_LOGIC	mods/behaviour_tree_status.hpp	/^		NO_LOGIC,$/;"	e	enum:mods::behaviour_tree_status
NPC	act.wizard.cpp	2296;"	d	file:
NRM	utils.h	111;"	d
NSLC	telnet.h	200;"	d
NTELOPTS	telnet.h	125;"	d
NULL	utils.h	510;"	d
NUMBER	act.wizard.cpp	2301;"	d	file:
NUM_CLASSES	structs.h	157;"	d
NUM_OF_BOARDS	boards.h	11;"	d
NUM_OF_DIRS	structs.h	498;"	d
NUM_RESERVED_DESCS	comm.h	11;"	d
NUM_TOKENS	interpreter.cpp	843;"	d	file:
NUM_WEARS	structs.h	322;"	d
NameAndDesc	mods/catch.hpp	/^		NameAndDesc(const char* _name = "", const char* _description= "")$/;"	f	struct:Catch::NameAndDesc
NameAndDesc	mods/catch.hpp	/^	struct NameAndDesc {$/;"	s	namespace:Catch
No	mods/catch.hpp	/^			No$/;"	e	enum:Catch::CaseSensitive::Choice
NonCopyable	mods/catch.hpp	/^			NonCopyable() {}$/;"	f	class:Catch::NonCopyable
NonCopyable	mods/catch.hpp	/^	class NonCopyable {$/;"	c	namespace:Catch
Normal	mods/catch.hpp	/^			Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Not	mods/catch.hpp	/^		inline Impl::MatchNotOf<T> Not(Impl::MatcherBase<T> const& underlyingMatcher) {$/;"	f	namespace:Catch::Matchers
NotImplementedException	mods/catch.hpp	/^			NotImplementedException(NotImplementedException const&) {}$/;"	f	class:Catch::NotImplementedException
NotImplementedException	mods/catch.hpp	/^	class NotImplementedException : public std::exception {$/;"	c	namespace:Catch
OBJAFF_FLAGGED	utils.h	233;"	d
OBJECT_DEAD	shop.h	61;"	d
OBJECT_NOTOK	shop.h	62;"	d
OBJECT_NOVAL	shop.h	64;"	d
OBJECT_OK	shop.h	63;"	d
OBJN	utils.h	478;"	d
OBJS	utils.h	475;"	d
OBJVAL_FLAGGED	utils.h	234;"	d
OBJWEAR_FLAGGED	utils.h	235;"	d
OBJ_FLAGGED	utils.h	236;"	d
OBJ_PREFIX	db.h	71;"	d
OC_TEST_CASE	mods/catch.hpp	3532;"	d
OFF	utils.h	109;"	d
OK	config.cpp	/^const char *OK = "Okay.\\r\\n";$/;"	v
OLC_ALIASES	olc.h	11;"	d
OLC_COPY	olc.h	8;"	d
OLC_DESC	olc.h	10;"	d
OLC_MOB	olc.h	5;"	d
OLC_NAME	olc.h	9;"	d
OLC_OBJ	olc.h	6;"	d
OLC_REPEAT	olc.h	3;"	d
OLC_ROOM	olc.h	4;"	d
OLC_SET	olc.h	1;"	d
OLC_SHOW	olc.h	2;"	d
OLC_USAGE	olc.cpp	34;"	d	file:
OLD_ENV_VALUE	telnet.h	236;"	d
OLD_ENV_VAR	telnet.h	235;"	d
ONOFF	utils.h	145;"	d
OPEN_DOOR	act.movement.cpp	342;"	d	file:
OPER_AND	shop.h	96;"	d
OPER_CLOSE_PAREN	shop.h	94;"	d
OPER_NOT	shop.h	97;"	d
OPER_OPEN_PAREN	shop.h	93;"	d
OPER_OR	shop.h	95;"	d
OPPOSITE_DIR	globals.hpp	32;"	d
OPT_USEC	structs.h	509;"	d
OTHER_PLAYER_INDEX_START	mods/player-scaffolding.hpp	/^		constexpr static std::size_t OTHER_PLAYER_INDEX_START = 2;$/;"	m	struct:mods::player_scaffolding
OUTPUT_SIZE	structs.h	/^		constexpr static size_t OUTPUT_SIZE = LARGE_BUFSIZE+1;$/;"	m	struct:mods::descriptor_data
OUTSIDE	utils.h	502;"	d
O_NONBLOCK	comm.cpp	2026;"	d	file:
Obj_from_store	objsave.cpp	/^struct obj_data *Obj_from_store(struct obj_file_elem object, int *location) {$/;"	f
Obj_to_store	objsave.cpp	/^int Obj_to_store(struct obj_data *obj, FILE *fl, int location) {$/;"	f
OfType	mods/catch.hpp	/^		enum OfType {$/;"	g	struct:Catch::ResultWas
Ok	mods/catch.hpp	/^			Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
Operator	mods/catch.hpp	/^		enum Operator {$/;"	g	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsEqualTo>             {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsGreaterThan>         {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsLessThan>            {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsLessThanOrEqualTo>   {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsNotEqualTo>          {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<Operator Op> struct OperatorTraits             {$/;"	s	namespace:Catch::Internal
PADDING0	structs.h	/^	byte PADDING0;		\/* used to be spells_to_learn		*\/$/;"	m	struct:player_special_data_saved
PAGE_LENGTH	comm.h	76;"	d
PAGE_SIZE	mods/player.hpp	/^			static constexpr int PAGE_SIZE = 40;$/;"	m	class:mods::player
PAGE_WIDTH	comm.h	77;"	d
PASSES_PER_SEC	structs.h	510;"	d
PATH_MAX	sysdep.h	352;"	d
PAUSE_FILE	db.h	55;"	d
PAUSE_FILE	db.h	59;"	d
PAUSE_FILE	db.h	63;"	d
PC	act.wizard.cpp	2295;"	d	file:
PERS	utils.h	473;"	d
PET_PRICE	spec_procs.cpp	697;"	d	file:
PLACE_HOLDER_VALUE	mods/schema.hpp	/^	constexpr static const char* PLACE_HOLDER_VALUE = "\\x01";$/;"	m	namespace:mods::schema
PLAYER	mods/player.hpp	/^				PLAYER, MOB, DRONE,$/;"	e	enum:mods::player::player_type_enum_t
PLAYER_FILE	db.h	96;"	d
PLAYER_GET	mods/prefs.hpp	20;"	d
PLAYER_GETI	mods/prefs.hpp	22;"	d
PLAYER_MUTED_DESCRIPTOR	mods/player.hpp	/^				PLAYER_MUTED_DESCRIPTOR,$/;"	e	enum:mods::player::player_type_enum_t
PLAYER_SET	mods/prefs.hpp	19;"	d
PLAYER_SETI	mods/prefs.hpp	21;"	d
PLR_CRASH	structs.h	193;"	d
PLR_CRYO	structs.h	202;"	d
PLR_DELETED	structs.h	197;"	d
PLR_DONTSET	structs.h	190;"	d
PLR_FLAGGED	utils.h	228;"	d
PLR_FLAGS	utils.h	213;"	d
PLR_FLAG_BIT_COUNT	mods/player.cpp	/^	constexpr static int16_t PLR_FLAG_BIT_COUNT = 16;$/;"	m	namespace:mods	file:
PLR_FROZEN	structs.h	189;"	d
PLR_INVSTART	structs.h	201;"	d
PLR_KILLER	structs.h	187;"	d
PLR_LOADROOM	structs.h	198;"	d
PLR_MAILING	structs.h	192;"	d
PLR_NODELETE	structs.h	200;"	d
PLR_NOSHOUT	structs.h	195;"	d
PLR_NOTDEADYET	structs.h	203;"	d
PLR_NOTITLE	structs.h	196;"	d
PLR_NOWIZLIST	structs.h	199;"	d
PLR_SITEOK	structs.h	194;"	d
PLR_THIEF	structs.h	188;"	d
PLR_TOG_CHK	utils.h	242;"	d
PLR_WRITING	structs.h	191;"	d
POLICIES_FILE	db.h	86;"	d
POSIX	sysdep.h	181;"	d
POSIX	sysdep.h	188;"	d
POSIX	sysdep.h	193;"	d
POSIX_NONBLOCK_BROKEN	sysdep.h	197;"	d
POS_DEAD	structs.h	175;"	d
POS_FIGHTING	structs.h	182;"	d
POS_INCAP	structs.h	177;"	d
POS_MORTALLYW	structs.h	176;"	d
POS_RESTING	structs.h	180;"	d
POS_SITTING	structs.h	181;"	d
POS_SLEEPING	structs.h	179;"	d
POS_STANDING	structs.h	183;"	d
POS_STUNNED	structs.h	178;"	d
PRAC_TYPE	spec_procs.cpp	127;"	d	file:
PREFS_FORMAT_STRING	mods/prefs.hpp	15;"	d
PREFS_SEPARATOR	mods/prefs.hpp	14;"	d
PRF_AUTOEXIT	structs.h	237;"	d
PRF_BRIEF	structs.h	230;"	d
PRF_COLOR_1	structs.h	243;"	d
PRF_COLOR_2	structs.h	244;"	d
PRF_COMPACT	structs.h	231;"	d
PRF_DEAF	structs.h	232;"	d
PRF_DISPAUTO	structs.h	252;"	d
PRF_DISPHP	structs.h	234;"	d
PRF_DISPMANA	structs.h	235;"	d
PRF_DISPMOVE	structs.h	236;"	d
PRF_FLAGGED	utils.h	230;"	d
PRF_FLAGS	utils.h	214;"	d
PRF_HOLYLIGHT	structs.h	242;"	d
PRF_LOG1	structs.h	246;"	d
PRF_LOG2	structs.h	247;"	d
PRF_NOAUCT	structs.h	248;"	d
PRF_NOGOSS	structs.h	249;"	d
PRF_NOGRATZ	structs.h	250;"	d
PRF_NOHASSLE	structs.h	238;"	d
PRF_NOREPEAT	structs.h	241;"	d
PRF_NOTELL	structs.h	233;"	d
PRF_NOWIZ	structs.h	245;"	d
PRF_QUEST	structs.h	239;"	d
PRF_ROOMFLAGS	structs.h	251;"	d
PRF_SUMMONABLE	structs.h	240;"	d
PRF_TOG_CHK	act.other.cpp	908;"	d	file:
PRF_TOG_CHK	utils.h	243;"	d
PROTECT	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
PULSE_AUTOSAVE	structs.h	517;"	d
PULSE_BTREE	structs.h	513;"	d
PULSE_IDLEPWD	structs.h	518;"	d
PULSE_MOBILE	structs.h	515;"	d
PULSE_SANITY	structs.h	519;"	d
PULSE_TIMESAVE	structs.h	521;"	d
PULSE_USAGE	structs.h	520;"	d
PULSE_VIOLENCE	structs.h	516;"	d
PULSE_ZONE	structs.h	514;"	d
Ptr	mods/catch.hpp	/^			Ptr() : m_p(CATCH_NULL) {}$/;"	f	class:Catch::Ptr
Ptr	mods/catch.hpp	/^			Ptr(Ptr const& other) : m_p(other.m_p) {$/;"	f	class:Catch::Ptr
Ptr	mods/catch.hpp	/^			Ptr(T* p) : m_p(p) {$/;"	f	class:Catch::Ptr
Ptr	mods/catch.hpp	/^	class Ptr {$/;"	c	namespace:Catch
QBLU	screen.h	44;"	d
QCYN	screen.h	46;"	d
QGRN	screen.h	42;"	d
QMAG	screen.h	45;"	d
QNRM	screen.h	40;"	d
QRED	screen.h	41;"	d
QWHT	screen.h	47;"	d
QYEL	screen.h	43;"	d
Q_COMPLETE_KEY	mods/quests.cpp	11;"	d	file:
Q_CURRENT_KEY	mods/quests.cpp	5;"	d	file:
Q_CURRENT_VALUE	mods/quests.cpp	6;"	d	file:
Q_FORMAT	mods/quests.cpp	4;"	d	file:
Q_TRIGGER_CODE_KEY	mods/quests.cpp	12;"	d	file:
Q_TRIGGER_KEY	mods/quests.cpp	7;"	d	file:
RANGE	act.wizard.cpp	2307;"	d	file:
RANGE	db.cpp	1586;"	d	file:
RANGE	db.cpp	1648;"	d	file:
READ_LVL	boards.h	37;"	d
READ_SIZE	utils.h	21;"	d
REAL	db.h	/^	REAL=0,\\$/;"	e	enum:__anon1
RECON	interpreter.cpp	1292;"	d	file:
RECREATE	utils.h	165;"	d
REDIRECT_TO_DB	structs.h	/^			REDIRECT_TO_DB$/;"	e	enum:mods::descriptor_data::queue_behaviour_enum_t
REDIRECT_TO_FILESYSTEM	structs.h	/^			REDIRECT_TO_FILESYSTEM,$/;"	e	enum:mods::descriptor_data::queue_behaviour_enum_t
REDIRECT_TO_PLAYER	structs.h	/^			REDIRECT_TO_PLAYER,$/;"	e	enum:mods::descriptor_data::queue_behaviour_enum_t
REMOVE_BIT	utils.h	194;"	d
REMOVE_FROM_LIST	utils.h	178;"	d
REMOVE_LVL	boards.h	39;"	d
RENT_CRASH	structs.h	471;"	d
RENT_CRYO	structs.h	473;"	d
RENT_FACTOR	objsave.cpp	25;"	d	file:
RENT_FORCED	structs.h	474;"	d
RENT_RENTED	structs.h	472;"	d
RENT_TIMEDOUT	structs.h	475;"	d
RENT_UNDEF	structs.h	470;"	d
RESERVED	mods/ai_state.hpp	/^				MANIC,CHAOTIC,RESERVED$/;"	e	enum:mods::ai_state::state
RETSIGTYPE	conf.h	20;"	d
RLIMIT_NOFILE	sysdep.h	409;"	d
RL_SEC	structs.h	511;"	d
ROOM_ATRIUM	structs.h	114;"	d
ROOM_BFS_MARK	structs.h	116;"	d
ROOM_DARK	structs.h	101;"	d
ROOM_DEATH	structs.h	102;"	d
ROOM_DESC_EMPTY	mods/builder.hpp	/^	constexpr static int ROOM_DESC_EMPTY = -3;$/;"	m	namespace:mods::builder
ROOM_EMP	mods/ai_state.hpp	/^				ROOM_EMP,ROOM_NORMAL$/;"	e	enum:mods::ai_state::event_type_t
ROOM_FLAGGED	utils.h	231;"	d
ROOM_FLAGS	utils.h	216;"	d
ROOM_GODROOM	structs.h	111;"	d
ROOM_HOUSE	structs.h	112;"	d
ROOM_HOUSE_CRASH	structs.h	113;"	d
ROOM_INDOORS	structs.h	104;"	d
ROOM_NAME_EMPTY	mods/builder.hpp	/^	constexpr static int ROOM_NAME_EMPTY = -2;$/;"	m	namespace:mods::builder
ROOM_NOMAGIC	structs.h	108;"	d
ROOM_NOMOB	structs.h	103;"	d
ROOM_NORMAL	mods/ai_state.hpp	/^				ROOM_EMP,ROOM_NORMAL$/;"	e	enum:mods::ai_state::event_type_t
ROOM_NOTRACK	structs.h	107;"	d
ROOM_NUMBER_OUT_OF_RANGE	mods/builder.hpp	/^	constexpr static int ROOM_NUMBER_OUT_OF_RANGE = -1;$/;"	m	namespace:mods::builder
ROOM_OLC	structs.h	115;"	d
ROOM_PEACEFUL	structs.h	105;"	d
ROOM_PRIVATE	structs.h	110;"	d
ROOM_SOUNDPROOF	structs.h	106;"	d
ROOM_TUNNEL	structs.h	109;"	d
RUNNING	mods/behaviour_tree_status.hpp	/^		RUNNING,$/;"	e	enum:mods::behaviour_tree_status
Read_Invalid_List	ban.cpp	/^void Read_Invalid_List(void) {$/;"	f
Read_Invalid_List	mods/hell.hpp	/^	constexpr inline bool Read_Invalid_List = false;$/;"	m	namespace:mods::hell
ResultBuilder	mods/catch.hpp	/^	class ResultBuilder : public DecomposedExpression {$/;"	c	namespace:Catch
ResultDisposition	mods/catch.hpp	/^	struct ResultDisposition {$/;"	s	namespace:Catch
ResultWas	mods/catch.hpp	/^	struct ResultWas {$/;"	s	namespace:Catch
SANA	utils.h	424;"	d
SAVING_BREATH	spells.h	152;"	d
SAVING_PARA	spells.h	149;"	d
SAVING_PETRI	spells.h	151;"	d
SAVING_ROD	spells.h	150;"	d
SAVING_SPELL	spells.h	153;"	d
SB	telnet.h	47;"	d
SCENARIO	mods/catch.hpp	12208;"	d
SCENARIO_METHOD	mods/catch.hpp	12209;"	d
SCMD_ASK	interpreter.h	134;"	d
SCMD_AUCTION	interpreter.h	140;"	d
SCMD_AUTOEXIT	interpreter.h	120;"	d
SCMD_BRIEF	interpreter.h	107;"	d
SCMD_BUG	interpreter.h	166;"	d
SCMD_CLEAR	interpreter.h	101;"	d
SCMD_CLOSE	interpreter.h	207;"	d
SCMD_COMMANDS	interpreter.h	156;"	d
SCMD_COMPACT	interpreter.h	108;"	d
SCMD_CREDITS	interpreter.h	93;"	d
SCMD_DATE	interpreter.h	152;"	d
SCMD_DEAF	interpreter.h	111;"	d
SCMD_DONATE	interpreter.h	163;"	d
SCMD_DOWN	interpreter.h	88;"	d
SCMD_DRINK	interpreter.h	193;"	d
SCMD_DROP	interpreter.h	161;"	d
SCMD_EAST	interpreter.h	84;"	d
SCMD_EAT	interpreter.h	191;"	d
SCMD_ECHO	interpreter.h	202;"	d
SCMD_EMOTE	interpreter.h	203;"	d
SCMD_FILL	interpreter.h	180;"	d
SCMD_FREEZE	interpreter.h	128;"	d
SCMD_GOSSIP	interpreter.h	139;"	d
SCMD_GRATZ	interpreter.h	141;"	d
SCMD_HANDBOOK	interpreter.h	92;"	d
SCMD_HIT	interpreter.h	187;"	d
SCMD_HOLLER	interpreter.h	137;"	d
SCMD_HOLYLIGHT	interpreter.h	118;"	d
SCMD_IDEA	interpreter.h	168;"	d
SCMD_IMMLIST	interpreter.h	98;"	d
SCMD_IMOTD	interpreter.h	100;"	d
SCMD_INFO	interpreter.h	91;"	d
SCMD_JUNK	interpreter.h	162;"	d
SCMD_LOCK	interpreter.h	209;"	d
SCMD_LOOK	interpreter.h	171;"	d
SCMD_MOTD	interpreter.h	99;"	d
SCMD_MURDER	interpreter.h	188;"	d
SCMD_NEWS	interpreter.h	94;"	d
SCMD_NOAUCTION	interpreter.h	110;"	d
SCMD_NOGOSSIP	interpreter.h	112;"	d
SCMD_NOGRATZ	interpreter.h	113;"	d
SCMD_NOHASSLE	interpreter.h	106;"	d
SCMD_NOREPEAT	interpreter.h	117;"	d
SCMD_NORTH	interpreter.h	83;"	d
SCMD_NOSUMMON	interpreter.h	105;"	d
SCMD_NOTELL	interpreter.h	109;"	d
SCMD_NOTITLE	interpreter.h	126;"	d
SCMD_NOWIZ	interpreter.h	114;"	d
SCMD_OPEN	interpreter.h	206;"	d
SCMD_PARDON	interpreter.h	125;"	d
SCMD_PICK	interpreter.h	210;"	d
SCMD_POLICIES	interpreter.h	96;"	d
SCMD_POOFIN	interpreter.h	183;"	d
SCMD_POOFOUT	interpreter.h	184;"	d
SCMD_POUR	interpreter.h	179;"	d
SCMD_QECHO	interpreter.h	176;"	d
SCMD_QSAY	interpreter.h	175;"	d
SCMD_QUAFF	interpreter.h	198;"	d
SCMD_QUEST	interpreter.h	115;"	d
SCMD_QUI	interpreter.h	148;"	d
SCMD_QUIT	interpreter.h	149;"	d
SCMD_READ	interpreter.h	172;"	d
SCMD_RECITE	interpreter.h	199;"	d
SCMD_REROLL	interpreter.h	124;"	d
SCMD_ROOMFLAGS	interpreter.h	116;"	d
SCMD_SHOUT	interpreter.h	138;"	d
SCMD_SHUTDOW	interpreter.h	144;"	d
SCMD_SHUTDOWN	interpreter.h	145;"	d
SCMD_SIP	interpreter.h	194;"	d
SCMD_SLOWNS	interpreter.h	119;"	d
SCMD_SOCIALS	interpreter.h	157;"	d
SCMD_SOUTH	interpreter.h	85;"	d
SCMD_SQUELCH	interpreter.h	127;"	d
SCMD_TASTE	interpreter.h	192;"	d
SCMD_THAW	interpreter.h	129;"	d
SCMD_TRACK	interpreter.h	121;"	d
SCMD_TYPO	interpreter.h	167;"	d
SCMD_UNAFFECT	interpreter.h	130;"	d
SCMD_UNLOCK	interpreter.h	208;"	d
SCMD_UP	interpreter.h	87;"	d
SCMD_UPTIME	interpreter.h	153;"	d
SCMD_USE	interpreter.h	197;"	d
SCMD_VERSION	interpreter.h	97;"	d
SCMD_WEST	interpreter.h	86;"	d
SCMD_WHISPER	interpreter.h	133;"	d
SCMD_WHOAMI	interpreter.h	102;"	d
SCMD_WIZHELP	interpreter.h	158;"	d
SCMD_WIZLIST	interpreter.h	95;"	d
SE	telnet.h	57;"	d
SECS_PER_MUD_DAY	utils.h	130;"	d
SECS_PER_MUD_HOUR	utils.h	129;"	d
SECS_PER_MUD_MONTH	utils.h	131;"	d
SECS_PER_MUD_YEAR	utils.h	132;"	d
SECS_PER_REAL_DAY	utils.h	137;"	d
SECS_PER_REAL_HOUR	utils.h	136;"	d
SECS_PER_REAL_MIN	utils.h	135;"	d
SECS_PER_REAL_YEAR	utils.h	138;"	d
SECT	utils.h	249;"	d
SECT_CITY	structs.h	130;"	d
SECT_FIELD	structs.h	131;"	d
SECT_FLYING	structs.h	137;"	d
SECT_FOREST	structs.h	132;"	d
SECT_HILLS	structs.h	133;"	d
SECT_INSIDE	structs.h	129;"	d
SECT_MOUNTAIN	structs.h	134;"	d
SECT_UNDERWATER	structs.h	138;"	d
SECT_WATER_NOSWIM	structs.h	136;"	d
SECT_WATER_SWIM	structs.h	135;"	d
SEEK_CUR	utils.h	524;"	d
SEEK_END	utils.h	525;"	d
SEEK_SET	utils.h	523;"	d
SELECTOR	mods/behaviour_tree_node.hpp	/^		enum node_type_t { SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
SELF	utils.h	441;"	d
SENDOK	comm.cpp	2399;"	d	file:
SENTINEL	mods/object.hpp	/^		SENTINEL$/;"	e	enum:mods::object::type
SEQUENCE	mods/behaviour_tree_node.hpp	/^		enum node_type_t { SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
SET_BIT	utils.h	193;"	d
SET_OR_REMOVE	act.wizard.cpp	2303;"	d	file:
SET_SKILL	utils.h	334;"	d
SEX_FEMALE	structs.h	171;"	d
SEX_MALE	structs.h	170;"	d
SEX_NEUTRAL	structs.h	169;"	d
SHOP_BANK	shop.h	111;"	d
SHOP_BITVECTOR	shop.h	113;"	d
SHOP_BROKE_TEMPER	shop.h	112;"	d
SHOP_BUYPROFIT	shop.h	116;"	d
SHOP_BUYTYPE	shop.h	108;"	d
SHOP_BUYWORD	shop.h	109;"	d
SHOP_CLOSE1	shop.h	104;"	d
SHOP_CLOSE2	shop.h	106;"	d
SHOP_FUNC	shop.h	118;"	d
SHOP_KEEPER	shop.h	102;"	d
SHOP_KILL_CHARS	shop.h	133;"	d
SHOP_NUM	shop.h	101;"	d
SHOP_OPEN1	shop.h	103;"	d
SHOP_OPEN2	shop.h	105;"	d
SHOP_PRODUCT	shop.h	110;"	d
SHOP_ROOM	shop.h	107;"	d
SHOP_SELLPROFIT	shop.h	117;"	d
SHOP_SORT	shop.h	115;"	d
SHOP_TRADE_WITH	shop.h	114;"	d
SHOP_USES_BANK	shop.h	134;"	d
SHOTGUN	mods/player.hpp	/^		enum mask_type { SMG, SNIPE, SHOTGUN, GRENADE };$/;"	e	enum:mods::weapon::mask_type
SHOW_OBJ_ACTION	act.informative.cpp	108;"	d	file:
SHOW_OBJ_LONG	act.informative.cpp	106;"	d	file:
SHOW_OBJ_SHORT	act.informative.cpp	107;"	d	file:
SHP_PREFIX	db.h	73;"	d
SIGALRM	comm.cpp	26;"	d	file:
SIGPIPE	comm.cpp	25;"	d	file:
SINFO	spell_parser.cpp	25;"	d	file:
SKILL	class.cpp	154;"	d	file:
SKILL_BACKSTAB	spells.h	94;"	d
SKILL_BASH	spells.h	95;"	d
SKILL_HIDE	spells.h	96;"	d
SKILL_KICK	spells.h	97;"	d
SKILL_PICK_LOCK	spells.h	98;"	d
SKILL_RESCUE	spells.h	100;"	d
SKILL_SNEAK	spells.h	101;"	d
SKILL_STEAL	spells.h	102;"	d
SKILL_TRACK	spells.h	103;"	d
SKY_CLOUDLESS	structs.h	463;"	d
SKY_CLOUDY	structs.h	464;"	d
SKY_LIGHTNING	structs.h	466;"	d
SKY_RAINING	structs.h	465;"	d
SLASH	db.h	32;"	d
SLASH	db.h	43;"	d
SLC_ABORT	telnet.h	187;"	d
SLC_ACK	telnet.h	231;"	d
SLC_AO	telnet.h	184;"	d
SLC_AYT	telnet.h	185;"	d
SLC_BRK	telnet.h	182;"	d
SLC_CANTCHANGE	telnet.h	222;"	d
SLC_DEFAULT	telnet.h	224;"	d
SLC_EC	telnet.h	190;"	d
SLC_EL	telnet.h	191;"	d
SLC_EOF	telnet.h	188;"	d
SLC_EOR	telnet.h	186;"	d
SLC_EW	telnet.h	192;"	d
SLC_FLAGS	telnet.h	228;"	d
SLC_FLUSHIN	telnet.h	232;"	d
SLC_FLUSHOUT	telnet.h	233;"	d
SLC_FORW1	telnet.h	197;"	d
SLC_FORW2	telnet.h	198;"	d
SLC_FUNC	telnet.h	227;"	d
SLC_IP	telnet.h	183;"	d
SLC_LEVELBITS	telnet.h	225;"	d
SLC_LNEXT	telnet.h	194;"	d
SLC_NAME	telnet.h	219;"	d
SLC_NAMELIST	telnet.h	206;"	d
SLC_NAMES	telnet.h	215;"	d
SLC_NAME_OK	telnet.h	218;"	d
SLC_NOSUPPORT	telnet.h	221;"	d
SLC_RP	telnet.h	193;"	d
SLC_SUSP	telnet.h	189;"	d
SLC_SYNCH	telnet.h	181;"	d
SLC_VALUE	telnet.h	229;"	d
SLC_VARIABLE	telnet.h	223;"	d
SLC_XOFF	telnet.h	196;"	d
SLC_XON	telnet.h	195;"	d
SMALL_BUFSIZE	structs.h	527;"	d
SMG	mods/player.hpp	/^		enum mask_type { SMG, SNIPE, SHOTGUN, GRENADE };$/;"	e	enum:mods::weapon::mask_type
SNIPE	mods/player.hpp	/^		enum mask_type { SMG, SNIPE, SHOTGUN, GRENADE };$/;"	e	enum:mods::weapon::mask_type
SOCMESS_FILE	db.h	93;"	d
SOUTH	structs.h	93;"	d
SPECIAL	boards.cpp	/^SPECIAL(gen_board) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(CastleGuard) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(DicknDavid) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(James) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(cleaning) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(jerry) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(king_welmar) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(peter) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(tim) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(tom) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(training_master) {$/;"	f
SPECIAL	mail.cpp	/^SPECIAL(postmaster) {$/;"	f
SPECIAL	objsave.cpp	/^SPECIAL(cryogenicist) {$/;"	f
SPECIAL	objsave.cpp	/^SPECIAL(receptionist) {$/;"	f
SPECIAL	shop.cpp	/^SPECIAL(shop_keeper) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(bank) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(cityguard) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(dump) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(fido) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(guild) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(guild_guard) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(janitor) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(magic_user) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(mayor) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(pet_shops) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(puff) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(snake) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(thief) {$/;"	f
SPECIAL	structs.h	83;"	d
SPELL	class.cpp	153;"	d	file:
SPELL_ACID_BREATH	spells.h	119;"	d
SPELL_ANIMATE_DEAD	spells.h	83;"	d
SPELL_ARMOR	spells.h	39;"	d
SPELL_BLESS	spells.h	41;"	d
SPELL_BLINDNESS	spells.h	42;"	d
SPELL_BURNING_HANDS	spells.h	43;"	d
SPELL_CALL_LIGHTNING	spells.h	44;"	d
SPELL_CHARM	spells.h	45;"	d
SPELL_CHILL_TOUCH	spells.h	46;"	d
SPELL_CLONE	spells.h	47;"	d
SPELL_COLOR_SPRAY	spells.h	48;"	d
SPELL_CONTROL_WEATHER	spells.h	49;"	d
SPELL_CREATE_FOOD	spells.h	50;"	d
SPELL_CREATE_WATER	spells.h	51;"	d
SPELL_CURE_BLIND	spells.h	52;"	d
SPELL_CURE_CRITIC	spells.h	53;"	d
SPELL_CURE_LIGHT	spells.h	54;"	d
SPELL_CURSE	spells.h	55;"	d
SPELL_DETECT_ALIGN	spells.h	56;"	d
SPELL_DETECT_INVIS	spells.h	57;"	d
SPELL_DETECT_MAGIC	spells.h	58;"	d
SPELL_DETECT_POISON	spells.h	59;"	d
SPELL_DISPEL_EVIL	spells.h	60;"	d
SPELL_DISPEL_GOOD	spells.h	84;"	d
SPELL_EARTHQUAKE	spells.h	61;"	d
SPELL_ENCHANT_WEAPON	spells.h	62;"	d
SPELL_ENERGY_DRAIN	spells.h	63;"	d
SPELL_FIREBALL	spells.h	64;"	d
SPELL_FIRE_BREATH	spells.h	116;"	d
SPELL_FROST_BREATH	spells.h	118;"	d
SPELL_GAS_BREATH	spells.h	117;"	d
SPELL_GROUP_ARMOR	spells.h	85;"	d
SPELL_GROUP_HEAL	spells.h	86;"	d
SPELL_GROUP_RECALL	spells.h	87;"	d
SPELL_HARM	spells.h	65;"	d
SPELL_HEAL	spells.h	66;"	d
SPELL_IDENTIFY	spells.h	115;"	d
SPELL_INFRAVISION	spells.h	88;"	d
SPELL_INVISIBLE	spells.h	67;"	d
SPELL_LIGHTNING_BOLT	spells.h	68;"	d
SPELL_LIGHTNING_BREATH	spells.h	120;"	d
SPELL_LOCATE_OBJECT	spells.h	69;"	d
SPELL_MAGIC_MISSILE	spells.h	70;"	d
SPELL_POISON	spells.h	71;"	d
SPELL_PROT_FROM_EVIL	spells.h	72;"	d
SPELL_REMOVE_CURSE	spells.h	73;"	d
SPELL_REMOVE_POISON	spells.h	81;"	d
SPELL_RESERVED_DBC	spells.h	35;"	d
SPELL_ROUTINES	utils.h	217;"	d
SPELL_SANCTUARY	spells.h	74;"	d
SPELL_SENSE_LIFE	spells.h	82;"	d
SPELL_SHOCKING_GRASP	spells.h	75;"	d
SPELL_SLEEP	spells.h	76;"	d
SPELL_STRENGTH	spells.h	77;"	d
SPELL_SUMMON	spells.h	78;"	d
SPELL_TELEPORT	spells.h	40;"	d
SPELL_TYPE_POTION	spells.h	198;"	d
SPELL_TYPE_SCROLL	spells.h	201;"	d
SPELL_TYPE_SPELL	spells.h	197;"	d
SPELL_TYPE_STAFF	spells.h	200;"	d
SPELL_TYPE_WAND	spells.h	199;"	d
SPELL_VENTRILOQUATE	spells.h	79;"	d
SPELL_WATERWALK	spells.h	89;"	d
SPELL_WORD_OF_RECALL	spells.h	80;"	d
SPLSKL	spec_procs.cpp	135;"	d	file:
STAMP_PRICE	mail.h	23;"	d
START_MESSG	config.cpp	/^const char *START_MESSG =$/;"	v
STATE	utils.cpp	/^int& STATE(mods::descriptor_data &d){	$/;"	f
STATE	utils.cpp	/^int& STATE(std::deque<mods::descriptor_data>::iterator d){ $/;"	f
STATE	utils.cpp	/^int& STATE(std::shared_ptr<mods::descriptor_data> d){	$/;"	f
STDC_HEADERS	conf.h	26;"	d
STDERR_FILENO	sysdep.h	416;"	d
STDOUT_FILENO	sysdep.h	421;"	d
STITCH_CLARA_CLOSE_NAMESPACE	mods/catch.hpp	4241;"	d
STITCH_CLARA_CLOSE_NAMESPACE	mods/catch.hpp	5424;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	4230;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	4240;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	5423;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	5427;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	mods/catch.hpp	4246;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	mods/catch.hpp	4434;"	d
STRENGTH_APPLY_INDEX	utils.h	346;"	d
SUCCESS	mods/behaviour_tree_status.hpp	/^		SUCCESS,$/;"	e	enum:mods::behaviour_tree_status
SUF_ALIAS	db.h	50;"	d
SUF_OBJS	db.h	48;"	d
SUF_TEXT	db.h	49;"	d
SUMMON_FAIL	spells.cpp	107;"	d	file:
SUN_DARK	structs.h	456;"	d
SUN_LIGHT	structs.h	458;"	d
SUN_RISE	structs.h	457;"	d
SUN_SET	structs.h	459;"	d
SUSP	telnet.h	60;"	d
SUSPICIOUS	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
SUSPICIOUS2	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
SYNCH	telnet.h	63;"	d
S_DATA	shop.h	88;"	d
S_LEN	shop.h	89;"	d
SafeBool	mods/catch.hpp	/^	class SafeBool {$/;"	c	namespace:Catch
SharedImpl	mods/catch.hpp	/^		SharedImpl() : m_rc(0) {}$/;"	f	struct:Catch::SharedImpl
SharedImpl	mods/catch.hpp	/^	struct SharedImpl : T {$/;"	s	namespace:Catch
SourceLineInfo	mods/catch.hpp	/^	struct SourceLineInfo {$/;"	s	namespace:Catch
StreamEndStop	mods/catch.hpp	/^	struct StreamEndStop {$/;"	s	namespace:Catch
StringMaker	mods/catch.hpp	/^	struct StringMaker :$/;"	s	namespace:Catch
StringMaker	mods/catch.hpp	/^	struct StringMaker<R C::*> {$/;"	s	namespace:Catch
StringMaker	mods/catch.hpp	/^	struct StringMaker<T*> {$/;"	s	namespace:Catch
StringMakerBase	mods/catch.hpp	/^		struct StringMakerBase {$/;"	s	namespace:Catch::Detail
StringMakerBase	mods/catch.hpp	/^		struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
SuppressFail	mods/catch.hpp	/^			SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
TARGET_PLAYER_INDEX	mods/player-scaffolding.hpp	/^		constexpr static std::size_t TARGET_PLAYER_INDEX = 1;$/;"	m	struct:mods::player_scaffolding
TAR_CHAR_ROOM	spells.h	157;"	d
TAR_CHAR_WORLD	spells.h	158;"	d
TAR_FIGHT_SELF	spells.h	159;"	d
TAR_FIGHT_VICT	spells.h	160;"	d
TAR_IGNORE	spells.h	156;"	d
TAR_NOT_SELF	spells.h	162;"	d
TAR_OBJ_EQUIP	spells.h	166;"	d
TAR_OBJ_INV	spells.h	163;"	d
TAR_OBJ_ROOM	spells.h	164;"	d
TAR_OBJ_WORLD	spells.h	165;"	d
TAR_SELF_ONLY	spells.h	161;"	d
TBC_TEXT_FORMAT_CONSOLE_WIDTH	mods/catch.hpp	5661;"	d
TBC_TEXT_FORMAT_H_INCLUDED	mods/catch.hpp	4253;"	d
TELCMD	telnet.h	79;"	d
TELCMD_FIRST	telnet.h	75;"	d
TELCMD_LAST	telnet.h	76;"	d
TELCMD_OK	telnet.h	77;"	d
TELOPT	telnet.h	143;"	d
TELOPT_3270REGIME	telnet.h	111;"	d
TELOPT_AUTHENTICATION	telnet.h	119;"	d
TELOPT_BINARY	telnet.h	82;"	d
TELOPT_BM	telnet.h	101;"	d
TELOPT_DET	telnet.h	102;"	d
TELOPT_ECHO	telnet.h	83;"	d
TELOPT_ENCRYPT	telnet.h	120;"	d
TELOPT_EOR	telnet.h	107;"	d
TELOPT_EXOPL	telnet.h	122;"	d
TELOPT_FIRST	telnet.h	140;"	d
TELOPT_LAST	telnet.h	141;"	d
TELOPT_LFLOW	telnet.h	115;"	d
TELOPT_LINEMODE	telnet.h	116;"	d
TELOPT_LOGOUT	telnet.h	100;"	d
TELOPT_NAMS	telnet.h	86;"	d
TELOPT_NAOCRD	telnet.h	92;"	d
TELOPT_NAOFFD	telnet.h	95;"	d
TELOPT_NAOHTD	telnet.h	94;"	d
TELOPT_NAOHTS	telnet.h	93;"	d
TELOPT_NAOL	telnet.h	90;"	d
TELOPT_NAOLFD	telnet.h	98;"	d
TELOPT_NAOP	telnet.h	91;"	d
TELOPT_NAOVTD	telnet.h	97;"	d
TELOPT_NAOVTS	telnet.h	96;"	d
TELOPT_NAWS	telnet.h	113;"	d
TELOPT_NEW_ENVIRON	telnet.h	121;"	d
TELOPT_OK	telnet.h	142;"	d
TELOPT_OLD_ENVIRON	telnet.h	118;"	d
TELOPT_OUTMRK	telnet.h	109;"	d
TELOPT_RCP	telnet.h	84;"	d
TELOPT_RCTE	telnet.h	89;"	d
TELOPT_SGA	telnet.h	85;"	d
TELOPT_SNDLOC	telnet.h	105;"	d
TELOPT_STATUS	telnet.h	87;"	d
TELOPT_SUPDUP	telnet.h	103;"	d
TELOPT_SUPDUPOUTPUT	telnet.h	104;"	d
TELOPT_TM	telnet.h	88;"	d
TELOPT_TSPEED	telnet.h	114;"	d
TELOPT_TTYLOC	telnet.h	110;"	d
TELOPT_TTYPE	telnet.h	106;"	d
TELOPT_TUID	telnet.h	108;"	d
TELOPT_X3PAD	telnet.h	112;"	d
TELOPT_XASCII	telnet.h	99;"	d
TELOPT_XDISPLOC	telnet.h	117;"	d
TELQUAL_INFO	telnet.h	149;"	d
TELQUAL_IS	telnet.h	147;"	d
TELQUAL_NAME	telnet.h	151;"	d
TELQUAL_REPLY	telnet.h	150;"	d
TELQUAL_SEND	telnet.h	148;"	d
THEN	mods/catch.hpp	12217;"	d
THIRST	structs.h	452;"	d
TICK_RESOLUTION	mods/deferred.hpp	/^			constexpr static uint64_t TICK_RESOLUTION = 20;$/;"	m	class:mods::deferred
TIME_FILE	db.h	100;"	d
TIME_WITH_SYS_TIME	conf.h	29;"	d
TOGGLE_BIT	utils.h	195;"	d
TOGGLE_LOCK	act.movement.cpp	354;"	d	file:
TOG_OFF	act.other.cpp	905;"	d	file:
TOG_ON	act.other.cpp	906;"	d	file:
TOP_SPELL_DEFINE	spells.h	122;"	d
TOROOM	graph.cpp	56;"	d	file:
TOROOM	house.h	30;"	d
TO_CHAR	comm.h	63;"	d
TO_NOTVICT	comm.h	62;"	d
TO_ROOM	comm.h	60;"	d
TO_SLEEP	comm.h	64;"	d
TO_VICT	comm.h	61;"	d
TRADE_NOCLERIC	shop.h	78;"	d
TRADE_NOEVIL	shop.h	75;"	d
TRADE_NOGOOD	shop.h	74;"	d
TRADE_NOMAGIC_USER	shop.h	77;"	d
TRADE_NONEUTRAL	shop.h	76;"	d
TRADE_NOTHIEF	shop.h	79;"	d
TRADE_NOWARRIOR	shop.h	80;"	d
TRUE	utils.h	518;"	d
TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED	mods/catch.hpp	2812;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED	mods/catch.hpp	8518;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED	mods/catch.hpp	924;"	d
TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED	mods/catch.hpp	856;"	d
TWOBLUECUBES_CATCH_CLARA_H_INCLUDED	mods/catch.hpp	4220;"	d
TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED	mods/catch.hpp	3584;"	d
TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED	mods/catch.hpp	9056;"	d
TWOBLUECUBES_CATCH_COMMON_H_INCLUDED	mods/catch.hpp	67;"	d
TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED	mods/catch.hpp	70;"	d
TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED	mods/catch.hpp	3587;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED	mods/catch.hpp	5856;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED	mods/catch.hpp	8205;"	d
TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED	mods/catch.hpp	532;"	d
TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED	mods/catch.hpp	8005;"	d
TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED	mods/catch.hpp	9213;"	d
TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED	mods/catch.hpp	2120;"	d
TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED	mods/catch.hpp	12040;"	d
TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED	mods/catch.hpp	1291;"	d
TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED	mods/catch.hpp	7853;"	d
TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED	mods/catch.hpp	1288;"	d
TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED	mods/catch.hpp	6760;"	d
TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED	mods/catch.hpp	2529;"	d
TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED	mods/catch.hpp	8439;"	d
TWOBLUECUBES_CATCH_HPP_INCLUDED	mods/catch.hpp	14;"	d
TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED	mods/catch.hpp	3570;"	d
TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED	mods/catch.hpp	2083;"	d
TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED	mods/catch.hpp	3902;"	d
TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED	mods/catch.hpp	2709;"	d
TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED	mods/catch.hpp	535;"	d
TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED	mods/catch.hpp	2715;"	d
TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED	mods/catch.hpp	5915;"	d
TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED	mods/catch.hpp	2186;"	d
TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED	mods/catch.hpp	3132;"	d
TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED	mods/catch.hpp	696;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED	mods/catch.hpp	8872;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED	mods/catch.hpp	8875;"	d
TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED	mods/catch.hpp	5656;"	d
TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED	mods/catch.hpp	1045;"	d
TWOBLUECUBES_CATCH_MATCHERS_STRING_H_INCLUDED	mods/catch.hpp	2978;"	d
TWOBLUECUBES_CATCH_MATCHERS_VECTOR_H_INCLUDED	mods/catch.hpp	3033;"	d
TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED	mods/catch.hpp	8838;"	d
TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED	mods/catch.hpp	2027;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED	mods/catch.hpp	7984;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED	mods/catch.hpp	64;"	d
TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED	mods/catch.hpp	1543;"	d
TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED	mods/catch.hpp	3338;"	d
TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED	mods/catch.hpp	3156;"	d
TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED	mods/catch.hpp	2123;"	d
TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED	mods/catch.hpp	559;"	d
TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED	mods/catch.hpp	10648;"	d
TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED	mods/catch.hpp	7592;"	d
TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED	mods/catch.hpp	10057;"	d
TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED	mods/catch.hpp	11664;"	d
TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED	mods/catch.hpp	11154;"	d
TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED	mods/catch.hpp	10891;"	d
TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED	mods/catch.hpp	9900;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED	mods/catch.hpp	10309;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED	mods/catch.hpp	7810;"	d
TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED	mods/catch.hpp	10054;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED	mods/catch.hpp	9579;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED	mods/catch.hpp	859;"	d
TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED	mods/catch.hpp	862;"	d
TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED	mods/catch.hpp	3581;"	d
TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED	mods/catch.hpp	6371;"	d
TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED	mods/catch.hpp	9174;"	d
TWOBLUECUBES_CATCH_SECTION_H_INCLUDED	mods/catch.hpp	2367;"	d
TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED	mods/catch.hpp	2370;"	d
TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED	mods/catch.hpp	3975;"	d
TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED	mods/catch.hpp	8008;"	d
TWOBLUECUBES_CATCH_STREAM_H_INCLUDED	mods/catch.hpp	3972;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED	mods/catch.hpp	3135;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED	mods/catch.hpp	9724;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED	mods/catch.hpp	9727;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED	mods/catch.hpp	8608;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED	mods/catch.hpp	3254;"	d
TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED	mods/catch.hpp	7595;"	d
TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED	mods/catch.hpp	6374;"	d
TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED	mods/catch.hpp	693;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED	mods/catch.hpp	3598;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED	mods/catch.hpp	3590;"	d
TWOBLUECUBES_CATCH_TEXT_H_INCLUDED	mods/catch.hpp	5659;"	d
TWOBLUECUBES_CATCH_TIMER_H_INCLUDED	mods/catch.hpp	2473;"	d
TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED	mods/catch.hpp	9332;"	d
TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED	mods/catch.hpp	1533;"	d
TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED	mods/catch.hpp	2373;"	d
TWOBLUECUBES_CATCH_TYPE_TRAITS_HPP_INCLUDED	mods/catch.hpp	2198;"	d
TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED	mods/catch.hpp	8803;"	d
TWOBLUECUBES_CATCH_VERSION_H_INCLUDED	mods/catch.hpp	7331;"	d
TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED	mods/catch.hpp	3606;"	d
TWOBLUECUBES_CATCH_WINDOWS_H_PROXY_H_INCLUDED	mods/catch.hpp	6776;"	d
TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED	mods/catch.hpp	10396;"	d
TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED	mods/catch.hpp	4439;"	d
TWOBLUECUBES_CLARA_H_INCLUDED	mods/catch.hpp	4239;"	d
TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED	mods/catch.hpp	12;"	d
TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED	mods/catch.hpp	5669;"	d
TYPE_BITE	spells.h	132;"	d
TYPE_BLAST	spells.h	140;"	d
TYPE_BLUDGEON	spells.h	133;"	d
TYPE_CLAW	spells.h	136;"	d
TYPE_CRUSH	spells.h	134;"	d
TYPE_HIT	spells.h	128;"	d
TYPE_MAUL	spells.h	137;"	d
TYPE_PIERCE	spells.h	139;"	d
TYPE_POUND	spells.h	135;"	d
TYPE_PUNCH	spells.h	141;"	d
TYPE_SLASH	spells.h	131;"	d
TYPE_SNIPE	spells.h	143;"	d
TYPE_STAB	spells.h	142;"	d
TYPE_STING	spells.h	129;"	d
TYPE_SUFFERING	spells.h	145;"	d
TYPE_THRASH	spells.h	138;"	d
TYPE_UNDEFINED	mods/behaviour_tree_impl.hpp	39;"	d
TYPE_UNDEFINED	spells.h	34;"	d
TYPE_WHIP	spells.h	130;"	d
TYPO_FILE	db.h	90;"	d
TestFailureException	mods/catch.hpp	/^	struct TestFailureException {};$/;"	s	namespace:Catch
TestFunction	mods/catch.hpp	/^	typedef void(*TestFunction)();$/;"	t	namespace:Catch
ThrewException	mods/catch.hpp	/^			ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
TrueType	mods/catch.hpp	/^		struct TrueType {$/;"	s	namespace:Catch::Detail
TupleDetail	mods/catch.hpp	/^	namespace TupleDetail {$/;"	n	namespace:Catch
UNKNOWN_STATUS	mods/behaviour_tree_status.hpp	/^		UNKNOWN_STATUS$/;"	e	enum:mods::behaviour_tree_status
UNLOCK_DOOR	act.movement.cpp	351;"	d	file:
UNMARK	graph.cpp	54;"	d	file:
UNSWITCH	interpreter.cpp	1294;"	d	file:
UP	structs.h	95;"	d
UPDATE	mods/lmdb.hpp	/^		EXEC, UPDATE, INSERT $/;"	e	enum:mods::lmdb::transact_type_t
UPPER	utils.h	148;"	d
USERS_FORMAT	act.informative.cpp	1402;"	d	file:
USE_AUTOEQ	structs.h	56;"	d
USURP	interpreter.cpp	1293;"	d	file:
Unknown	mods/catch.hpp	/^			Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
VALID_EDGE	graph.cpp	/^int VALID_EDGE(room_rnum x, int y) {$/;"	f
VALID_OBJ_RNUM	utils.h	386;"	d
VALID_ROOM_RNUM	utils.h	255;"	d
VANISH	act.item.cpp	470;"	d	file:
VERSION3_TAG	shop.h	51;"	d
VIRTUAL	db.h	/^	VIRTUAL\\$/;"	e	enum:__anon1
Valid_Name	ban.cpp	/^int Valid_Name(const char *newname) {$/;"	f
WAIT_STATE	utils.h	366;"	d
WANDER	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
WEAPON	mods/object.hpp	/^		WEAPON = 1,$/;"	e	enum:mods::object::type
WEAPON_SET_NUM	mods/player.hpp	27;"	d
WEAR_ABOUT	structs.h	315;"	d
WEAR_ARMS	structs.h	313;"	d
WEAR_BODY	structs.h	308;"	d
WEAR_FEET	structs.h	311;"	d
WEAR_FINGER_L	structs.h	305;"	d
WEAR_FINGER_R	structs.h	304;"	d
WEAR_HANDS	structs.h	312;"	d
WEAR_HEAD	structs.h	309;"	d
WEAR_HOLD	structs.h	320;"	d
WEAR_LEGS	structs.h	310;"	d
WEAR_LIGHT	structs.h	303;"	d
WEAR_NECK_1	structs.h	306;"	d
WEAR_NECK_2	structs.h	307;"	d
WEAR_SHIELD	structs.h	314;"	d
WEAR_WAIST	structs.h	316;"	d
WEAR_WIELD	structs.h	319;"	d
WEAR_WRIST_L	structs.h	318;"	d
WEAR_WRIST_R	structs.h	317;"	d
WELC_MESSG	config.cpp	/^const char *WELC_MESSG =$/;"	v
WEST	structs.h	94;"	d
WHEN	mods/catch.hpp	12215;"	d
WHO_FORMAT	act.informative.cpp	1213;"	d	file:
WILL	telnet.h	46;"	d
WILL_BANK_MONEY	shop.h	131;"	d
WILL_START_FIGHT	shop.h	130;"	d
WIN32_LEAN_AND_MEAN	mods/catch.hpp	6782;"	d
WIN32_LEAN_AND_MEAN	mods/catch.hpp	6795;"	d
WIZLIST_FILE	db.h	83;"	d
WLD_PREFIX	db.h	69;"	d
WONT	telnet.h	45;"	d
WRITE_LVL	boards.h	38;"	d
Warning	mods/catch.hpp	/^			Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
XNAME_FILE	db.h	94;"	d
YES	config.cpp	20;"	d	file:
YESNO	utils.h	144;"	d
Yes	mods/catch.hpp	/^			Yes,$/;"	e	enum:Catch::CaseSensitive::Choice
Z	db.cpp	1701;"	d	file:
Z	db.cpp	1709;"	d	file:
ZONE_ERROR	db.cpp	2012;"	d	file:
ZON_PREFIX	db.h	72;"	d
ZO_DEAD	db.cpp	1932;"	d	file:
Z_KINGS_C	castle.cpp	31;"	d	file:
_ARPA_TELNET_H	telnet.h	37;"	d
_BSD_SNPRINTF_H	bsd-snprintf.h	41;"	d
_BSD_SOURCE	mods/catch.hpp	146;"	d
_CIRCLEMUD	structs.h	46;"	d
_POSIX_C_SOURCE	sysdep.h	293;"	d
_POSIX_C_SOURCE	sysdep.h	295;"	d
__ACT_OTHER_C__	act.other.cpp	11;"	d	file:
__CIRCLEMUD_SRC_MODS_GLOBALS_HEADER__	globals.hpp	2;"	d
__CIRCLEMUD_SRC_MODS_GLOBALS_SOURCE__	globals.cpp	2;"	d	file:
__CIRCLEMUD_SRC_MODS_OBJECT_HEADER__	mods/object.hpp	2;"	d
__CIRCLEMUD_STRUCTS_HEADER__	structs.h	12;"	d
__COMM_C__	comm.cpp	11;"	d	file:
__CONFIG_C__	config.cpp	11;"	d	file:
__DB_C__	db.cpp	11;"	d	file:
__INTERPRETER_C__	interpreter.cpp	11;"	d	file:
__INTERPRETER_C__	login.hpp	3;"	d
__INTERPRETER_HEADER__	interpreter.h	2;"	d
__MENTOC_CONFIG_HEADER__	config.hpp	2;"	d
__MENTOC_DB_HEADER__	db.h	2;"	d
__MENTOC_HELL_HEADER__	mods/hell.hpp	2;"	d
__MENTOC_LOGIN_HEADER__	login.hpp	2;"	d
__MENTOC_MODS_ACL_LIST_HEADER__	mods/acl_list.hpp	2;"	d
__MENTOC_MODS_BAN_SYSTEM_HEADER__	mods/ban_system.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_HEADER__	mods/behaviour_tree.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_IMPL_HEADER__	mods/behaviour_tree_impl.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_NODE_HEADER__	mods/behaviour_tree_node.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_STATUS_HEADER__	mods/behaviour_tree_status.hpp	2;"	d
__MENTOC_MODS_BUILDER_HEADER__	mods/builder.hpp	2;"	d
__MENTOC_MODS_CHAT_HEADER__	mods/chat.hpp	2;"	d
__MENTOC_MODS_CONF_HEADER__	mods/conf.hpp	2;"	d
__MENTOC_MODS_CRYPTO_HEADER__	mods/crypto.hpp	2;"	d
__MENTOC_MODS_DB_LIB__	mods/db.hpp	2;"	d
__MENTOC_MODS_DRONE_HEADER__	mods/drone.hpp	2;"	d
__MENTOC_MODS_DRONE_SOURCE__	mods/drone.cpp	2;"	d	file:
__MENTOC_MODS_IMMORTAL_HEADER__	mods/immortal.hpp	2;"	d
__MENTOC_MODS_JS_HEADER__	mods/js.hpp	2;"	d
__MENTOC_MODS_JX_HEADER__	mods/jx.hpp	2;"	d
__MENTOC_MODS_LMDB_HEADER__	mods/lmdb.hpp	2;"	d
__MENTOC_MODS_LOOPS_HEADER__	mods/loops.hpp	2;"	d
__MENTOC_MODS_META_UTILS_HEADER__	mods/meta_utils.hpp	2;"	d
__MENTOC_MODS_PLAYER_HEADER__	mods/player.hpp	2;"	d
__MENTOC_MODS_PLAYER_SCAFFOLDING_HEADER__	mods/player-scaffolding.hpp	2;"	d
__MENTOC_MODS_PLAYER_SOURCE__	mods/player.cpp	2;"	d	file:
__MENTOC_MODS_PQ_HEADER__	mods/pq.hpp	2;"	d
__MENTOC_MODS_PROJECTILE_HEADER__	mods/projectile.hpp	2;"	d
__MENTOC_MODS_QUESTS_HEADER__	mods/quests.hpp	2;"	d
__MENTOC_MODS_SCAN_HEADER__	mods/scan.hpp	2;"	d
__MENTOC_MODS_SCHEMA_HEADER__	mods/schema.hpp	2;"	d
__MENTOC_MODS_SQL_HEADER__	mods/sql.hpp	10;"	d
__MENTOC_MODS_STRING_HEADER__	mods/string.hpp	2;"	d
__MENTOC_MODS_TESTING_INDEX_HEADER__	mods/testing_index.hpp	2;"	d
__MENTOC_MODS_WEAPON_HEADER__	mods/weapon.hpp	2;"	d
__MENTOC_MODS_ai_state_HEADER__	mods/ai_state.hpp	2;"	d
__MENTOC_MODS_cron_HEADER__	mods/cron.hpp	2;"	d
__MENTOC_MODS_deferred_HEADER__	mods/deferred.hpp	2;"	d
__MENTOC_MODS_prefs_HEADER__	mods/prefs.hpp	2;"	d
__MENTOC_MODS_pregame_HEADER__	mods/pregame.hpp	2;"	d
__MENTOC_STRING_LIT__	mods/util.hpp	20;"	d
__MENTOC_TYPES_HEADER__	types.hpp	2;"	d
__MENTOC_UTILS_HEADER__	mods/util.hpp	2;"	d
__MENTOC_UTILS_SOURCE__	mods/util.cpp	2;"	d	file:
__MENTOC_UTIL_CONF_HEADER__	mods/util-conf.hpp	2;"	d
__MENTOC_UTIL_MAP_HEADER__	mods/util-map.hpp	2;"	d
__SHOP_HEADER__	shop.h	12;"	d
__STATE_GUARD__	utils.h	23;"	d
__attribute__	sysdep.h	339;"	d
__find_player_by_name	mods/js.cpp	/^			static inline bool __find_player_by_name(std::shared_ptr<mods::player> player_ptr,find_player_payload_t* param){$/;"	f	namespace:mods::js::utils
_clrlevel	screen.h	26;"	d
_db_handle	mods/lmdb.cpp	/^	_db_handle::_db_handle(std::string directory,std::string db_name,const uint64_t & flags,const uint16_t & mode,bool unused) $/;"	f	class:mods::lmdb::_db_handle
_db_handle	mods/lmdb.hpp	/^	struct _db_handle {$/;"	s	namespace:mods::lmdb
_old_unused_vwrite_to_output_unused_	comm.cpp	/^size_t _old_unused_vwrite_to_output_unused_(mods::descriptor_data &t, const char *format, va_list args) {$/;"	f
_parse_name	interpreter.cpp	/^int _parse_name(char *arg, char *name) {$/;"	f
_s	mods/lmdb.hpp	/^	inline static std::string operator "" _s(const char* str,std::size_t size){ $/;"	f	namespace:mods::lmdb
_s	mods/util.hpp	/^static inline std::string operator "" _s(const char* s,long unsigned int i) {$/;"	f
_selector	mods/lmdb.hpp	/^	struct _selector {$/;"	s	namespace:mods::lmdb
_write_one_node	ban.cpp	/^void _write_one_node(FILE *fp, struct ban_list_element *node) {$/;"	f
a	random.cpp	48;"	d	file:
a_type	structs.h	/^	int	a_type;			\/* Attack type				*\/$/;"	m	struct:message_list
abilities	structs.h	/^	struct char_ability_data abilities;$/;"	m	struct:char_file_u	typeref:struct:char_file_u::char_ability_data
abort_txn	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::abort_txn(){$/;"	f	class:mods::lmdb::_db_handle
abs_val	bsd-snprintf.cpp	155;"	d	file:
account	structs.h	/^	int	account;$/;"	m	struct:rent_info
acl_allowed	globals.cpp	/^		bool acl_allowed(struct char_data *ch,const char* command_name,const char* file,int cmd,const char* arg,int subcmd) {$/;"	f	namespace:mods::globals
acl_list	mods/acl_list.cpp	/^namespace mods::acl_list {$/;"	n	class:mods	file:
acl_list	mods/acl_list.hpp	/^namespace mods::acl_list {$/;"	n	class:mods
acl_list	mods/player.hpp	/^namespace mods::acl_list {$/;"	n	class:mods
act	comm.cpp	/^void act(const char *str, int hide_invisible, char_data *ch,$/;"	f
act	structs.h	/^	long \/*bitvector_t*\/ act;	\/* act flag for NPC's; player flag for PC's *\/$/;"	m	struct:char_special_data_saved
act_nr	act.social.cpp	/^	int act_nr;$/;"	m	struct:social_messg	file:
action_bits	constants.cpp	/^const char *action_bits[] = {$/;"	v
action_bits	constants.hpp	/^const char *action_bits[] = {$/;"	v
action_bits_count	constants.cpp	/^        action_bits_count = sizeof(action_bits) \/ sizeof(action_bits[0]) - 1,$/;"	v
action_bits_count	constants.hpp	/^	action_bits_count = sizeof(action_bits) \/ sizeof(action_bits[0]) - 1,$/;"	v
action_description	structs.h	/^	char	*action_description;      \/* What to write when used          *\/$/;"	m	struct:obj_data
addRef	mods/catch.hpp	/^		virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl
add_follower	utils.cpp	/^void add_follower(struct char_data *ch, struct char_data *leader) {$/;"	f
add_private_publisher	mods/chat.cpp	/^	void channel::add_private_publisher(std::string_view user) {$/;"	f	class:mods::chat::channel
add_subscriber	mods/chat.cpp	/^	void channel::add_subscriber(const socket_t& sock) {$/;"	f	class:mods::chat::channel
add_to_list	shop.cpp	/^int add_to_list(struct shop_buy_data *list, int type, int *len, int *val) {$/;"	f
advance_level	class.cpp	/^void advance_level(struct char_data *ch) {$/;"	f
aff_abils	structs.h	/^	char_ability_data aff_abils;	 \/* Abils with spells\/stones\/etc  *\/$/;"	m	struct:char_data
aff_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,22> aff_flags = { {$/;"	m	namespace:mods::builder	file:
affect	mods/player.cpp	/^			void player::affect(int64_t flag){$/;"	f	class:mods::player
affect_from_char	handler.cpp	/^void affect_from_char(struct char_data *ch, int type) {$/;"	f
affect_from_char	mods/js.cpp	/^		static duk_ret_t affect_from_char(duk_context *ctx) {$/;"	f	namespace:mods::js
affect_join	handler.cpp	/^void affect_join(struct char_data *ch, struct affected_type *af,$/;"	f
affect_modify	handler.cpp	/^void affect_modify(struct char_data *ch, byte loc, sbyte mod,$/;"	f
affect_plr	mods/player.cpp	/^			void player::affect_plr(int64_t flag){$/;"	f	class:mods::player
affect_remove	handler.cpp	/^void affect_remove(struct char_data *ch, struct affected_type *af) {$/;"	f
affect_to_char	handler.cpp	/^void affect_to_char(struct char_data *ch, struct affected_type *af) {$/;"	f
affect_total	handler.cpp	/^void affect_total(struct char_data *ch) {$/;"	f
affect_update	magic.cpp	/^void affect_update(void) {$/;"	f
affected	structs.h	/^	affected_type *affected;       \/* affected by what spells       *\/$/;"	m	struct:char_data
affected	structs.h	/^	struct affected_type affected[MAX_AFFECT];$/;"	m	struct:char_file_u	typeref:struct:char_file_u::affected_type
affected	structs.h	/^	struct obj_affected_type affected[MAX_OBJ_AFFECT];  \/* affects *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::obj_affected_type
affected	structs.h	/^	struct obj_affected_type affected[MAX_OBJ_AFFECT];$/;"	m	struct:obj_file_elem	typeref:struct:obj_file_elem::obj_affected_type
affected_bits	constants.cpp	/^const char *affected_bits[] = {$/;"	v
affected_bits	constants.hpp	/^const char *affected_bits[] =$/;"	v
affected_bits_count	constants.cpp	/^        affected_bits_count = sizeof(affected_bits) \/ sizeof(affected_bits[0]) - 1,$/;"	v
affected_bits_count	constants.hpp	/^	affected_bits_count = sizeof(affected_bits) \/ sizeof(affected_bits[0]) - 1,$/;"	v
affected_by	structs.h	/^	long \/*bitvector_t*\/	affected_by;$/;"	m	struct:char_special_data_saved
affected_by_spell	handler.cpp	/^bool affected_by_spell(struct char_data *ch, int type) {$/;"	f
affected_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,25> affected_flags = { {$/;"	m	namespace:mods::builder	file:
affected_type	structs.h	/^struct affected_type {$/;"	s
age	db.h	/^	int	age;                \/* current age of this zone (minutes) *\/$/;"	m	struct:zone_data
age	utils.cpp	/^struct time_info_data *age(struct char_data *ch) {$/;"	f
aggressive_mob_on_a_leash	mobact.cpp	/^bool aggressive_mob_on_a_leash(char_data *slave,char_data *master,char_data *attack) {$/;"	f
ai_state	mods/ai_state.hpp	/^			ai_state(char_data* ch,uint8_t st,uint32_t aggr) : m_char_data(ch), m_state(st), mpub_aggro(aggr) {$/;"	f	class:mods::ai_state
ai_state	mods/ai_state.hpp	/^	class ai_state {$/;"	c	namespace:mods
ai_state	structs.h	/^	uint8_t ai_state;$/;"	m	struct:obj_data
ai_state_map	structs.h	/^typedef std::map<struct char_data*,std::unique_ptr<mods::ai_state>> ai_state_map;$/;"	t
ai_state_t	structs.h	/^typedef short ai_state_t;$/;"	t
alias	interpreter.h	/^	char *alias;$/;"	m	struct:alias_data
alias_data	interpreter.h	/^struct alias_data {$/;"	s
aliased	structs.h	/^	int aliased;$/;"	m	struct:txt_block
aliases	structs.h	/^	struct alias_data *aliases;	\/* Character's aliases			*\/$/;"	m	struct:player_special_data	typeref:struct:player_special_data::alias_data
alignment	structs.h	/^	int	alignment;		\/* +-1000 for alignments                *\/$/;"	m	struct:char_special_data_saved
all_aff_flags	mods/player.cpp	/^				const std::array<int64_t,AFF_FLAG_BIT_COUNT> all_aff_flags = {$/;"	m	namespace:mods	file:
all_plr_flags	mods/player.cpp	/^				const std::array<int64_t,PLR_FLAG_BIT_COUNT> all_plr_flags = {$/;"	m	namespace:mods	file:
alwaysFalse	mods/catch.hpp	/^	inline bool alwaysFalse() {$/;"	f	namespace:Catch
alwaysTrue	mods/catch.hpp	/^	inline bool alwaysTrue() {$/;"	f	namespace:Catch
ammo	structs.h	/^	int16_t ammo;$/;"	m	struct:obj_data
ammo_adjustment	mods/player.cpp	/^	void player::ammo_adjustment(int increment) {$/;"	f	class:mods::player
ammo_max	structs.h	/^	int16_t ammo_max;$/;"	m	struct:obj_data
ammo_type_adjustment	mods/player.cpp	/^	int player::ammo_type_adjustment(int increment,const weapon_type_t& type) {$/;"	f	class:mods::player
another_hour	weather.cpp	/^void another_hour(int mode) {$/;"	f
any_one_arg	interpreter.cpp	/^char *any_one_arg(char *argument, char *first_arg) {$/;"	f
appear	fight.cpp	/^void appear(struct char_data *ch) {$/;"	f
append_child	mods/behaviour_tree_node.hpp	/^		void append_child(const child_node_t & child){$/;"	f	struct:mods::behaviour_tree_node
applyEvaluator	mods/catch.hpp	/^		bool applyEvaluator(T1 const& lhs, T2 const& rhs) {$/;"	f	namespace:Catch::Internal
apply_ac	handler.cpp	/^int apply_ac(struct char_data *ch, int eq_pos) {$/;"	f
apply_saving_throw	structs.h	/^	sh_int apply_saving_throw[5]; \/* Saving throw (Bonuses)		*\/$/;"	m	struct:char_special_data_saved
apply_types	constants.cpp	/^const char *apply_types[] = {$/;"	v
apply_types	constants.hpp	/^const char *apply_types[] = {$/;"	v
arcSafeRelease	mods/catch.hpp	/^inline void arcSafeRelease(NSObject* obj) {$/;"	f
arcSafeRelease	mods/catch.hpp	/^inline void arcSafeRelease(NSObject*) {}$/;"	f
arg1	db.h	/^	int	arg1;		\/*                                      *\/$/;"	m	struct:reset_com
arg2	db.h	/^	int	arg2;		\/* Arguments to the command             *\/$/;"	m	struct:reset_com
arg3	db.h	/^	int	arg3;		\/*                                      *\/$/;"	m	struct:reset_com
arglist	mods/util.hpp	/^	T arglist(const std::string& argument) {$/;"	f	namespace:mods::util
argument_interpreter	interpreter.h	42;"	d
argument_type	mods/behaviour_tree_impl.hpp	/^		typedef T argument_type;$/;"	t	namespace:mods::behaviour_tree_impl
armor	mods/player.hpp	/^			sh_int& armor() {$/;"	f	class:mods::player
armor	structs.h	/^	sh_int armor;        \/* Internal -100..100, external -10..10 AC *\/$/;"	m	struct:char_point_data
array_end	mods/jx.hpp	/^			compositor& array_end() {$/;"	f	struct:mods::jx::compositor
array_start	mods/jx.hpp	/^			compositor& array_start(const std::string& key) {$/;"	f	struct:mods::jx::compositor
as_int	mods/pq.cpp	/^	int as_int(result& r,int index, int index_y) {$/;"	f	namespace:mods::pq
asciiflag_conv	db.cpp	/^bitvector_t asciiflag_conv(char *flag) {$/;"	f
assert	sysdep.h	241;"	d
assign	mods/string.cpp	/^	void string::assign(const std::string & other){$/;"	f	class:mods::string
assign_kings_castle	castle.cpp	/^void assign_kings_castle(void) {$/;"	f
assign_mobiles	mods/hell.hpp	/^	constexpr inline bool assign_mobiles = false;$/;"	m	namespace:mods::hell
assign_mobiles	spec_assign.cpp	/^void assign_mobiles(void) {$/;"	f
assign_objects	mods/hell.hpp	/^	constexpr inline bool assign_objects = false;$/;"	m	namespace:mods::hell
assign_objects	spec_assign.cpp	/^void assign_objects(void) {$/;"	f
assign_rooms	mods/hell.hpp	/^	constexpr inline bool assign_rooms = false;$/;"	m	namespace:mods::hell
assign_rooms	spec_assign.cpp	/^void assign_rooms(void) {$/;"	f
assign_the_shopkeepers	mods/hell.hpp	/^	constexpr inline bool assign_the_shopkeepers = false;$/;"	m	namespace:mods::hell
assign_the_shopkeepers	shop.cpp	/^void assign_the_shopkeepers(void) {$/;"	f
atrium	house.h	/^	room_vnum atrium;		\/* vnum of atrium		*\/$/;"	m	struct:house_control_rec
attack_hit_text	fight.cpp	/^struct attack_hit_type attack_hit_text[] = {$/;"	v	typeref:struct:attack_hit_type
attack_hit_type	spells.h	/^struct attack_hit_type {$/;"	s
attack_type	structs.h	/^	byte	attack_type;        \/* The Attack Type Bitvector for NPC's     *\/$/;"	m	struct:mob_special_data
attacker_msg	structs.h	/^	char	*attacker_msg;  \/* message to attacker *\/$/;"	m	struct:msg_type
authtype_names	telnet.h	/^char *authtype_names[] = {$/;"	v
auto_equip	objsave.cpp	/^void auto_equip(struct char_data *ch, struct obj_data *obj, int location) {$/;"	f
auto_save	config.cpp	/^int auto_save = YES;$/;"	v
autosave_time	config.cpp	/^int autosave_time = 5;$/;"	v
award_quest	mods/quests.cpp	/^		void award_quest(struct char_data* ch,int quest_id) {$/;"	f	namespace:mods::quests
background	db.cpp	/^char *background = NULL;	\/* background story		 *\/$/;"	v
backstab_mult	class.cpp	/^int backstab_mult(int level) {$/;"	f
bad_pws	structs.h	/^		byte	bad_pws;		\/* number of bad pw attemps this login	*\/$/;"	m	struct:mods::descriptor_data
bad_pws	structs.h	/^	ubyte bad_pws;		\/* number of bad password attemps	*\/$/;"	m	struct:player_special_data_saved
ban_list	ban.cpp	/^struct ban_list_element *ban_list = NULL;$/;"	v	typeref:struct:ban_list_element
ban_list_element	db.h	/^struct ban_list_element {$/;"	s
ban_system	mods/ban_system.hpp	/^	namespace ban_system {$/;"	n	namespace:mods
ban_types	ban.cpp	/^const char *ban_types[] = {$/;"	v
bank	spec_assign.cpp	/^SPECIAL(bank);$/;"	v
bank	spec_procs.cpp	/^SPECIAL(bank);$/;"	v
bankAccount	shop.h	/^	int	 bankAccount;		\/* Store all gold over 15000 (disabled)	*\/$/;"	m	struct:shop_data
bank_gold	mods/player.hpp	/^			int& bank_gold() {$/;"	f	class:mods::player
bank_gold	structs.h	/^	int	bank_gold;	\/* Gold the char has in a bank account	   *\/$/;"	m	struct:char_point_data
banzaii	castle.cpp	/^int banzaii(struct char_data *ch) {$/;"	f
basic_mud_log	utils.cpp	/^void basic_mud_log(const char *format, ...) {$/;"	f
basic_mud_vlog	utils.cpp	/^void basic_mud_vlog(const char *format, va_list args) {$/;"	f
behaviour_tree	mods/behaviour_tree.hpp	/^		behaviour_tree() : m_tree_name("default") {}$/;"	f	struct:mods::behaviour_tree
behaviour_tree	mods/behaviour_tree.hpp	/^		behaviour_tree(const std::string_view & name) : m_tree_name(name) {}$/;"	f	struct:mods::behaviour_tree
behaviour_tree	mods/behaviour_tree.hpp	/^		behaviour_tree(const std::string_view & name,$/;"	f	struct:mods::behaviour_tree
behaviour_tree	mods/behaviour_tree.hpp	/^	struct behaviour_tree {$/;"	s	namespace:mods
behaviour_tree	structs.h	/^	int16_t behaviour_tree;$/;"	m	struct:mob_special_data
behaviour_tree_impl	mods/behaviour_tree_impl.cpp	/^namespace mods::behaviour_tree_impl {$/;"	n	class:mods	file:
behaviour_tree_impl	mods/behaviour_tree_impl.hpp	/^	namespace behaviour_tree_impl { $/;"	n	namespace:mods
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(callback_t& c, const node_type_t& t) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(callback_t& c,const node_type_t& t, const children_t& ch) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(const node_type_t& t) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(const node_type_t& t,const children_t & ch) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^	struct behaviour_tree_node {$/;"	s	namespace:mods
behaviour_tree_status	mods/behaviour_tree_status.hpp	/^	enum behaviour_tree_status {$/;"	g	namespace:mods
bfs_clear_queue	graph.cpp	/^void bfs_clear_queue(void) {$/;"	f
bfs_dequeue	graph.cpp	/^void bfs_dequeue(void) {$/;"	f
bfs_enqueue	graph.cpp	/^void bfs_enqueue(room_rnum room, int dir) {$/;"	f
bfs_queue_struct	graph.cpp	/^struct bfs_queue_struct {$/;"	s	file:
birth	structs.h	/^	time_t birth;    \/* This represents the characters age                *\/$/;"	m	struct:time_data
birth	structs.h	/^	time_t birth;   \/* Time of birth of character     *\/$/;"	m	struct:char_file_u
bitvector	shop.h	/^	bitvector_t	 bitvector;	\/* Can attack? Use bank? Cast here?	*\/$/;"	m	struct:shop_data
bitvector	structs.h	/^	long \/*bitvector_t*\/	bitvector;	\/* To set chars bits                *\/$/;"	m	struct:obj_flag_data
bitvector	structs.h	/^	long \/*bitvector_t*\/	bitvector; \/* Tells which bits to set (AFF_XXX) *\/$/;"	m	struct:affected_type
bitvector	structs.h	/^	long \/*bitvector_t*\/	bitvector;$/;"	m	struct:obj_file_elem
bitvector_t	structs.h	/^typedef unsigned long int	bitvector_t;$/;"	t
block_type	mail.h	/^	long	block_type;		\/* -1 if header block, -2 if last data block$/;"	m	struct:data_block_type_d
block_type	mail.h	/^	long	block_type;		\/* is this a header or data block?	*\/$/;"	m	struct:header_block_type_d
block_way	castle.cpp	/^int block_way(struct char_data *ch, int cmd, char *arg, room_vnum iIn_room,$/;"	f
board_info	boards.cpp	/^struct board_info_type board_info[NUM_OF_BOARDS] = {$/;"	v	typeref:struct:board_info_type
board_info_type	boards.h	/^struct board_info_type {$/;"	s
board_msginfo	boards.h	/^struct board_msginfo {$/;"	s
bonus	structs.h	/^	byte bonus;       \/* how many practices player gains per lev *\/$/;"	m	struct:wis_app_type
bool	structs.h	/^typedef char			bool;$/;"	t
boot_db	db.cpp	/^void boot_db(void) {$/;"	f
boot_hell	db.cpp	/^void boot_hell(void){$/;"	f
boot_social_messages	act.social.cpp	/^void boot_social_messages(void) {$/;"	f
boot_social_messages	mods/hell.hpp	/^	constexpr inline bool boot_social_messages = false;$/;"	m	namespace:mods::hell
boot_sql_shops	shop.cpp	/^void boot_sql_shops() {$/;"	f
boot_suite	mods/pregame.cpp	/^	void boot_suite(std::string_view suite){$/;"	f	namespace:mods::pregame
boot_the_shops	shop.cpp	/^void boot_the_shops() {$/;"	f
boot_time	db.cpp	/^time_t boot_time = 0;		\/* time of mud boot		 *\/$/;"	v
boot_type_t	globals.hpp	/^		enum boot_type_t { BOOT_DB,BOOT_HELL };$/;"	g	namespace:mods::globals
boot_world	db.cpp	/^void boot_world(void) {$/;"	f
bootup_test_suite	globals.cpp	/^		std::string bootup_test_suite;$/;"	m	namespace:mods::globals	file:
bot	db.h	/^	uint64_t bot;           \/* starting room number for this zone *\/$/;"	m	struct:zone_data
buf_largecount	comm.cpp	/^int buf_largecount = 0;		\/* # of large buffers which exist *\/$/;"	v
buf_overflows	comm.cpp	/^int buf_overflows = 0;		\/* # of overflows of output *\/$/;"	v
buf_switches	comm.cpp	/^int buf_switches = 0;		\/* # of switches from small to large buf *\/$/;"	v
bufpool	comm.cpp	/^struct txt_block *bufpool = 0;	\/* pool of large output buffers *\/$/;"	v	typeref:struct:txt_block
bufptr	structs.h	/^		int bufptr;$/;"	m	struct:mods::descriptor_data
bufspace	structs.h	/^		int bufspace;$/;"	m	struct:mods::descriptor_data
build_player_index	db.cpp	/^void build_player_index(void) {$/;"	f
builder	mods/builder.cpp	/^namespace mods::builder {$/;"	n	class:mods	file:
builder	mods/builder.hpp	/^namespace mods::builder {$/;"	n	class:mods
builder_data	structs.h	/^	std::shared_ptr<builder_data_t> builder_data;$/;"	m	struct:char_data
builder_data_t	structs.h	/^	builder_data_t() : room_pave_mode(false),zone_pave_mode(false) {}$/;"	f	struct:builder_data_t
builder_data_t	structs.h	/^struct builder_data_t {$/;"	s
builder_mode	mods/player.cpp	/^			bool player::builder_mode() const{$/;"	f	class:mods::player
builder_util	mods/builder_util.hpp	/^namespace mods::builder_util {$/;"	n	class:mods
builders	mods/acl_list.cpp	/^		static player_acl_list_t builders;$/;"	m	namespace:mods::acl_list::list_container	file:
built_on	house.h	/^	time_t built_on;		\/* date this house was built	*\/$/;"	m	struct:house_control_rec
buy_price	shop.cpp	/^int buy_price(struct obj_data *obj, int shop_nr, struct char_data *keeper, struct char_data *buyer) {$/;"	f
byte	structs.h	/^typedef signed char			byte;$/;"	t
c_str	mods/string.cpp	/^	const char* string::c_str() const {$/;"	f	class:mods::string
call_magic	spell_parser.cpp	/^int call_magic(struct char_data *caster, struct char_data *cvict,$/;"	f
callback	mods/projectile.hpp	/^		typedef std::function<void (room_rnum,int)> callback;$/;"	t	namespace:mods::projectile
callback_t	mods/behaviour_tree_node.hpp	/^		typedef std::function<behaviour_tree_status(LambdaArgument)> callback_t;$/;"	t	struct:mods::behaviour_tree_node
can_modify	olc.cpp	/^int can_modify(struct char_data *ch, int vnum) {$/;"	f
can_snipe	mods/player.cpp	/^	bool player::can_snipe(char_data *target) {$/;"	f	class:mods::player
can_take_obj	act.item.cpp	/^int can_take_obj(struct char_data *ch, struct obj_data *obj) {$/;"	f
capture_output	mods/player.cpp	/^	void player::capture_output(bool capture_status) {$/;"	f	class:mods::player
capturedExpression	mods/catch.hpp	/^		std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo
carried_by	structs.h	/^	struct char_data *carried_by;  \/* Carried by :NULL in room\/conta   *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::char_data
carry_items	structs.h	/^	byte carry_items;		\/* Number of items carried		*\/$/;"	m	struct:char_special_data
carry_w	structs.h	/^	sh_int carry_w;  \/* Maximum weight that can be carrried *\/$/;"	m	struct:str_app_type
carry_weight	structs.h	/^	int	carry_weight;		\/* Carried weight			*\/$/;"	m	struct:char_special_data
carrying	structs.h	/^	obj_data *carrying;            \/* Head of list                  *\/$/;"	m	struct:char_data
carrying_ammo_of_type	mods/player.cpp	/^	bool player::carrying_ammo_of_type(const weapon_type_t& type) {$/;"	f	class:mods::player
cast_finite	mods/projectile.cpp	/^		room_rnum cast_finite(struct char_data* source_char,room_rnum source_room,int direction,int depth) {$/;"	f	namespace:mods::projectile
cast_spell	spell_parser.cpp	/^int cast_spell(struct char_data *ch, struct char_data *tch,$/;"	f
castle_cleaner	castle.cpp	/^int castle_cleaner(struct char_data *ch, int cmd, int gripe) {$/;"	f
castle_mob_spec	castle.cpp	/^void castle_mob_spec(mob_vnum mobnum, SPECIAL(*specproc)) {$/;"	f
castle_real_room	castle.cpp	/^room_rnum castle_real_room(room_vnum roomoffset) {$/;"	f
castle_twin_proc	castle.cpp	/^int castle_twin_proc(struct char_data *ch, int cmd, char *arg, int ctlnum, const char *twinname) {$/;"	f
castle_virtual	castle.cpp	/^mob_vnum castle_virtual(mob_vnum offset) {$/;"	f
cd	mods/drone.hpp	/^			char_data* cd() const {$/;"	f	class:mods::drone
cd	mods/player.hpp	/^			char_data* cd() const {$/;"	f	class:mods::player
ch	mods/scan.hpp	/^			char_data* ch;$/;"	m	struct:mods::scan::__anon4
cha	structs.h	/^	sbyte cha;$/;"	m	struct:char_ability_data
chan	globals.cpp	/^		std::vector<mods::chat::channel> chan;$/;"	m	namespace:mods::globals	file:
chan_verbs	globals.cpp	/^		std::vector<std::string> chan_verbs;$/;"	m	namespace:mods::globals	file:
change	structs.h	/^	int	change;	\/* How fast and what way does it change. *\/$/;"	m	struct:weather_data
change_alignment	fight.cpp	/^void change_alignment(struct char_data *ch, struct char_data *victim) {$/;"	f
channel	mods/chat.hpp	/^			channel(std::string_view name,std::string_view verb,bool b_private) :$/;"	f	struct:mods::mods::chat::channel
channel	mods/chat.hpp	/^	struct channel {$/;"	s	namespace:mods::mods::chat
char_ability_data	structs.h	/^	char_ability_data() : str(0),str_add(0),intel(0),$/;"	f	struct:char_ability_data
char_ability_data	structs.h	/^struct char_ability_data {$/;"	s
char_auto	act.social.cpp	/^	char *char_auto;$/;"	m	struct:social_messg	file:
char_data	mods/ai_state.hpp	/^typedef struct char_data char_data;$/;"	t	typeref:struct:char_data
char_data	structs.cpp	/^char_data::char_data(char_data* o){$/;"	f	class:char_data
char_data	structs.h	/^	char_data(){$/;"	f	struct:char_data
char_data	structs.h	/^struct char_data {$/;"	s
char_exists	db.cpp	/^bool char_exists(const std::string& name){$/;"	f
char_exists	db.cpp	/^bool char_exists(const std::string& name, aligned_int_t & meta_int_id){$/;"	f
char_exists	db.cpp	/^bool char_exists(std::shared_ptr<mods::player> player_ptr){$/;"	f
char_file_u	structs.h	/^struct char_file_u {$/;"	s
char_found	act.social.cpp	/^	char *char_found;		\/* if NULL, read no further, ignore args *\/$/;"	m	struct:social_messg	file:
char_from_room	globals.cpp	/^			void char_from_room(struct char_data* ch) {$/;"	f	namespace:mods::globals::rooms
char_from_room	handler.cpp	/^void char_from_room(struct char_data *ch) {$/;"	f
char_from_room	mods/js.cpp	/^		static duk_ret_t char_from_room(duk_context *ctx){$/;"	f	namespace:mods::js
char_no_arg	act.social.cpp	/^	char *char_no_arg;$/;"	m	struct:social_messg	file:
char_player_data	structs.cpp	/^char_player_data::char_player_data(){$/;"	f	class:char_player_data
char_player_data	structs.h	/^struct char_player_data {$/;"	s
char_point_data	structs.h	/^	char_point_data() : mana(0),max_mana(0),hit(0),max_hit(0),$/;"	f	struct:char_point_data
char_point_data	structs.h	/^struct char_point_data {$/;"	s
char_special_data	structs.h	/^struct char_special_data {$/;"	s
char_special_data_saved	structs.h	/^struct char_special_data_saved {$/;"	s
char_specials	structs.h	/^	char_special_data char_specials;	\/* PC\/NPC specials	  *\/$/;"	m	struct:char_data
char_specials_saved	structs.h	/^	struct char_special_data_saved char_specials_saved;$/;"	m	struct:char_file_u	typeref:struct:char_file_u::char_special_data_saved
char_to_int	bsd-snprintf.cpp	154;"	d	file:
char_to_room	globals.cpp	/^			void char_to_room(const room_rnum& room,struct char_data* ch) {$/;"	f	namespace:mods::globals::rooms
char_to_room	handler.cpp	/^void char_to_room(struct char_data *ch, room_rnum room) {$/;"	f
char_to_store	db.cpp	/^void char_to_store(struct char_data *ch, struct char_file_u *st) {$/;"	f
character	structs.h	/^		char_data *character;    \/** FIXME: turn to mods::player *\/$/;"	m	struct:mods::descriptor_data
character_list	globals.cpp	/^struct char_data* character_list = NULL;$/;"	v	typeref:struct:char_data
chat	mods/chat.cpp	/^namespace mods::chat {$/;"	n	class:mods	file:
chat	mods/chat.hpp	/^namespace mods::chat {$/;"	n	class:mods
chat	mods/chat.hpp	/^namespace mods::chat {$/;"	n	class:mods::mods
chclass	structs.h	/^	byte chclass;       \/* PC \/ NPC's class		       *\/$/;"	m	struct:char_player_data
chclass	structs.h	/^	byte chclass;$/;"	m	struct:char_file_u
chdir	sysdep.h	355;"	d
check_bitvector_names	db.cpp	/^int check_bitvector_names(bitvector_t bits, size_t namecount, const char *whatami, const char *whatbits) {$/;"	f
check_idle_passwords	comm.cpp	/^void check_idle_passwords(void) {$/;"	f
check_idling	limits.cpp	/^void check_idling(struct char_data *ch) {$/;"	f
check_killer	fight.cpp	/^void check_killer(struct char_data *ch, struct char_data *vict) {$/;"	f
check_object	db.cpp	/^int check_object(struct obj_data *obj) {$/;"	f
check_object_level	db.cpp	/^int check_object_level(struct obj_data *obj, int val) {$/;"	f
check_object_spell_number	db.cpp	/^int check_object_spell_number(struct obj_data *obj, int val) {$/;"	f
check_start_rooms	db.cpp	/^void check_start_rooms(void) {$/;"	f
checkpointing	comm.cpp	/^RETSIGTYPE checkpointing(int sig) {$/;"	f
child_node_t	mods/behaviour_tree_node.hpp	/^		typedef std::shared_ptr<behaviour_tree_node<LambdaArgument>> child_node_t;$/;"	t	struct:mods::behaviour_tree_node
children_t	mods/behaviour_tree_node.hpp	/^		typedef std::vector<child_node_t> children_t;$/;"	t	struct:mods::behaviour_tree_node
chptr	mods/scan.hpp	/^		typedef char_data* chptr;$/;"	t	namespace:mods::scan
circle_follow	utils.cpp	/^bool circle_follow(struct char_data *ch, struct char_data *victim) {$/;"	f
circle_random	random.cpp	/^unsigned long circle_random(void) {$/;"	f
circle_reboot	comm.cpp	/^int circle_reboot = 0;		\/* reboot the game after a shutdown *\/$/;"	v
circle_restrict	db.cpp	/^int circle_restrict = 0;	\/* level of game restriction	 *\/$/;"	v
circle_shutdown	comm.cpp	/^int circle_shutdown = 0;	\/* clean shutdown *\/$/;"	v
circle_sleep	comm.cpp	/^void circle_sleep(struct timeval *timeout) {$/;"	f
circle_srandom	random.cpp	/^void circle_srandom(unsigned long initial_seed) {$/;"	f
circlemud_version	constants.cpp	/^const char *circlemud_version =$/;"	v
circlemud_version	constants.hpp	/^constexpr const char *circlemud_version =$/;"	v
cityguard	spec_assign.cpp	/^SPECIAL(cityguard);$/;"	v
cityguard	spec_procs.cpp	/^SPECIAL(cityguard);$/;"	v
class_abbrevs	class.cpp	/^const char *class_abbrevs[] = {$/;"	v
class_capability_t	mods/player.hpp	/^			typedef std::vector<class_type> class_capability_t;$/;"	t	class:mods::player
class_info_t	mods/player.hpp	/^			typedef std::vector<std::shared_ptr<mods::classes::base>> class_info_t;$/;"	t	class:mods::player
class_menu	class.cpp	/^const char *class_menu =$/;"	v
cleaning	castle.cpp	/^SPECIAL(cleaning);$/;"	v
clear	mods/sql.hpp	/^			compositor<T>& clear() {$/;"	f	struct:mods::sql::compositor
clear	mods/string.cpp	/^	void string::clear(){$/;"	f	class:mods::string
clear	structs.h	/^		void clear(){ $/;"	f	struct:mods::descriptor_data
clearMemory	mobact.cpp	/^void clearMemory(char_data *ch) {$/;"	f
clear_all_affected	mods/player.cpp	/^			void player::clear_all_affected(){$/;"	f	class:mods::player
clear_all_affected_flags	mods/js.cpp	/^		static duk_ret_t clear_all_affected_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
clear_all_affected_plr	mods/player.cpp	/^			void player::clear_all_affected_plr(){$/;"	f	class:mods::player
clear_all_plr_flags	mods/js.cpp	/^		static duk_ret_t clear_all_plr_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
clear_captured_output	mods/player.cpp	/^	void player::clear_captured_output() {$/;"	f	class:mods::player
clear_free_list	mail.cpp	/^void clear_free_list(void) {$/;"	f
clear_object	db.cpp	/^void clear_object(struct obj_data *obj) {$/;"	f
clear_pluck_filter	mods/lmdb.cpp	/^	void _db_handle::clear_pluck_filter(){$/;"	f	class:mods::lmdb::_db_handle
close	mods/lmdb.cpp	/^	void _db_handle::close(){$/;"	f	class:mods::lmdb::_db_handle
close1	shop.h	/^	int	 close1, close2;	\/* When does the shop close?		*\/$/;"	m	struct:shop_data
close2	shop.h	/^	int	 close1, close2;	\/* When does the shop close?		*\/$/;"	m	struct:shop_data
close_socket	comm.cpp	/^void close_socket(mods::descriptor_data d) {$/;"	f
clr	screen.h	28;"	d
cmd	act.wizard.cpp	/^	const char *cmd;$/;"	m	struct:set_struct	file:
cmd	db.h	/^	std::vector<reset_com> cmd;   \/* command table for reset	          *\/$/;"	m	struct:zone_data
cmd	mods/js.cpp	/^		static duk_ret_t cmd(duk_context *ctx) {$/;"	f	namespace:mods::js
cmd_door	act.movement.cpp	/^	const char *cmd_door[] = {$/;"	v
cmd_emote	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_exec	mods/js.cpp	/^		static duk_ret_t cmd_exec(duk_context *ctx) {$/;"	f	namespace:mods::js
cmd_info	interpreter.cpp	/^cpp_extern const struct command_info cmd_info[] = {$/;"	v	typeref:struct:command_info
cmd_puke	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_say	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_slap	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_sort_info	act.informative.cpp	/^int *cmd_sort_info;$/;"	v
cmd_tell	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
color_eval	globals.cpp	/^		std::string color_eval(std::string final_buffer) {$/;"	f	namespace:mods::globals
color_eval	mods/util.cpp	/^		std::string color_eval(std::string final_buffer) {$/;"	f	namespace:mods::util
color_liquid	constants.cpp	/^const char *color_liquid[] = {$/;"	v
color_liquid	constants.hpp	/^const char *color_liquid[] =$/;"	v
column	mods/lmdb.hpp	/^		key_type_t column;$/;"	m	struct:mods::lmdb::_selector
combat_list	fight.cpp	/^struct char_data *combat_list = NULL;	\/* head of l-list of fighting chars *\/$/;"	v	typeref:struct:char_data
command	db.h	/^	char	command;   \/* current command                      *\/$/;"	m	struct:reset_com
command	interpreter.h	/^	const char *command;$/;"	m	struct:command_info
command_info	interpreter.h	/^struct command_info {$/;"	s
command_interpreter	globals.cpp	/^		bool command_interpreter(std::shared_ptr<mods::player> player,const std::string& argument) {$/;"	f	namespace:mods::globals
command_interpreter	interpreter.cpp	/^void command_interpreter(struct char_data *ch, char *argument) {$/;"	f
command_interpreter	interpreter.cpp	/^void command_interpreter(struct char_data *ch, const char *argument) {$/;"	f
command_pointer	interpreter.h	/^	void	(*command_pointer)$/;"	m	struct:command_info
commit	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::commit(){$/;"	f	class:mods::lmdb::_db_handle
commit	mods/pq.cpp	/^	void commit(transaction& txn) {$/;"	f	namespace:mods::pq
compare	mods/catch.hpp	/^		bool compare(T1 const& lhs, T2 const& rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, long long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, std::nullptr_t) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(int lhs, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(long lhs, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(long long lhs, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(std::nullptr_t, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(int lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(int lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(int lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned long long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned char lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned char lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned int lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned int lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, long long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare_spells	spec_procs.cpp	/^int compare_spells(const void *x, const void *y) {$/;"	f
complete_key	mods/quests.cpp	/^		std::string complete_key(struct char_data *ch,room_rnum room,int n_index) {$/;"	f	namespace:mods::quests
compositor	mods/jx.hpp	/^			compositor() : m_current_level(0) {$/;"	f	struct:mods::jx::compositor
compositor	mods/jx.hpp	/^	struct compositor {$/;"	s	namespace:mods::jx
compositor	mods/sql.hpp	/^			compositor(str_object table, T* txn_ptr) :$/;"	f	struct:mods::sql::compositor
compositor	mods/sql.hpp	/^	struct compositor {$/;"	s	namespace:mods::sql
compute_armor_class	fight.cpp	/^int compute_armor_class(struct char_data *ch) {$/;"	f
compute_thaco	fight.cpp	/^int compute_thaco(struct char_data *ch, struct char_data *victim) {$/;"	f
con	structs.h	/^	sbyte con;$/;"	m	struct:char_ability_data
con_app	constants.cpp	/^cpp_extern const struct con_app_type con_app[] = {$/;"	v	typeref:struct:con_app_type
con_app	constants.hpp	/^cpp_extern const struct con_app_type con_app[] = {$/;"	v	typeref:struct:con_app_type
con_app_type	structs.h	/^struct con_app_type {$/;"	s
concat	mods/string.cpp	/^	void string::concat(const std::string & str){$/;"	f	class:mods::string
concat	mods/string.cpp	/^	void string::concat(int ch){$/;"	f	class:mods::string
conditions	structs.h	/^	std::array<sbyte,conditions_max> conditions;         \/* Drunk, full, thirsty			*\/$/;"	m	struct:player_special_data_saved
conditions_max	structs.h	/^	constexpr static unsigned conditions_max = 3;$/;"	m	struct:player_special_data_saved
conf	mods/conf.cpp	/^namespace mods::conf {$/;"	n	class:mods	file:
conf	mods/conf.hpp	/^namespace mods::conf {$/;"	n	class:mods
conf	mods/util-conf.hpp	/^		namespace conf {$/;"	n	namespace:mods::util
config	config.cpp	/^namespace config {$/;"	n	file:
config	config.hpp	/^namespace config {$/;"	n
config	globals.cpp	/^namespace config {$/;"	n	file:
connected	structs.h	/^		int	connected;		\/* mode of 'connectedness'		*\/$/;"	m	struct:mods::descriptor_data
connected_types	constants.cpp	/^const char *connected_types[] = {$/;"	v
connected_types	constants.hpp	/^const char *connected_types[] = {$/;"	v
container_bits	constants.cpp	/^const char *container_bits[] = {$/;"	v
container_bits	constants.hpp	/^const char *container_bits[] = {$/;"	v
container_t	mods/behaviour_tree_impl.hpp	/^		typedef std::vector<behaviour_tree<argument_type>> container_t;$/;"	t	namespace:mods::behaviour_tree_impl
contains	structs.h	/^	struct obj_data *contains;     \/* Contains objects                 *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::obj_data
contents	structs.h	/^	struct obj_data *contents;   \/* List of items in room              *\/$/;"	m	struct:room_data	typeref:struct:room_data::obj_data
contextual_eval_string	mods/js.cpp	/^		void contextual_eval_string(char_data* player,duk_context* ctx,const std::string& str) {$/;"	f	namespace:mods::js
contextual_eval_string	mods/js.cpp	/^		void contextual_eval_string(mods::player* player,duk_context* ctx,const std::string& str) {$/;"	f	namespace:mods::js
convert	mods/catch.hpp	/^			static std::string convert(T const& _value) {$/;"	f	struct:Catch::Detail::StringMakerBase
convert	mods/catch.hpp	/^			static std::string convert(T const& v) {$/;"	f	struct:Catch::Detail::EnumStringMaker
convert	mods/catch.hpp	/^			static std::string convert(T const& v) {$/;"	f	struct:Catch::Detail::StringMakerBase
convert	mods/catch.hpp	/^			static std::string convert(T const&) {$/;"	f	struct:Catch::Detail::EnumStringMaker
convert	mods/catch.hpp	/^		static std::string convert(R C::* p) {$/;"	f	struct:Catch::StringMaker
convert	mods/catch.hpp	/^		static std::string convert(U* p) {$/;"	f	struct:Catch::StringMaker
core_dump	utils.h	49;"	d
core_dump_real	utils.cpp	/^void core_dump_real(const char *who, int line) {$/;"	f
cost	structs.h	/^	int	cost;		\/* Value when sold (gp.)            *\/$/;"	m	struct:obj_flag_data
cost_per_day	structs.h	/^	int	cost_per_day;	\/* Cost to keep pr. real day        *\/$/;"	m	struct:obj_flag_data
count	mods/pq.cpp	/^	int count(std::string_view query) {$/;"	f	namespace:mods::pq
count_alias_records	db.cpp	/^int count_alias_records(FILE *fl) {$/;"	f
count_hash_records	db.cpp	/^int count_hash_records(FILE *fl) {$/;"	f
count_pages	modify.cpp	/^int count_pages(char *str) {$/;"	f
cpp_extern	sysdep.h	400;"	d
cpp_extern	sysdep.h	402;"	d
crash_file_timeout	config.cpp	/^int crash_file_timeout = 10;$/;"	v
create	mods/behaviour_tree_node.hpp	/^		static child_node_t create(callback_t& c,node_type_t n_type){$/;"	f	struct:mods::behaviour_tree_node
create	mods/behaviour_tree_node.hpp	/^		static child_node_t create(callback_t& c,node_type_t n_type,children_t& ch){$/;"	f	struct:mods::behaviour_tree_node
create	mods/behaviour_tree_node.hpp	/^		static child_node_t create(node_type_t n_type){$/;"	f	struct:mods::behaviour_tree_node
create	mods/drone.cpp	/^	 struct char_data* drone::create(char_data* owner) {$/;"	f	class:mods::drone
create	mods/sql.hpp	/^			compositor<T>& create() {$/;"	f	struct:mods::sql::compositor
create_direction	mods/builder.cpp	/^	bool create_direction(room_rnum room_id,int direction,room_rnum to_room) {$/;"	f	namespace:mods::builder
create_entry	db.cpp	/^int create_entry(const char *name) {$/;"	f
create_leaf	mods/behaviour_tree_node.hpp	/^		static child_node_t create_leaf(callback_t c){$/;"	f	struct:mods::behaviour_tree_node
create_money	handler.cpp	/^struct obj_data *create_money(int amount) {$/;"	f
create_muted_player_target	mods/player-scaffolding.cpp	/^	std::shared_ptr<mods::player> player_scaffolding::create_muted_player_target() {$/;"	f	class:mods::player_scaffolding
create_obj	db.cpp	/^struct obj_data *create_obj(void) {$/;"	f
create_player	mods/player-scaffolding.cpp	/^	std::shared_ptr<mods::player> player_scaffolding::create_player() {$/;"	f	class:mods::player_scaffolding
create_selector	mods/behaviour_tree_node.hpp	/^		static child_node_t create_selector(const children_t& ch){$/;"	f	struct:mods::behaviour_tree_node
create_sequence	mods/behaviour_tree_node.hpp	/^		static child_node_t create_sequence(const children_t& ch){$/;"	f	struct:mods::behaviour_tree_node
credits	db.cpp	/^char *credits = NULL;		\/* game credits			 *\/$/;"	v
cron	mods/cron.hpp	/^			cron(uint64_t tick_resolution) : m_tres(tick_resolution) {$/;"	f	class:mods::cron
cron	mods/cron.hpp	/^	class cron {$/;"	c	namespace:mods
cryogenicist	objsave.cpp	/^SPECIAL(cryogenicist);$/;"	v
cryogenicist	spec_assign.cpp	/^SPECIAL(cryogenicist);$/;"	v
crypto	mods/crypto.hpp	/^	class crypto {$/;"	c	namespace:mods
ctypes	act.informative.cpp	/^const char *ctypes[] = {$/;"	v
current_key	mods/quests.cpp	/^		std::string current_key(struct char_data* ch) {$/;"	f	namespace:mods::quests
current_player	globals.cpp	/^		std::shared_ptr<mods::player> current_player;$/;"	m	namespace:mods::globals	file:
current_quest	mods/quests.cpp	/^		std::string current_quest(struct char_data *ch) {$/;"	f	namespace:mods::quests
current_room_number	structs.h	/^	room_vnum current_room_number;$/;"	m	struct:room_pavement_t
current_value	mods/quests.cpp	/^		std::string current_value(room_rnum room,int t_index) {$/;"	f	namespace:mods::quests
customer_string	shop.cpp	/^char *customer_string(int shop_nr, int detailed) {$/;"	f
d	globals.hpp	36;"	d
dam_message	fight.cpp	/^void dam_message(int dam, struct char_data *ch, struct char_data *victim,$/;"	f
damage	fight.cpp	/^int damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype) {$/;"	f
damnodice	structs.h	/^	byte damnodice;          \/* The number of damage dice's	       *\/$/;"	m	struct:mob_special_data
damroll	mods/player.hpp	/^			sbyte& damroll() {$/;"	f	class:mods::player
damroll	structs.h	/^	sbyte damroll;       \/* Any bonus or penalty to the damage roll *\/$/;"	m	struct:char_point_data
damsizedice	structs.h	/^	byte damsizedice;        \/* The size of the damage dice's           *\/$/;"	m	struct:mob_special_data
data	shop.h	/^	int data[100];$/;"	m	struct:stack_data
data_block_type	mail.h	/^typedef struct data_block_type_d data_block_type;$/;"	t	typeref:struct:data_block_type_d
data_block_type_d	mail.h	/^struct data_block_type_d {$/;"	s
date	db.h	/^	time_t date;$/;"	m	struct:ban_list_element
day	structs.h	/^	int hours, day, month;$/;"	m	struct:time_info_data
db	db.cpp	/^namespace db {$/;"	n	file:
db	db.h	/^namespace db {$/;"	n
db	globals.cpp	/^		std::unique_ptr<lmdb_db> db;$/;"	m	namespace:mods::globals	file:
db	mods/db.cpp	/^namespace mods::db {$/;"	n	class:mods	file:
db	mods/db.hpp	/^namespace mods::db{$/;"	n	class:mods
db	mods/schema.hpp	/^	static schema_list_t db = {$/;"	m	namespace:mods::schema
db_exists_by_id	mods/lmdb.cpp	/^bool db_exists_by_id(std::string table,std::string id){$/;"	f
db_exists_by_meta	mods/lmdb.cpp	/^bool db_exists_by_meta(std::string table,$/;"	f
db_get	mods/js.cpp	/^		static duk_ret_t db_get(duk_context *ctx) {$/;"	f	namespace:mods::js
db_get	mods/lmdb.cpp	/^std::string db_get(std::string table,std::string key){$/;"	f
db_get_all	mods/lmdb.cpp	/^mods::lmdb::result_container_t db_get_all(std::string table){$/;"	f
db_get_all_pluck	mods/lmdb.cpp	/^mods::lmdb::result_container_t db_get_all_pluck(std::string table,const std::vector<std::string>& pluck){$/;"	f
db_get_by_id	mods/lmdb.cpp	/^mods::lmdb::result_container_t db_get_by_id(std::string table,std::string id){$/;"	f
db_get_by_meta	mods/lmdb.cpp	/^mods::lmdb::result_container_t db_get_by_meta(std::string table,$/;"	f
db_geti	mods/js.cpp	/^		static duk_ret_t db_geti(duk_context *ctx) {$/;"	f	namespace:mods::js
db_has_been_booted	db.cpp	/^bool db_has_been_booted = false;$/;"	v
db_insert	mods/lmdb.cpp	/^tuple_status_t db_insert(std::string table,$/;"	f
db_key	mods/lmdb.cpp	/^std::string db_key(const std::vector<std::string> & parts){$/;"	f
db_meta_array_values	mods/schema.hpp	/^	static schema_list_t db_meta_array_values = {$/;"	m	namespace:mods::schema
db_meta_values	mods/schema.hpp	/^	static schema_list_t db_meta_values = {$/;"	m	namespace:mods::schema
db_put	mods/lmdb.cpp	/^void db_put(std::string table,std::string key,std::string value){$/;"	f
db_set	mods/js.cpp	/^		static duk_ret_t db_set(duk_context *ctx) {$/;"	f	namespace:mods::js
db_seti	mods/js.cpp	/^		static duk_ret_t db_seti(duk_context *ctx) {$/;"	f	namespace:mods::js
db_update	mods/lmdb.cpp	/^tuple_status_t db_update(std::string table,$/;"	f
dbg_print	mods/quests.cpp	2;"	d	file:
deactivate_account	mods/player.cpp	/^			void player::deactivate_account(){$/;"	f	class:mods::player
death_cry	fight.cpp	/^void death_cry(struct char_data *ch) {$/;"	f
debug	mods/db.hpp	7;"	d
debug	mods/db.hpp	9;"	d
decomposedExpression	mods/catch.hpp	/^		mutable DecomposedExpression const* decomposedExpression;$/;"	m	struct:Catch::AssertionResultData
default_pos	structs.h	/^	byte default_pos;        \/* Default position for NPC                *\/$/;"	m	struct:mob_special_data
defensive	structs.h	/^	sh_int defensive;$/;"	m	struct:dex_app_type
defer_queue	globals.cpp	/^		std::unique_ptr<mods::deferred> defer_queue;$/;"	m	namespace:mods::globals	file:
deferred	mods/deferred.hpp	/^			deferred(uint64_t tick_resolution) : m_tres(tick_resolution),$/;"	f	class:mods::deferred
deferred	mods/deferred.hpp	/^	class deferred {$/;"	c	namespace:mods
definition	mods/sql.hpp	/^			compositor<T>& definition(const std::vector<std::string>& members) {$/;"	f	struct:mods::sql::compositor
del	mods/lmdb.cpp	/^	int _db_handle::del(std::string key){$/;"	f	class:mods::lmdb::_db_handle
deleteAll	mods/catch.hpp	/^	inline void deleteAll(ContainerT& container) {$/;"	f	namespace:Catch
deleteAllValues	mods/catch.hpp	/^	inline void deleteAllValues(AssociativeContainerT& container) {$/;"	f	namespace:Catch
delete_aliases	alias.cpp	/^void delete_aliases(const char *charname) {$/;"	f
delete_doubledollar	interpreter.cpp	/^char *delete_doubledollar(char *string) {$/;"	f
delete_zone	mods/builder.cpp	/^	bool delete_zone(int id) {$/;"	f	namespace:mods::builder
delim	mods/meta_utils.cpp	/^	constexpr static const char* delim = "|";$/;"	m	namespace:mods::meta_utils	file:
deregister_player	comm.cpp	/^void deregister_player(std::shared_ptr<mods::player> & player_obj){$/;"	f
desc	mods/player.cpp	/^			descriptor_data& player::desc(){ $/;"	f	class:mods::player
desc	structs.h	/^	std::shared_ptr<mods::descriptor_data> desc;         \/* NULL for mobiles              *\/$/;"	m	struct:char_data
desc_num	structs.h	/^		int	desc_num;		\/* unique num assigned to desc		*\/$/;"	m	struct:mods::descriptor_data
description	mods/builder.cpp	/^	bool description(room_rnum room_id,std::string_view str_description) {$/;"	f	namespace:mods::builder
description	mods/catch.hpp	/^		const char* description;$/;"	m	struct:Catch::NameAndDesc
description	structs.h	/^	char	*description;		  \/* When in room                     *\/$/;"	m	struct:obj_data
description	structs.h	/^	char	*description;             \/* What to see                      *\/$/;"	m	struct:extra_descr_data
description	structs.h	/^	mods::string	description;           \/* Shown when entered                 *\/$/;"	m	struct:room_data
description	structs.h	/^	mods::string description;  \/* Extra descriptions                   *\/$/;"	m	struct:char_player_data
description	structs.h	/^	mods::string description;$/;"	m	struct:char_file_u
descriptor	structs.h	/^		socket_t	descriptor;	\/* file descriptor for socket		*\/$/;"	m	struct:mods::descriptor_data
descriptor_data	structs.h	/^		descriptor_data(){ clear(); }$/;"	f	struct:mods::descriptor_data
descriptor_data	structs.h	/^		descriptor_data(queue_behaviour_enum_t queue_behaviour){ $/;"	f	struct:mods::descriptor_data
descriptor_data	structs.h	/^	struct descriptor_data {$/;"	s	namespace:mods
destroy_db	db.cpp	/^void destroy_db(void) {$/;"	f
destroy_direction	mods/builder.cpp	/^	bool destroy_direction(room_rnum room_id,int direction) {$/;"	f	namespace:mods::builder
destroy_shops	shop.cpp	/^void destroy_shops(void) {$/;"	f
destroy_socket	comm.cpp	/^int64_t destroy_socket(socket_t & sock_fd){$/;"	f
dex	structs.h	/^	sbyte dex;$/;"	m	struct:char_ability_data
dex_app	constants.cpp	/^cpp_extern const struct dex_app_type dex_app[] = {$/;"	v	typeref:struct:dex_app_type
dex_app	constants.hpp	/^cpp_extern const struct dex_app_type dex_app[] = {$/;"	v	typeref:struct:dex_app_type
dex_app_skill	constants.cpp	/^cpp_extern const struct dex_skill_type dex_app_skill[] = {$/;"	v	typeref:struct:dex_skill_type
dex_app_skill	constants.hpp	/^cpp_extern const struct dex_skill_type dex_app_skill[] = {$/;"	v	typeref:struct:dex_skill_type
dex_app_type	structs.h	/^struct dex_app_type {$/;"	s
dex_skill_type	structs.h	/^struct dex_skill_type {$/;"	s
diag_char_to_char	act.informative.cpp	/^void diag_char_to_char(struct char_data *i, struct char_data *ch) {$/;"	f
dice	utils.cpp	/^int dice(int num, int size) {$/;"	f
die	fight.cpp	/^void die(struct char_data *ch) {$/;"	f
die	fight.cpp	/^void die(struct char_data* killer,struct char_data *victim) {$/;"	f
die_follower	utils.cpp	/^void die_follower(struct char_data *ch) {$/;"	f
die_msg	structs.h	/^	struct msg_type die_msg;	\/* messages when death			*\/$/;"	m	struct:message_type	typeref:struct:message_type::msg_type
dir	graph.cpp	/^	char dir;$/;"	m	struct:bfs_queue_struct	file:
dir_exists	mods/util.cpp	/^	bool dir_exists(const char* dir){$/;"	f	namespace:mods::util
dir_int	globals.cpp	/^		int dir_int(char dir) {$/;"	f	namespace:mods::globals
dir_option	mods/builder.cpp	/^	std::optional<std::string> dir_option(room_rnum room_id,int direction,std::optional<std::string_view> description,$/;"	f	namespace:mods::builder
dir_option	structs.h	/^	struct room_direction_data *dir_option[NUM_OF_DIRS]; \/* Directions *\/$/;"	m	struct:room_data	typeref:struct:room_data::room_direction_data
direction	mods/scan.hpp	/^			int direction;$/;"	m	struct:mods::scan::__anon5
direction	structs.h	/^	int direction;$/;"	m	struct:guild_info_type
directions	mods/scan.cpp	/^		int directions[] = { NORTH,EAST,SOUTH,WEST,UP,DOWN };$/;"	m	namespace:mods::scan	file:
dirs	constants.cpp	/^const char *dirs[] = {$/;"	v
dirs	constants.hpp	/^const char *dirs[] =$/;"	v
discrete_load	db.cpp	/^void discrete_load(FILE *fl, int mode, char *filename) {$/;"	f
disorient	structs.h	/^	short disorient;$/;"	m	struct:char_data
dispatch	mods/ai_state.cpp	/^	uint32_t ai_state::dispatch(struct char_data* ch) {$/;"	f	class:mods::ai_state
dispatch	mods/behaviour_tree_impl.cpp	/^	void dispatch(argument_type ch){$/;"	f	namespace:mods::behaviour_tree_impl
distance	mods/scan.hpp	/^			uint16_t distance;$/;"	m	struct:mods::scan::__anon4
distance	mods/scan.hpp	/^			uint16_t distance;$/;"	m	struct:mods::scan::__anon5
do_action	act.informative.cpp	/^ACMD(do_action);$/;"	v
do_action	act.social.cpp	/^ACMD(do_action);$/;"	v
do_action	interpreter.cpp	/^ACMD(do_action);$/;"	v
do_action	mobact.cpp	/^ACMD(do_action);$/;"	v
do_action	objsave.cpp	/^ACMD(do_action);$/;"	v
do_action	shop.cpp	/^ACMD(do_action);$/;"	v
do_action	spec_procs.cpp	/^ACMD(do_action);$/;"	v
do_advance	act.wizard.cpp	/^ACMD(do_advance);$/;"	v
do_advance	interpreter.cpp	/^ACMD(do_advance);$/;"	v
do_alias	interpreter.cpp	/^ACMD(do_alias);$/;"	v
do_ammo	interpreter.cpp	/^ACMD(do_ammo);$/;"	v
do_assist	act.offensive.cpp	/^ACMD(do_assist);$/;"	v
do_assist	interpreter.cpp	/^ACMD(do_assist);$/;"	v
do_at	act.wizard.cpp	/^ACMD(do_at);$/;"	v
do_at	interpreter.cpp	/^ACMD(do_at);$/;"	v
do_auto_exits	act.informative.cpp	/^void do_auto_exits(struct char_data *ch) {$/;"	f
do_backstab	act.offensive.cpp	/^ACMD(do_backstab);$/;"	v
do_backstab	interpreter.cpp	/^ACMD(do_backstab);$/;"	v
do_ban	ban.cpp	/^ACMD(do_ban);$/;"	v
do_ban	interpreter.cpp	/^ACMD(do_ban);$/;"	v
do_bash	act.offensive.cpp	/^ACMD(do_bash);$/;"	v
do_bash	interpreter.cpp	/^ACMD(do_bash);$/;"	v
do_breach	act.offensive.cpp	/^ACMD(do_breach);$/;"	v
do_breach	interpreter.cpp	/^ACMD(do_breach);$/;"	v
do_cast	interpreter.cpp	/^ACMD(do_cast);$/;"	v
do_cast	spell_parser.cpp	/^ACMD(do_cast);$/;"	v
do_chanmgr	interpreter.cpp	/^ACMD(do_chanmgr);$/;"	v
do_color	act.informative.cpp	/^ACMD(do_color);$/;"	v
do_color	interpreter.cpp	/^ACMD(do_color);$/;"	v
do_commands	act.informative.cpp	/^ACMD(do_commands);$/;"	v
do_commands	interpreter.cpp	/^ACMD(do_commands);$/;"	v
do_consider	act.informative.cpp	/^ACMD(do_consider);$/;"	v
do_consider	interpreter.cpp	/^ACMD(do_consider);$/;"	v
do_credits	interpreter.cpp	/^ACMD(do_credits);$/;"	v
do_date	act.wizard.cpp	/^ACMD(do_date);$/;"	v
do_date	interpreter.cpp	/^ACMD(do_date);$/;"	v
do_dc	act.wizard.cpp	/^ACMD(do_dc);$/;"	v
do_dc	interpreter.cpp	/^ACMD(do_dc);$/;"	v
do_diagnose	act.informative.cpp	/^ACMD(do_diagnose);$/;"	v
do_diagnose	interpreter.cpp	/^ACMD(do_diagnose);$/;"	v
do_display	act.other.cpp	/^ACMD(do_display);$/;"	v
do_display	interpreter.cpp	/^ACMD(do_display);$/;"	v
do_doorcmd	act.movement.cpp	/^	void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd) {$/;"	f
do_drink	act.item.cpp	/^ACMD(do_drink);$/;"	v
do_drink	interpreter.cpp	/^ACMD(do_drink);$/;"	v
do_drone	act.informative.cpp	/^ACMD(do_drone);	\/*!mods*\/$/;"	v
do_drone	interpreter.cpp	/^ACMD(do_drone);$/;"	v
do_drop	act.item.cpp	/^ACMD(do_drop);$/;"	v
do_drop	interpreter.cpp	/^ACMD(do_drop);$/;"	v
do_drop	spec_procs.cpp	/^ACMD(do_drop);$/;"	v
do_eat	act.item.cpp	/^ACMD(do_eat);$/;"	v
do_eat	interpreter.cpp	/^ACMD(do_eat);$/;"	v
do_echo	act.wizard.cpp	/^ACMD(do_echo);$/;"	v
do_echo	interpreter.cpp	/^ACMD(do_echo);$/;"	v
do_echo	shop.cpp	/^ACMD(do_echo);$/;"	v
do_enter	act.movement.cpp	/^ACMD(do_enter);$/;"	v
do_enter	interpreter.cpp	/^ACMD(do_enter);$/;"	v
do_equipment	act.informative.cpp	/^ACMD(do_equipment);$/;"	v
do_equipment	interpreter.cpp	/^ACMD(do_equipment);$/;"	v
do_examine	act.informative.cpp	/^ACMD(do_examine);$/;"	v
do_examine	interpreter.cpp	/^ACMD(do_examine);$/;"	v
do_exit	interpreter.cpp	/^ACMD(do_exit);$/;"	v
do_exits	act.informative.cpp	/^ACMD(do_exits);$/;"	v
do_exits	interpreter.cpp	/^ACMD(do_exits);$/;"	v
do_flee	act.offensive.cpp	/^ACMD(do_flee);$/;"	v
do_flee	fight.cpp	/^ACMD(do_flee);$/;"	v
do_flee	interpreter.cpp	/^ACMD(do_flee);$/;"	v
do_follow	act.movement.cpp	/^ACMD(do_follow);$/;"	v
do_follow	castle.cpp	/^ACMD(do_follow);$/;"	v
do_follow	interpreter.cpp	/^ACMD(do_follow);$/;"	v
do_force	act.wizard.cpp	/^ACMD(do_force);$/;"	v
do_force	interpreter.cpp	/^ACMD(do_force);$/;"	v
do_gecho	act.wizard.cpp	/^ACMD(do_gecho);$/;"	v
do_gecho	interpreter.cpp	/^ACMD(do_gecho);$/;"	v
do_gen_comm	act.comm.cpp	/^ACMD(do_gen_comm);$/;"	v
do_gen_comm	act.other.cpp	/^ACMD(do_gen_comm);$/;"	v
do_gen_comm	interpreter.cpp	/^ACMD(do_gen_comm);$/;"	v
do_gen_door	act.movement.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_door	castle.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_door	interpreter.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_door	spec_procs.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_ps	act.informative.cpp	/^ACMD(do_gen_ps);$/;"	v
do_gen_ps	interpreter.cpp	/^ACMD(do_gen_ps);$/;"	v
do_gen_tog	act.other.cpp	/^ACMD(do_gen_tog);$/;"	v
do_gen_tog	interpreter.cpp	/^ACMD(do_gen_tog);$/;"	v
do_gen_write	act.other.cpp	/^ACMD(do_gen_write);$/;"	v
do_gen_write	interpreter.cpp	/^ACMD(do_gen_write);$/;"	v
do_get	act.item.cpp	/^ACMD(do_get);$/;"	v
do_get	interpreter.cpp	/^ACMD(do_get);$/;"	v
do_get	mobact.cpp	/^ACMD(do_get);$/;"	v
do_give	act.item.cpp	/^ACMD(do_give);$/;"	v
do_give	interpreter.cpp	/^ACMD(do_give);$/;"	v
do_givemegold	act.informative.cpp	/^ACMD(do_givemegold); \/*!mods*\/$/;"	v
do_givemegold	interpreter.cpp	/^ACMD(do_givemegold);$/;"	v
do_gold	act.informative.cpp	/^ACMD(do_gold);$/;"	v
do_gold	interpreter.cpp	/^ACMD(do_gold);$/;"	v
do_goto	act.wizard.cpp	/^ACMD(do_goto);$/;"	v
do_goto	interpreter.cpp	/^ACMD(do_goto);$/;"	v
do_grab	act.item.cpp	/^ACMD(do_grab);$/;"	v
do_grab	interpreter.cpp	/^ACMD(do_grab);$/;"	v
do_group	act.other.cpp	/^ACMD(do_group);$/;"	v
do_group	interpreter.cpp	/^ACMD(do_group);$/;"	v
do_gsay	act.comm.cpp	/^ACMD(do_gsay);$/;"	v
do_gsay	interpreter.cpp	/^ACMD(do_gsay);$/;"	v
do_hcontrol	house.cpp	/^ACMD(do_hcontrol);$/;"	v
do_hcontrol	interpreter.cpp	/^ACMD(do_hcontrol);$/;"	v
do_heal	interpreter.cpp	/^ACMD(do_heal);$/;"	v
do_help	act.informative.cpp	/^ACMD(do_help);$/;"	v
do_help	interpreter.cpp	/^ACMD(do_help);$/;"	v
do_hide	act.other.cpp	/^ACMD(do_hide);$/;"	v
do_hide	interpreter.cpp	/^ACMD(do_hide);$/;"	v
do_hit	act.offensive.cpp	/^ACMD(do_hit);$/;"	v
do_hit	interpreter.cpp	/^ACMD(do_hit);$/;"	v
do_house	house.cpp	/^ACMD(do_house);$/;"	v
do_house	interpreter.cpp	/^ACMD(do_house);$/;"	v
do_idle	interpreter.cpp	/^ACMD(do_idle);$/;"	v
do_insult	act.informative.cpp	/^ACMD(do_insult);$/;"	v
do_insult	act.social.cpp	/^ACMD(do_insult);$/;"	v
do_insult	interpreter.cpp	/^ACMD(do_insult);$/;"	v
do_inventory	act.informative.cpp	/^ACMD(do_inventory);$/;"	v
do_inventory	interpreter.cpp	/^ACMD(do_inventory);$/;"	v
do_invis	act.wizard.cpp	/^ACMD(do_invis);$/;"	v
do_invis	interpreter.cpp	/^ACMD(do_invis);$/;"	v
do_js	act.informative.cpp	/^ACMD(do_js);	\/*!mods*\/$/;"	v
do_js	interpreter.cpp	/^ACMD(do_js);$/;"	v
do_jstest	interpreter.cpp	/^ACMD(do_jstest);$/;"	v
do_kick	act.offensive.cpp	/^ACMD(do_kick);$/;"	v
do_kick	interpreter.cpp	/^ACMD(do_kick);$/;"	v
do_kill	act.offensive.cpp	/^ACMD(do_kill);$/;"	v
do_kill	interpreter.cpp	/^ACMD(do_kill);$/;"	v
do_last	act.wizard.cpp	/^ACMD(do_last);$/;"	v
do_last	interpreter.cpp	/^ACMD(do_last);$/;"	v
do_leave	act.movement.cpp	/^ACMD(do_leave);$/;"	v
do_leave	interpreter.cpp	/^ACMD(do_leave);$/;"	v
do_levels	act.informative.cpp	/^ACMD(do_levels);$/;"	v
do_levels	interpreter.cpp	/^ACMD(do_levels);$/;"	v
do_load	act.wizard.cpp	/^ACMD(do_load);$/;"	v
do_load	interpreter.cpp	/^ACMD(do_load);$/;"	v
do_look	act.informative.cpp	/^ACMD(do_look);$/;"	v
do_look	interpreter.cpp	/^ACMD(do_look);$/;"	v
do_meta_easy	mods/meta_utils.cpp	/^	int do_meta_easy(  const std::string & table, mutable_map_t* values,$/;"	f	namespace:mods::meta_utils
do_meta_easy_by_pk	mods/meta_utils.cpp	/^	int do_meta_easy_by_pk( const std::string & table, mutable_map_t* values){$/;"	f	namespace:mods::meta_utils
do_move	interpreter.h	/^ACMD(do_move);$/;"	v
do_newjs	interpreter.cpp	/^ACMD(do_newjs);$/;"	v
do_not_buy	shop.h	/^	char	*do_not_buy;		\/* If keeper dosn't buy such things	*\/$/;"	m	struct:shop_data
do_not_here	act.other.cpp	/^ACMD(do_not_here);$/;"	v
do_not_here	interpreter.cpp	/^ACMD(do_not_here);$/;"	v
do_npc_rescue	castle.cpp	/^int do_npc_rescue(struct char_data *ch_hero, struct char_data *ch_victim) {$/;"	f
do_olc	interpreter.cpp	/^ACMD(do_olc);$/;"	v
do_olc	olc.cpp	/^ACMD(do_olc);$/;"	v
do_order	act.offensive.cpp	/^ACMD(do_order);$/;"	v
do_order	interpreter.cpp	/^ACMD(do_order);$/;"	v
do_page	act.comm.cpp	/^ACMD(do_page);$/;"	v
do_poofset	act.wizard.cpp	/^ACMD(do_poofset);$/;"	v
do_poofset	interpreter.cpp	/^ACMD(do_poofset);$/;"	v
do_pour	act.item.cpp	/^ACMD(do_pour);$/;"	v
do_pour	interpreter.cpp	/^ACMD(do_pour);$/;"	v
do_practice	act.other.cpp	/^ACMD(do_practice);$/;"	v
do_practice	interpreter.cpp	/^ACMD(do_practice);$/;"	v
do_pref	interpreter.cpp	/^ACMD(do_pref);$/;"	v
do_pref	mods/prefs.hpp	/^ACMD(do_pref);$/;"	v
do_preferences	act.informative.cpp	/^ACMD(do_preferences); \/*!mods *\/$/;"	v
do_purge	act.wizard.cpp	/^ACMD(do_purge);$/;"	v
do_purge	interpreter.cpp	/^ACMD(do_purge);$/;"	v
do_put	act.item.cpp	/^ACMD(do_put);$/;"	v
do_put	interpreter.cpp	/^ACMD(do_put);$/;"	v
do_qcomm	act.comm.cpp	/^ACMD(do_qcomm);$/;"	v
do_qcomm	interpreter.cpp	/^ACMD(do_qcomm);$/;"	v
do_quest	act.informative.cpp	/^ACMD(do_quest);	\/*!mods*\/$/;"	v
do_quest	interpreter.cpp	/^ACMD(do_quest);$/;"	v
do_quit	act.other.cpp	/^ACMD(do_quit);$/;"	v
do_quit	interpreter.cpp	/^ACMD(do_quit);$/;"	v
do_rbuild	mods/builder.hpp	/^ACMD(do_rbuild);$/;"	v
do_reboot	db.cpp	/^ACMD(do_reboot);$/;"	v
do_reboot	interpreter.cpp	/^ACMD(do_reboot);$/;"	v
do_recall	act.informative.cpp	/^ACMD(do_recall);	\/*!mods*\/$/;"	v
do_recall	interpreter.cpp	/^ACMD(do_recall);$/;"	v
do_reload	interpreter.cpp	/^ACMD(do_reload);$/;"	v
do_remove	act.item.cpp	/^ACMD(do_remove);$/;"	v
do_remove	interpreter.cpp	/^ACMD(do_remove);$/;"	v
do_reply	act.comm.cpp	/^ACMD(do_reply);$/;"	v
do_reply	interpreter.cpp	/^ACMD(do_reply);$/;"	v
do_report	act.other.cpp	/^ACMD(do_report);$/;"	v
do_report	interpreter.cpp	/^ACMD(do_report);$/;"	v
do_rescue	act.offensive.cpp	/^ACMD(do_rescue);$/;"	v
do_rescue	interpreter.cpp	/^ACMD(do_rescue);$/;"	v
do_rest	act.movement.cpp	/^ACMD(do_rest);$/;"	v
do_rest	interpreter.cpp	/^ACMD(do_rest);$/;"	v
do_restore	act.wizard.cpp	/^ACMD(do_restore);$/;"	v
do_restore	interpreter.cpp	/^ACMD(do_restore);$/;"	v
do_return	act.wizard.cpp	/^ACMD(do_return);$/;"	v
do_return	handler.cpp	/^ACMD(do_return);$/;"	v
do_return	interpreter.cpp	/^ACMD(do_return);$/;"	v
do_rnum	act.offensive.cpp	/^ACMD(do_rnum);$/;"	v
do_rnum	interpreter.cpp	/^ACMD(do_rnum);$/;"	v
do_rnumlist	interpreter.cpp	/^ACMD(do_rnumlist);$/;"	v
do_rnumlist	mods/immortal.hpp	/^ACMD(do_rnumlist);$/;"	v
do_rnumtele	interpreter.cpp	/^ACMD(do_rnumtele);$/;"	v
do_rnumtele	mods/immortal.hpp	/^ACMD(do_rnumtele);$/;"	v
do_save	act.other.cpp	/^ACMD(do_save);$/;"	v
do_save	interpreter.cpp	/^ACMD(do_save);$/;"	v
do_say	act.comm.cpp	/^ACMD(do_say);$/;"	v
do_say	graph.cpp	/^ACMD(do_say);$/;"	v
do_say	interpreter.cpp	/^ACMD(do_say);$/;"	v
do_say	mods/ai_state.cpp	/^EXTERN_ACT(do_say);$/;"	v
do_say	shop.cpp	/^ACMD(do_say);$/;"	v
do_say	spec_procs.cpp	/^ACMD(do_say);$/;"	v
do_scan	act.offensive.cpp	/^ACMD(do_scan);$/;"	v
do_scan	interpreter.cpp	/^ACMD(do_scan);$/;"	v
do_score	act.informative.cpp	/^ACMD(do_score);$/;"	v
do_score	interpreter.cpp	/^ACMD(do_score);$/;"	v
do_send	act.wizard.cpp	/^ACMD(do_send);$/;"	v
do_send	interpreter.cpp	/^ACMD(do_send);$/;"	v
do_set	act.wizard.cpp	/^ACMD(do_set);$/;"	v
do_set	interpreter.cpp	/^ACMD(do_set);$/;"	v
do_show	act.wizard.cpp	/^ACMD(do_show);$/;"	v
do_show	interpreter.cpp	/^ACMD(do_show);$/;"	v
do_shutdown	act.wizard.cpp	/^ACMD(do_shutdown);$/;"	v
do_shutdown	interpreter.cpp	/^ACMD(do_shutdown);$/;"	v
do_simple_move	act.movement.cpp	/^int do_simple_move(struct char_data *ch, int dir, int need_specials_check) {$/;"	f
do_sit	act.movement.cpp	/^ACMD(do_sit);$/;"	v
do_sit	interpreter.cpp	/^ACMD(do_sit);$/;"	v
do_skillset	interpreter.cpp	/^ACMD(do_skillset);$/;"	v
do_skillset	modify.cpp	/^ACMD(do_skillset);$/;"	v
do_sleep	act.movement.cpp	/^ACMD(do_sleep);$/;"	v
do_sleep	interpreter.cpp	/^ACMD(do_sleep);$/;"	v
do_sneak	act.other.cpp	/^ACMD(do_sneak);$/;"	v
do_sneak	interpreter.cpp	/^ACMD(do_sneak);$/;"	v
do_snipe	interpreter.cpp	/^ACMD(do_snipe);$/;"	v
do_snoop	act.wizard.cpp	/^ACMD(do_snoop);$/;"	v
do_snoop	interpreter.cpp	/^ACMD(do_snoop);$/;"	v
do_spec_comm	act.comm.cpp	/^ACMD(do_spec_comm);$/;"	v
do_spec_comm	interpreter.cpp	/^ACMD(do_spec_comm);$/;"	v
do_split	act.other.cpp	/^ACMD(do_split);$/;"	v
do_split	interpreter.cpp	/^ACMD(do_split);$/;"	v
do_stand	act.movement.cpp	/^ACMD(do_stand);$/;"	v
do_stand	interpreter.cpp	/^ACMD(do_stand);$/;"	v
do_start	class.cpp	/^void do_start(struct char_data *ch) {$/;"	f
do_stat	act.wizard.cpp	/^ACMD(do_stat);$/;"	v
do_stat	interpreter.cpp	/^ACMD(do_stat);$/;"	v
do_stat_character	act.wizard.cpp	/^void do_stat_character(struct char_data *ch, struct char_data *k) {$/;"	f
do_stat_object	act.wizard.cpp	/^void do_stat_object(struct char_data *ch, struct obj_data *j) {$/;"	f
do_stat_room	act.wizard.cpp	/^void do_stat_room(struct char_data *ch) {$/;"	f
do_steal	act.other.cpp	/^ACMD(do_steal);$/;"	v
do_steal	interpreter.cpp	/^ACMD(do_steal);$/;"	v
do_switch	act.wizard.cpp	/^ACMD(do_switch);$/;"	v
do_switch	interpreter.cpp	/^ACMD(do_switch);$/;"	v
do_syslog	act.wizard.cpp	/^ACMD(do_syslog);$/;"	v
do_syslog	interpreter.cpp	/^ACMD(do_syslog);$/;"	v
do_teleport	act.wizard.cpp	/^ACMD(do_teleport);$/;"	v
do_teleport	interpreter.cpp	/^ACMD(do_teleport);$/;"	v
do_tell	act.comm.cpp	/^ACMD(do_tell);$/;"	v
do_tell	interpreter.cpp	/^ACMD(do_tell);$/;"	v
do_tell	mods/ai_state.cpp	/^EXTERN_ACT(do_tell);$/;"	v
do_tell	objsave.cpp	/^ACMD(do_tell);$/;"	v
do_tell	shop.cpp	/^ACMD(do_tell);$/;"	v
do_throw	interpreter.cpp	/^ACMD(do_throw);$/;"	v
do_time	act.informative.cpp	/^ACMD(do_time);$/;"	v
do_time	interpreter.cpp	/^ACMD(do_time);$/;"	v
do_title	act.other.cpp	/^ACMD(do_title);$/;"	v
do_title	interpreter.cpp	/^ACMD(do_title);$/;"	v
do_toggle	act.informative.cpp	/^ACMD(do_toggle);$/;"	v
do_toggle	interpreter.cpp	/^ACMD(do_toggle);$/;"	v
do_track	graph.cpp	/^ACMD(do_track);$/;"	v
do_track	interpreter.cpp	/^ACMD(do_track);$/;"	v
do_trans	act.wizard.cpp	/^ACMD(do_trans);$/;"	v
do_trans	interpreter.cpp	/^ACMD(do_trans);$/;"	v
do_unban	ban.cpp	/^ACMD(do_unban);$/;"	v
do_unban	interpreter.cpp	/^ACMD(do_unban);$/;"	v
do_ungroup	act.other.cpp	/^ACMD(do_ungroup);$/;"	v
do_ungroup	interpreter.cpp	/^ACMD(do_ungroup);$/;"	v
do_use	act.other.cpp	/^ACMD(do_use);$/;"	v
do_use	interpreter.cpp	/^ACMD(do_use);$/;"	v
do_users	act.informative.cpp	/^ACMD(do_users);$/;"	v
do_users	interpreter.cpp	/^ACMD(do_users);$/;"	v
do_visible	act.other.cpp	/^ACMD(do_visible);$/;"	v
do_visible	interpreter.cpp	/^ACMD(do_visible);$/;"	v
do_vnum	act.wizard.cpp	/^ACMD(do_vnum);$/;"	v
do_vnum	interpreter.cpp	/^ACMD(do_vnum);$/;"	v
do_vstat	act.wizard.cpp	/^ACMD(do_vstat);$/;"	v
do_vstat	interpreter.cpp	/^ACMD(do_vstat);$/;"	v
do_wake	act.movement.cpp	/^ACMD(do_wake);$/;"	v
do_wake	interpreter.cpp	/^ACMD(do_wake);$/;"	v
do_wear	act.item.cpp	/^ACMD(do_wear);$/;"	v
do_wear	interpreter.cpp	/^ACMD(do_wear);$/;"	v
do_weather	act.informative.cpp	/^ACMD(do_weather);$/;"	v
do_weather	interpreter.cpp	/^ACMD(do_weather);$/;"	v
do_where	act.informative.cpp	/^ACMD(do_where);$/;"	v
do_where	interpreter.cpp	/^ACMD(do_where);$/;"	v
do_who	act.informative.cpp	/^ACMD(do_who);$/;"	v
do_who	interpreter.cpp	/^ACMD(do_who);$/;"	v
do_wield	act.item.cpp	/^ACMD(do_wield);$/;"	v
do_wield	interpreter.cpp	/^ACMD(do_wield);$/;"	v
do_wimpy	act.other.cpp	/^ACMD(do_wimpy);$/;"	v
do_wimpy	interpreter.cpp	/^ACMD(do_wimpy);$/;"	v
do_wizlock	act.wizard.cpp	/^ACMD(do_wizlock);$/;"	v
do_wizlock	interpreter.cpp	/^ACMD(do_wizlock);$/;"	v
do_wiznet	act.wizard.cpp	/^ACMD(do_wiznet);$/;"	v
do_wiznet	interpreter.cpp	/^ACMD(do_wiznet);$/;"	v
do_wizutil	act.wizard.cpp	/^ACMD(do_wizutil);$/;"	v
do_wizutil	interpreter.cpp	/^ACMD(do_wizutil);$/;"	v
do_write	act.comm.cpp	/^ACMD(do_write);$/;"	v
do_write	interpreter.cpp	/^ACMD(do_write);$/;"	v
do_zbuild	mods/builder.hpp	/^ACMD(do_zbuild);$/;"	v
do_zreset	act.wizard.cpp	/^ACMD(do_zreset);$/;"	v
do_zreset	interpreter.cpp	/^ACMD(do_zreset);$/;"	v
donation_room_1	config.cpp	/^room_vnum donation_room_1 = 3063;$/;"	v
donation_room_2	config.cpp	/^room_vnum donation_room_2 = NOWHERE;	\/* unused - room for expansion *\/$/;"	v
donation_room_3	config.cpp	/^room_vnum donation_room_3 = NOWHERE;	\/* unused - room for expansion *\/$/;"	v
done	mods/player.cpp	/^			void player::done() {$/;"	f	class:mods::player
dopr	bsd-snprintf.cpp	/^dopr(char *buffer, size_t maxlen, const char *format, va_list args) {$/;"	f	file:
dopr_outch	bsd-snprintf.cpp	/^dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c) {$/;"	f	file:
drink_aff	constants.cpp	/^int drink_aff[][3] = {$/;"	v
drink_aff	constants.hpp	/^int drink_aff[][3] = {$/;"	v
drinknames	constants.cpp	/^const char *drinknames[] = {$/;"	v
drinknames	constants.hpp	/^const char *drinknames[] =$/;"	v
drinks	constants.cpp	/^const char *drinks[] = {$/;"	v
drinks	constants.hpp	/^const char *drinks[] =$/;"	v
drone	mods/drone.cpp	/^	drone::drone(char_data* ch) : m_char_data(ch) { };$/;"	f	class:mods::drone
drone	mods/drone.hpp	/^	class drone {$/;"	c	namespace:mods
drone	structs.h	/^	bool drone;$/;"	m	struct:char_data
drone_owner	structs.h	/^	uuid_t drone_owner;$/;"	m	struct:char_data
drone_simulate	structs.h	/^	bool drone_simulate;$/;"	m	struct:char_data
drone_uuid	structs.h	/^	uuid_t drone_uuid;$/;"	m	struct:char_data
dts_are_dumps	config.cpp	/^int dts_are_dumps = YES;$/;"	v
duktape_context	globals.cpp	/^		duk_context* duktape_context;$/;"	m	namespace:mods::globals	file:
dummy_mob	db.cpp	/^struct player_special_data dummy_mob;	\/* dummy spec area for mobs	*\/$/;"	v	typeref:struct:player_special_data
dump	mods/util-map.hpp	/^			static inline void dump(std::map<TKey,TVal> m){$/;"	f	namespace:mods::util::maps
dump	spec_assign.cpp	/^SPECIAL(dump);$/;"	v
dump	spec_procs.cpp	/^SPECIAL(dump);$/;"	v
dump_status	mods/lmdb.cpp	/^	void _db_handle::dump_status() const {$/;"	f	class:mods::lmdb::_db_handle
duplicate	db.h	/^	int duplicate;$/;"	m	struct:help_index_element
duration	structs.h	/^	sh_int duration;      \/* For how long its effects will last      *\/$/;"	m	struct:affected_type
dynamic_get	mods/prefs.cpp	/^	std::string prefs::dynamic_get(const std::string& key,const std::string& section,struct char_data* ch) {$/;"	f	class:mods::prefs
dynamic_namify	mods/prefs.cpp	/^	std::string prefs::dynamic_namify(const std::string& key,const std::string& section,struct char_data* c) {$/;"	f	class:mods::prefs
dynamic_set	mods/prefs.cpp	/^	void prefs::dynamic_set(const std::string& key,const std::string& value,const std::string& section,struct char_data* ch) {$/;"	f	class:mods::prefs
e_commit	mods/db.hpp	/^	constexpr static int_status_t e_commit = -2;$/;"	m	namespace:mods::lmdb::error
e_get	mods/db.hpp	/^	constexpr static int_status_t e_get = -3;$/;"	m	namespace:mods::lmdb::error
e_put	mods/db.hpp	/^	constexpr static int_status_t e_put = -1;$/;"	m	namespace:mods::lmdb::error
echo_off	comm.cpp	/^void echo_off(mods::descriptor_data &d) {$/;"	f
echo_on	comm.cpp	/^void echo_on(mods::descriptor_data &d) {$/;"	f
emergency_unban	comm.cpp	/^byte emergency_unban;		\/* signal: SIGUSR2 *\/$/;"	v
encrypt	mods/crypto.hpp	/^			static int encrypt(const std::string & data,std::vector<char>& outbuf){$/;"	f	class:mods::crypto
encrypt_names	telnet.h	/^char *encrypt_names[] = {$/;"	v
enctype_names	telnet.h	/^char *enctype_names[] = {$/;"	v
end_read_list	shop.cpp	/^int end_read_list(struct shop_buy_data *list, int len, int error) {$/;"	f
entry	db.h	/^	char *entry;$/;"	m	struct:help_index_element
epoll_ev	comm.cpp	/^epoll_event epoll_ev;$/;"	v
epoll_fd	comm.cpp	/^int epoll_fd = -1;$/;"	v
equip_char	handler.cpp	/^void equip_char(struct char_data *ch, struct obj_data *obj, int pos) {$/;"	f
equipment	structs.h	/^	obj_data *equipment[NUM_WEARS];\/* Equipment array               *\/$/;"	m	struct:char_data
equipment_types	constants.cpp	/^const char *equipment_types[] = {$/;"	v
equipment_types	constants.hpp	/^const char *equipment_types[] = {$/;"	v
err	mods/util.cpp	/^namespace mods::util::err {$/;"	n	class:mods::util	file:
err	mods/util.hpp	/^namespace mods::util::err {$/;"	n	class:mods::util
error	mods/db.hpp	/^namespace mods::lmdb::error { $/;"	n	class:mods::lmdb
eval_string	mods/js.cpp	/^		void eval_string(duk_context* ctx,const std::string& str) {$/;"	f	namespace:mods::js
eval_string	mods/js.cpp	/^		void eval_string(std::string_view str) {$/;"	f	namespace:mods::js
evaluate	mods/catch.hpp	/^			static bool evaluate(T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator
evaluate_expression	shop.cpp	/^int evaluate_expression(struct obj_data *obj, char *expr) {$/;"	f
evaluate_operation	shop.cpp	/^void evaluate_operation(struct stack_data *ops, struct stack_data *vals) {$/;"	f
event	mods/ai_state.cpp	/^	uint32_t ai_state::event(struct char_data* ch,event_type_t ev) {$/;"	f	class:mods::ai_state
event_type_t	mods/ai_state.hpp	/^			enum event_type_t {$/;"	g	class:mods::ai_state
ex_description	structs.h	/^	struct extra_descr_data *ex_description; \/* extra descriptions     *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::extra_descr_data
ex_description	structs.h	/^	struct extra_descr_data *ex_description; \/* for examine\/look       *\/$/;"	m	struct:room_data	typeref:struct:room_data::extra_descr_data
exec	mods/lmdb.hpp	/^	inline transaction_ptr exec(std::string table){$/;"	f	namespace:mods::lmdb
exec	mods/pq.cpp	/^	pqxx::result exec(transaction& txn,std::string_view query) {$/;"	f	namespace:mods::pq
executing_js	mods/player.cpp	/^	void player::executing_js(bool true_false) {$/;"	f	class:mods::player
exists	mods/util.hpp	/^	bool exists(const ContainerType * container_ptr,$/;"	f	namespace:mods::util
exit_bits	constants.cpp	/^const char *exit_bits[] = {$/;"	v
exit_bits	constants.hpp	/^const char *exit_bits[] = {$/;"	v
exit_info	structs.h	/^	int exit_info;	\/* Exit info			*\/$/;"	m	struct:room_direction_data
exit_num	house.h	/^	sh_int exit_num;		\/* direction of house's exit	*\/$/;"	m	struct:house_control_rec
exits	mods/player.cpp	/^	void player::exits() {$/;"	f	class:mods::player
exp	mods/player.hpp	/^			int& exp() {$/;"	f	class:mods::player
exp	structs.h	/^	int	exp;            \/* The experience of the player            *\/$/;"	m	struct:char_point_data
extra_bits	constants.cpp	/^const char *extra_bits[] = {$/;"	v
extra_bits	constants.hpp	/^const char *extra_bits[] = {$/;"	v
extra_bits_count	constants.cpp	/^        extra_bits_count = sizeof(extra_bits) \/ sizeof(extra_bits[0]) - 1,$/;"	v
extra_bits_count	constants.hpp	/^	extra_bits_count = sizeof(extra_bits) \/ sizeof(extra_bits[0]) - 1,$/;"	v
extra_descr_data	structs.h	/^struct extra_descr_data {$/;"	s
extra_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,17> extra_flags = { {$/;"	m	namespace:mods::builder	file:
extra_flags	structs.h	/^	int \/*bitvector_t*\/	extra_flags;	\/* If it hums, glows, etc.	    *\/$/;"	m	struct:obj_flag_data
extra_flags	structs.h	/^	int \/*bitvector_t*\/	extra_flags;$/;"	m	struct:obj_file_elem
extract_char	handler.cpp	/^void extract_char(struct char_data *ch) {$/;"	f
extract_char_final	handler.cpp	/^void extract_char_final(struct char_data *ch) {$/;"	f
extract_obj	handler.cpp	/^void extract_obj(struct obj_data *obj) {$/;"	f
extract_pending_chars	handler.cpp	/^void extract_pending_chars(void) {$/;"	f
extract_reference_field_from_meta_key	mods/meta_utils.cpp	/^	std::string extract_reference_field_from_meta_key(const std::string& key){$/;"	f	namespace:mods::meta_utils
extractions_pending	handler.cpp	/^int extractions_pending = 0;$/;"	v
f_import_rooms	globals.cpp	/^		bool f_import_rooms;$/;"	m	namespace:mods::globals	file:
fido	spec_assign.cpp	/^SPECIAL(fido);$/;"	v
fido	spec_procs.cpp	/^SPECIAL(fido);$/;"	v
fields_to_grab	mods/lmdb.cpp	/^	std::vector<std::string> _db_handle::fields_to_grab(const std::string& table){$/;"	f	class:mods::lmdb::_db_handle
fight_messages	db.cpp	/^struct message_list fight_messages[MAX_MESSAGES];	\/* fighting messages	 *\/$/;"	v	typeref:struct:message_list
fighting	structs.h	/^	char_data *fighting;	\/* Opponent				*\/$/;"	m	struct:char_special_data
file	mods/catch.hpp	/^		char const* file;$/;"	m	struct:Catch::SourceLineInfo
file_end_pos	mail.cpp	/^long file_end_pos = 0;			\/* length of file *\/$/;"	v
file_to_lmdb	globals.cpp	/^		int file_to_lmdb(const std::string& file, const std::string& key) {$/;"	f	namespace:mods::globals
file_to_string	db.cpp	/^int file_to_string(const char *name, char *buf) {$/;"	f
file_to_string_alloc	db.cpp	/^int file_to_string_alloc(const char *name, char **buf) {$/;"	f
filename	boards.h	/^	char	filename[50];	\/* file to save this board to *\/$/;"	m	struct:board_info_type
fill	interpreter.cpp	/^const char *fill[] = {$/;"	v
fill_word	interpreter.cpp	/^int fill_word(char *argument) {$/;"	f
find_action	act.social.cpp	/^int find_action(int cmd) {$/;"	f
find_alias	interpreter.cpp	/^struct alias_data *find_alias(struct alias_data *alias_list, char *str) {$/;"	f
find_all_dots	handler.cpp	/^int find_all_dots(char *arg) {$/;"	f
find_board	boards.cpp	/^int find_board(struct char_data *ch) {$/;"	f
find_char_in_index	mail.cpp	/^mail_index_type *find_char_in_index(long searchee) {$/;"	f
find_class_bitvector	class.cpp	/^bitvector_t find_class_bitvector(const char *arg) {$/;"	f
find_command	interpreter.cpp	/^int find_command(const char *command) {$/;"	f
find_door	act.movement.cpp	/^	int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname) {$/;"	f
find_eq_pos	act.item.cpp	/^int find_eq_pos(struct char_data *ch, struct obj_data *obj, char *arg) {$/;"	f
find_exdesc	act.informative.cpp	/^char *find_exdesc(char *word, struct extra_descr_data *list) {$/;"	f
find_first_step	graph.cpp	/^int find_first_step(room_rnum src, room_rnum target) {$/;"	f
find_guard	castle.cpp	/^struct char_data *find_guard(struct char_data *chAtChar) {$/;"	f
find_house	house.cpp	/^int find_house(room_vnum vnum) {$/;"	f
find_npc_by_name	castle.cpp	/^struct char_data *find_npc_by_name(struct char_data *chAtChar,$/;"	f
find_oper_num	shop.cpp	/^int find_oper_num(char token) {$/;"	f
find_player_by_name	mods/js.cpp	/^			std::shared_ptr<mods::player> find_player_by_name(std::string_view name,bool& found){$/;"	f	namespace:mods::js::utils
find_player_payload_t	mods/js.cpp	/^				find_player_payload_t(std::string_view name) : player_name(name.data()), found(false){$/;"	f	struct:mods::js::utils::find_player_payload_t
find_player_payload_t	mods/js.cpp	/^			struct find_player_payload_t {$/;"	s	namespace:mods::js::utils	file:
find_results_t	mods/scan.hpp	/^		} find_results_t;$/;"	t	namespace:mods::scan	typeref:struct:mods::scan::__anon5
find_skill_num	spell_parser.cpp	/^int find_skill_num(char *name) {$/;"	f
find_slot	boards.cpp	/^int find_slot(void) {$/;"	f
find_target_room	act.wizard.cpp	/^room_rnum find_target_room(struct char_data *ch, char *rawroomstr) {$/;"	f
flag_help	mods/builder_util.hpp	/^	void flag_help($/;"	f	namespace:mods::builder_util
flagged	mods/behaviour_tree_impl.hpp	/^		bool inline flagged(const argument_type & mob){$/;"	f	namespace:mods::behaviour_tree_impl
flagged	mods/behaviour_tree_impl.hpp	/^		bool inline flagged(const argument_type & mob,const type & type){$/;"	f	namespace:mods::behaviour_tree_impl
flags_door	act.movement.cpp	/^	const int flags_door[] = {$/;"	v
flush_output	structs.cpp	/^		size_t mods::descriptor_data::flush_output(){$/;"	f	class:mods::mods::descriptor_data
flush_queues	comm.cpp	/^void flush_queues(mods::descriptor_data &d) {$/;"	f
flush_to_db	mods/builder.cpp	/^	bool flush_to_db(struct char_data *ch,room_vnum room) {$/;"	f	namespace:mods::builder
fmtfp	bsd-snprintf.cpp	/^fmtfp(char *buffer, size_t *currlen, size_t maxlen, long double fvalue,$/;"	f	file:
fmtint	bsd-snprintf.cpp	/^fmtint(char *buffer, size_t *currlen, size_t maxlen,$/;"	f	file:
fmtstr	bsd-snprintf.cpp	/^fmtstr(char *buffer, size_t *currlen, size_t maxlen,$/;"	f	file:
fname	handler.cpp	/^char *fname(const char *namelist) {$/;"	f
follow_type	structs.h	/^struct follow_type {$/;"	s
follower	structs.h	/^	struct char_data *follower;$/;"	m	struct:follow_type	typeref:struct:follow_type::char_data
followers	structs.h	/^	follow_type *followers;        \/* List of chars followers       *\/$/;"	m	struct:char_data
foreach_all_chars	mods/loops.cpp	/^	void foreach_all_chars(all_function_t func){$/;"	f	namespace:mods::loops
foreach_mob	mods/loops.cpp	/^	void foreach_mob(mob_function_t func){$/;"	f	namespace:mods::loops
foreach_player	mods/loops.cpp	/^	void foreach_player(player_function_t func){$/;"	f	namespace:mods::loops
foreach_player	mods/loops.hpp	/^	static inline PointerType* foreach_player(mods_player_function_t<PointerType> func,PointerType* param){$/;"	f	namespace:mods::loops
forget	mobact.cpp	/^void forget(char_data *ch,char_data *victim) {$/;"	f
found	mods/js.cpp	/^				bool found;$/;"	m	struct:mods::js::utils::find_player_payload_t	file:
found	mods/scan.hpp	/^			bool found;$/;"	m	struct:mods::scan::__anon5
fread_action	act.social.cpp	/^char *fread_action(FILE *fl, int nr) {$/;"	f
fread_string	db.cpp	/^char *fread_string(FILE *fl, const char *error) {$/;"	f
free_alias	interpreter.cpp	/^void free_alias(struct alias_data *a) {$/;"	f
free_char	db.cpp	/^void free_char(struct char_data *ch) {$/;"	f
free_extra_descriptions	db.cpp	/^void free_extra_descriptions(struct extra_descr_data *edesc) {$/;"	f
free_help	db.cpp	/^void free_help(void) {$/;"	f
free_list	mail.cpp	/^position_list_type *free_list = NULL;	\/* list of free positions in file *\/$/;"	v
free_messages	fight.cpp	/^void free_messages(void) {$/;"	f
free_messages_type	fight.cpp	/^void free_messages_type(struct msg_type *msg) {$/;"	f
free_obj	db.cpp	/^void free_obj(struct obj_data *obj) {$/;"	f
free_player_index	db.cpp	/^void free_player_index(void) {$/;"	f
free_rent	config.cpp	/^int free_rent = YES;$/;"	v
free_social_messages	act.social.cpp	/^void free_social_messages(void) {$/;"	f
free_text_files	db.cpp	/^void free_text_files(void) {$/;"	f
freeze_level	structs.h	/^	byte freeze_level;		\/* Level of god who froze char, if any	*\/$/;"	m	struct:player_special_data_saved
from	mail.h	/^	long from;			\/* idnum of the mail's sender		*\/$/;"	m	struct:header_data_type
from	mods/sql.hpp	/^			compositor<T>& from(str_object table) {$/;"	f	struct:mods::sql::compositor
frozen_start_room	config.cpp	/^config::rooms::room_type_t frozen_start_room = 27089;$/;"	v
fry_victim	castle.cpp	/^void fry_victim(struct char_data *ch) {$/;"	f
fullness	constants.cpp	/^const char *fullness[] = {$/;"	v
fullness	constants.hpp	/^const char *fullness[] =$/;"	v
func	shop.h	/^	SPECIAL(*func);		\/* Secondary spec_proc for shopkeeper	*\/$/;"	m	struct:shop_data
func	structs.h	/^	SPECIAL(*func);$/;"	m	struct:index_data
func	structs.h	/^	SPECIAL(*func);$/;"	m	struct:room_data
fuzzy_match	mods/util.cpp	/^		bool fuzzy_match(const std::string& _needle,const std::string & _haystack) {$/;"	f	namespace:mods::util
gain_condition	limits.cpp	/^void gain_condition(struct char_data *ch, int condition, int value) {$/;"	f
gain_exp	limits.cpp	/^void gain_exp(struct char_data *ch, int gain) {$/;"	f
gain_exp_regardless	limits.cpp	/^void gain_exp_regardless(struct char_data *ch, int gain) {$/;"	f
game_loop	comm.cpp	/^void game_loop(socket_t mother_desc) {$/;"	f
gen_board	boards.cpp	/^SPECIAL(gen_board);$/;"	v
gen_board	spec_assign.cpp	/^SPECIAL(gen_board);$/;"	v
gen_receptionist	objsave.cpp	/^int gen_receptionist(struct char_data *ch, struct char_data *recep,$/;"	f
genders	constants.cpp	/^const char *genders[] = {$/;"	v
genders	constants.hpp	/^const char *genders[] =$/;"	v
general_description	structs.h	/^	mods::string general_description;       \/* When look DIR.			*\/$/;"	m	struct:room_direction_data
generate_meta_keys	mods/meta_utils.cpp	/^	std::vector<std::string> generate_meta_keys(const std::string& table,$/;"	f	namespace:mods::meta_utils
generic_find	handler.cpp	/^int generic_find(char *arg, bitvector_t bitvector, struct char_data *ch,$/;"	f
genstr	mods/util-conf.hpp	/^			bool genstr(const std::string& file_name,$/;"	f	namespace:mods::util::conf
get	config.hpp	/^	static inline T get(std::string_view option){$/;"	f	namespace:config
get	mods/catch.hpp	/^			T* get() const {$/;"	f	class:Catch::Ptr
get	mods/jx.hpp	/^			std::string get() {$/;"	f	struct:mods::jx::compositor
get	mods/lmdb.cpp	/^		std::string transaction_t::get(T consumer,std::string key){$/;"	f	class:mods::lmdb::transaction_t
get	mods/lmdb.cpp	/^	int _db_handle::get(std::string key,std::string & in_value){$/;"	f	class:mods::lmdb::_db_handle
get	mods/lmdb.cpp	/^	std::string _db_handle::get(std::string key){$/;"	f	class:mods::lmdb::_db_handle
get	mods/prefs.cpp	/^	std::string prefs::get(const std::string& key,struct char_data* ch) {$/;"	f	class:mods::prefs
getName	mods/catch.hpp	/^			static const char* getName() {$/;"	f	struct:Catch::Internal::OperatorTraits
get_affected	mods/player.cpp	/^			std::map<int64_t,bool> player::get_affected(){$/;"	f	class:mods::player
get_affected_plr	mods/player.cpp	/^			std::map<int64_t,bool> player::get_affected_plr(){$/;"	f	class:mods::player
get_all	mods/lmdb.cpp	/^		result_container_t transaction_t::get_all(T consumer){$/;"	f	class:mods::lmdb::transaction_t
get_all_meta_values	mods/meta_utils.cpp	/^	std::vector<std::pair<std::string,std::string>> get_all_meta_values($/;"	f	namespace:mods::meta_utils
get_ammo	mods/player.cpp	/^	obj_data* player::get_ammo(const weapon_type_t& type) {$/;"	f	class:mods::player
get_bad_password_count	mods/player.cpp	/^			int player::get_bad_password_count(){$/;"	f	class:mods::player
get_bind_addr	comm.cpp	/^struct in_addr *get_bind_addr() {$/;"	f
get_by_id	mods/lmdb.cpp	/^		result_container_t transaction_t::get_by_id(T consumer,std::string id){$/;"	f	class:mods::lmdb::transaction_t
get_by_meta	mods/lmdb.cpp	/^		result_container_t transaction_t::get_by_meta(T consumer,std::string column,std::string equals_value){$/;"	f	class:mods::lmdb::transaction_t
get_captured_output	mods/player.cpp	/^	std::string_view player::get_captured_output() {$/;"	f	class:mods::player
get_char_num	handler.cpp	/^struct char_data *get_char_num(mob_rnum nr) {$/;"	f
get_char_room	handler.cpp	/^struct char_data *get_char_room(char *name, int *number, room_rnum room) {$/;"	f
get_char_room_vis	handler.cpp	/^struct char_data *get_char_room_vis(struct char_data *ch, char *name, int *number) {$/;"	f
get_char_vis	handler.cpp	/^struct char_data *get_char_vis(struct char_data *ch, char *name, int *number, int where) {$/;"	f
get_char_world_vis	handler.cpp	/^struct char_data *get_char_world_vis(struct char_data *ch, char *name, int *number) {$/;"	f
get_check_money	act.item.cpp	/^void get_check_money(struct char_data *ch, struct obj_data *obj) {$/;"	f
get_children	mods/behaviour_tree_node.hpp	/^		children_t & get_children() const { return m_children; }$/;"	f	struct:mods::behaviour_tree_node
get_class	mods/player.cpp	/^	std::shared_ptr<mods::classes::base>& player::get_class(class_type c_type) {$/;"	f	class:mods::player
get_context	mods/js.hpp	/^				inline duk_context* get_context() {$/;"	f	struct:mods::js::include
get_current_player	mods/js.cpp	/^		static duk_ret_t get_current_player(duk_context *ctx) {$/;"	f	namespace:mods::js
get_db_id	mods/player.cpp	/^			aligned_int_t player::get_db_id() const {$/;"	f	class:mods::player
get_dir	mods/js.hpp	/^				inline std::string_view get_dir() {$/;"	f	struct:mods::js::include
get_drone	mods/drone.cpp	/^	 void drone::get_drone(struct char_data* owner) {$/;"	f	class:mods::drone
get_existing	mods/drone.cpp	/^	 struct char_data * drone::get_existing(struct char_data* owner) {$/;"	f	class:mods::drone
get_file	mods/js.hpp	/^				inline std::string_view get_file() {$/;"	f	struct:mods::js::include
get_filename	utils.cpp	/^int get_filename(char *filename, size_t fbufsize, int mode, const char *orig_name) {$/;"	f
get_first_ammo_of_type	mods/player.cpp	/^	obj_data* player::get_first_ammo_of_type(const weapon_type_t& type) const {$/;"	f	class:mods::player
get_from_container	act.item.cpp	/^void get_from_container(struct char_data *ch, struct obj_data *cont,$/;"	f
get_from_q	comm.cpp	/^int get_from_q(struct txt_q *queue, char *dest, int *aliased) {$/;"	f
get_from_room	act.item.cpp	/^void get_from_room(struct char_data *ch, char *arg, int howmany) {$/;"	f
get_hash_obj_vis	shop.cpp	/^struct obj_data *get_hash_obj_vis(struct char_data *ch, char *name,$/;"	f
get_id_by_name	db.cpp	/^long get_id_by_name(const char *name) {$/;"	f
get_last_error	mods/player-scaffolding.cpp	/^	std::vector<std::string>* player_scaffolding::get_last_error(){$/;"	f	class:mods::player_scaffolding
get_line	utils.cpp	/^int get_line(FILE *fl, char *buf) {$/;"	f
get_logic	mods/behaviour_tree_node.hpp	/^		callback_t & get_logic() const { return m_logic; }$/;"	f	struct:mods::behaviour_tree_node
get_max_players	comm.cpp	/^int get_max_players(void) {$/;"	f
get_name	mods/chat.cpp	/^	std::string_view channel::get_name() const {$/;"	f	class:mods::chat::channel
get_name_by_id	db.cpp	/^char *get_name_by_id(long id) {$/;"	f
get_node	mods/behaviour_tree.hpp	/^		node & get_node() const {$/;"	f	struct:mods::behaviour_tree
get_number	handler.cpp	/^int get_number(char **name) {$/;"	f
get_obj_in_equip_vis	handler.cpp	/^struct obj_data *get_obj_in_equip_vis(struct char_data *ch, char *arg, int *number, struct obj_data *equipment[]) {$/;"	f
get_obj_in_list_num	handler.cpp	/^struct obj_data *get_obj_in_list_num(int num, struct obj_data *list) {$/;"	f
get_obj_in_list_vis	handler.cpp	/^struct obj_data *get_obj_in_list_vis(struct char_data *ch, char *name, int *number, struct obj_data *list) {$/;"	f
get_obj_num	handler.cpp	/^struct obj_data *get_obj_num(obj_rnum nr) {$/;"	f
get_obj_pos_in_equip_vis	handler.cpp	/^int get_obj_pos_in_equip_vis(struct char_data *ch, char *arg, int *number, struct obj_data *equipment[]) {$/;"	f
get_obj_vis	handler.cpp	/^struct obj_data *get_obj_vis(struct char_data *ch, char *name, int *number) {$/;"	f
get_one_line	db.cpp	/^void get_one_line(FILE *fl, char *buf) {$/;"	f
get_password	mods/player.cpp	/^			std::string player::get_password(){$/;"	f	class:mods::player
get_pk_by_meta	mods/meta_utils.cpp	/^	std::optional<aligned_int_t> get_pk_by_meta($/;"	f	namespace:mods::meta_utils
get_player_vis	handler.cpp	/^struct char_data *get_player_vis(struct char_data *ch, char *name, int *number, int inroom) {$/;"	f
get_pluck_filter	mods/lmdb.cpp	/^	const std::vector<std::string> & _db_handle::get_pluck_filter() const {$/;"	f	class:mods::lmdb::_db_handle
get_private	mods/chat.hpp	/^			bool get_private() const {$/;"	f	struct:mods::mods::chat::channel
get_private_publishers	mods/chat.hpp	/^			const std::vector<std::string>& get_private_publishers() const {$/;"	f	struct:mods::mods::chat::channel
get_ptable_by_name	db.cpp	/^long get_ptable_by_name(const char *name) {$/;"	f
get_purchase_obj	shop.cpp	/^struct obj_data *get_purchase_obj(struct char_data *ch, char *arg,$/;"	f
get_queue_behaviour	structs.h	/^		queue_behaviour_enum_t get_queue_behaviour() const {$/;"	f	struct:mods::descriptor_data
get_row_id_list	mods/lmdb.cpp	/^	uint64_t transaction_t::get_row_id_list(row_id_list_t & rows){$/;"	f	class:mods::lmdb::transaction_t
get_selling_obj	shop.cpp	/^struct obj_data *get_selling_obj(struct char_data *ch, char *name, struct char_data *keeper, int shop_nr, int msg) {$/;"	f
get_slide_obj_vis	shop.cpp	/^struct obj_data *get_slide_obj_vis(struct char_data *ch, char *name,$/;"	f
get_string	mods/util.cpp	/^	std::string get_string(int _errno){$/;"	f	namespace:mods::util::err
get_time_birth	mods/player.cpp	/^			time_t player::get_time_birth() const {$/;"	f	class:mods::player
get_time_login	mods/player.cpp	/^			time_t player::get_time_login() const {$/;"	f	class:mods::player
get_time_played	mods/player.cpp	/^			int player::get_time_played() const{$/;"	f	class:mods::player
get_uuid	globals.cpp	/^		uuid_t get_uuid() {$/;"	f	namespace:mods::globals
get_verb	mods/chat.cpp	/^	std::string_view channel::get_verb() const {$/;"	f	class:mods::chat::channel
get_victim	castle.cpp	/^struct char_data *get_victim(struct char_data *chAtChar) {$/;"	f
gettimeofday	comm.cpp	/^void gettimeofday(struct timeval *t, struct timezone *dummy) {$/;"	f
give_find_vict	act.item.cpp	/^struct char_data *give_find_vict(struct char_data *ch, char *arg) {$/;"	f
glob	mods/util.cpp	/^		directory_list_t glob(std::string_view path){$/;"	f	namespace:mods::util
globals	config.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	globals.cpp	/^	namespace globals {$/;"	n	namespace:mods	file:
globals	globals.hpp	/^    namespace globals {$/;"	n	namespace:mods
globals	mods/lmdb.cpp	/^namespace mods::globals {$/;"	n	class:mods	file:
globals	mods/lmdb.hpp	/^namespace mods::globals {$/;"	n	class:mods
goal	structs.h	/^	goal_t goal;$/;"	m	struct:char_data
goal_t	structs.h	/^typedef short goal_t;$/;"	t
god_mode	mods/player.cpp	/^			bool player::god_mode() const{$/;"	f	class:mods::player
god_msg	structs.h	/^	struct msg_type god_msg;	\/* messages when hit on god		*\/$/;"	m	struct:message_type	typeref:struct:message_type::msg_type
gods	mods/acl_list.cpp	/^		static player_acl_list_t gods;$/;"	m	namespace:mods::acl_list::list_container	file:
gold	mods/player.hpp	/^			int& gold() {$/;"	f	class:mods::player
gold	structs.h	/^	int	gold;           \/* Money carried                           *\/$/;"	m	struct:char_point_data
gold	structs.h	/^	int	gold;$/;"	m	struct:rent_info
good	mods/js.hpp	/^				inline bool good() {$/;"	f	struct:mods::js::include
graf	limits.cpp	/^int graf(int grafage, int p0, int p1, int p2, int p3, int p4, int p5, int p6) {$/;"	f
grenade	mods/weapon.hpp	/^			static constexpr int grenade = 2;$/;"	m	struct:mods::weapon::mask
grenade_damage	fight.cpp	/^int grenade_damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype) {$/;"	f
grenade_damage	mods/projectile.cpp	/^		int grenade_damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype) {$/;"	f	namespace:mods::projectile
group_gain	fight.cpp	/^void group_gain(struct char_data *ch, struct char_data *victim) {$/;"	f
guests	house.h	/^	long guests[MAX_GUESTS];	\/* idnums of house's guests	*\/$/;"	m	struct:house_control_rec
guild	castle.cpp	/^SPECIAL(guild);$/;"	v
guild	spec_assign.cpp	/^SPECIAL(guild);$/;"	v
guild	spec_procs.cpp	/^SPECIAL(guild);$/;"	v
guild_guard	spec_assign.cpp	/^SPECIAL(guild_guard);$/;"	v
guild_guard	spec_procs.cpp	/^SPECIAL(guild_guard);$/;"	v
guild_info	class.cpp	/^struct guild_info_type guild_info[] = {$/;"	v	typeref:struct:guild_info_type
guild_info_type	structs.h	/^struct guild_info_type {$/;"	s
guild_room	structs.h	/^	room_vnum guild_room;$/;"	m	struct:guild_info_type
half_chop	interpreter.cpp	/^void half_chop(char *string, char *arg1, char *arg2) {$/;"	f
handbook	db.cpp	/^char *handbook = NULL;		\/* handbook for new immortals	 *\/$/;"	v
handle_disconnects	comm.cpp	/^std::size_t handle_disconnects(){$/;"	f
has_affect	mods/player.cpp	/^			bool player::has_affect(int64_t flag){$/;"	f	class:mods::player
has_affect_plr	mods/player.cpp	/^			bool player::has_affect_plr(int64_t flag) {$/;"	f	class:mods::player
has_ammo	mods/player.cpp	/^	bool player::has_ammo() {$/;"	f	class:mods::player
has_boat	act.movement.cpp	/^int has_boat(struct char_data *ch) {$/;"	f
has_builder_data	mods/player.cpp	/^			bool player::has_builder_data(){$/;"	f	class:mods::player
has_class_capability	mods/player.cpp	/^	bool player::has_class_capability(class_type type) {$/;"	f	class:mods::player
has_desc	structs.h	/^	bool has_desc;$/;"	m	struct:char_data
has_equipment_tag	mods/player.cpp	/^	bool player::has_equipment_tag(const std::string& tag) {$/;"	f	class:mods::player
has_inventory_capability	mods/player.cpp	/^	bool player::has_inventory_capability(int type) {$/;"	f	class:mods::player
has_key	act.movement.cpp	/^	int has_key(struct char_data *ch, obj_vnum key) {$/;"	f
has_mail	mail.cpp	/^int has_mail(long recipient) {$/;"	f
has_output	structs.h	/^		bool has_output;$/;"	m	struct:mods::descriptor_data
has_prompt	structs.h	/^		int	has_prompt;		\/* is the user at a prompt?             *\/$/;"	m	struct:mods::descriptor_data
has_quest	mods/quests.cpp	/^		bool has_quest(struct char_data * ch) {$/;"	f	namespace:mods::quests
has_thermite	mods/player.cpp	/^	bool player::has_thermite() {$/;"	f	class:mods::player
has_weapon_capability	mods/player.cpp	/^	bool player::has_weapon_capability(int type) {$/;"	f	class:mods::player
hcontrol_build_house	house.cpp	/^void hcontrol_build_house(struct char_data *ch, char *arg) {$/;"	f
hcontrol_destroy_house	house.cpp	/^void hcontrol_destroy_house(struct char_data *ch, char *arg) {$/;"	f
hcontrol_list_houses	house.cpp	/^void hcontrol_list_houses(struct char_data *ch) {$/;"	f
hcontrol_pay_house	house.cpp	/^void hcontrol_pay_house(struct char_data *ch, char *arg) {$/;"	f
head	db.h	/^	struct reset_q_element *head;$/;"	m	struct:reset_q_type	typeref:struct:reset_q_type::reset_q_element
head	structs.h	/^	struct txt_block *head;$/;"	m	struct:txt_q	typeref:struct:txt_q::txt_block
header_block_type	mail.h	/^typedef struct header_block_type_d header_block_type;$/;"	t	typeref:struct:header_block_type_d
header_block_type_d	mail.h	/^struct header_block_type_d {$/;"	s
header_data	mail.h	/^	struct header_data_type header_data;	\/* other header data		*\/$/;"	m	struct:header_block_type_d	typeref:struct:header_block_type_d::header_data_type
header_data_type	mail.h	/^struct header_data_type {$/;"	s
heading	boards.h	/^	char	*heading;     \/* pointer to message's heading *\/$/;"	m	struct:board_msginfo
heading_len	boards.h	/^	int	heading_len;  \/* size of header (for file write) *\/$/;"	m	struct:board_msginfo
heartbeat	comm.cpp	/^void heartbeat(int pulse) {$/;"	f
height	structs.h	/^	ubyte height;       \/* PC \/ NPC's height                    *\/$/;"	m	struct:char_player_data
height	structs.h	/^	ubyte height;$/;"	m	struct:char_file_u
hell	mods/hell.cpp	/^namespace mods::hell {$/;"	n	class:mods	file:
hell	mods/hell.hpp	/^namespace mods::hell {$/;"	n	class:mods
help	db.cpp	/^char *help = NULL;		\/* help screen			 *\/$/;"	v
help_index_element	db.h	/^struct help_index_element {$/;"	s
help_table	db.cpp	/^struct help_index_element *help_table = 0;	\/* the help table	 *\/$/;"	v	typeref:struct:help_index_element
hide	act.social.cpp	/^	int hide;$/;"	m	struct:social_messg	file:
hide	structs.h	/^	sh_int hide;$/;"	m	struct:dex_skill_type
history	structs.h	/^		history_type_t history;		\/* History of commands, for ! mostly.	*\/$/;"	m	struct:mods::descriptor_data
history_pos	structs.h	/^		history_pos_type_t history_pos;$/;"	m	struct:mods::descriptor_data
hit	fight.cpp	/^void hit(struct char_data *ch, struct char_data *victim, int type) {$/;"	f
hit	mods/js.cpp	/^		static duk_ret_t hit(duk_context *ctx) {$/;"	f	namespace:mods::js
hit	structs.h	/^	sh_int hit;$/;"	m	struct:char_point_data
hit_gain	limits.cpp	/^int hit_gain(struct char_data *ch) {$/;"	f
hit_msg	structs.h	/^	struct msg_type hit_msg;	\/* messages when hit			*\/$/;"	m	struct:message_type	typeref:struct:message_type::msg_type
hitp	structs.h	/^	sh_int hitp;$/;"	m	struct:con_app_type
hitroll	mods/player.hpp	/^			sbyte& hitroll() {$/;"	f	class:mods::player
hitroll	structs.h	/^	sbyte hitroll;       \/* Any bonus or penalty to the hit roll    *\/$/;"	m	struct:char_point_data
holds_ammo	structs.h	/^	short holds_ammo;$/;"	m	struct:obj_data
holler_move_cost	config.cpp	/^int holler_move_cost = 20;$/;"	v
hometown	structs.h	/^	sh_int hometown;    \/* PC s Hometown (zone)                 *\/$/;"	m	struct:char_player_data
hometown	structs.h	/^	sh_int hometown;$/;"	m	struct:char_file_u
host	mods/player.cpp	/^			std::string player::host() const {$/;"	f	class:mods::player
host	structs.h	/^		mods::string host;		\/* hostname				*\/$/;"	m	struct:mods::descriptor_data
host	structs.h	/^	mods::string host;	\/* host of last logon *\/$/;"	m	struct:char_file_u
hours	structs.h	/^	int hours, day, month;$/;"	m	struct:time_info_data
house_control	house.cpp	/^struct house_control_rec house_control[MAX_HOUSES];$/;"	v	typeref:struct:house_control_rec
house_control_rec	house.h	/^struct house_control_rec {$/;"	s
how_good	spec_procs.cpp	/^const char *how_good(int percent) {$/;"	f
hp	mods/player.hpp	/^			sh_int& hp() {$/;"	f	class:mods::player
hsort	db.cpp	/^int hsort(const void *a, const void *b) {$/;"	f
hunt_victim	graph.cpp	/^void hunt_victim(struct char_data *ch) {$/;"	f
hunting	structs.h	/^	char_data *hunting;	\/* Char hunted by this char		*\/$/;"	m	struct:char_special_data
hupsig	comm.cpp	/^RETSIGTYPE hupsig(int sig) {$/;"	f
id	db.h	/^	long id;$/;"	m	struct:player_index_element
id	mods/behaviour_tree_node.hpp	/^			uint64_t id;\\$/;"	m	struct:mods::behaviour_tree_node::__anon2
id	structs.h	/^	long	id;$/;"	m	struct:memory_rec_struct
idle	config.cpp	/^		room_type_t idle(){$/;"	f	namespace:config::rooms
idle_max_level	config.cpp	/^int idle_max_level = LVL_GOD;$/;"	v
idle_rent_time	config.cpp	/^int idle_rent_time = 48;$/;"	v
idle_tics	structs.h	/^		byte idle_tics;		\/* tics idle at password prompt		*\/$/;"	m	struct:mods::descriptor_data
idle_void	config.cpp	/^int idle_void = 8;$/;"	v
idnum	structs.h	/^	long	idnum;			\/* player's idnum; -1 for mobiles	*\/$/;"	m	struct:char_special_data_saved
if_flag	db.h	/^	bool if_flag;	\/* if TRUE: exe only if preceding exe'd *\/$/;"	m	struct:reset_com
immlist	db.cpp	/^char *immlist = NULL;		\/* list of peon gods		 *\/$/;"	v
immort_level_ok	config.cpp	/^int immort_level_ok = 0;$/;"	v
immort_start_room	config.cpp	/^config::rooms::room_type_t immort_start_room = 27089;$/;"	v
immortal	mods/immortal.cpp	/^namespace mods::immortal {$/;"	n	class:mods	file:
immortal	mods/immortal.hpp	/^namespace mods::immortal {$/;"	n	class:mods
imotd	db.cpp	/^char *imotd = NULL;		\/* message of the day - immorts *\/$/;"	v
implementor_mode	mods/player.cpp	/^			bool player::implementor_mode() const{$/;"	f	class:mods::player
implementors	mods/acl_list.cpp	/^		static player_acl_list_t implementors;$/;"	m	namespace:mods::acl_list::list_container	file:
import_room	mods/builder.cpp	/^	int import_room(struct room_data* room) {$/;"	f	namespace:mods::builder
in_addr	sysdep.h	/^struct in_addr {$/;"	s
in_obj	structs.h	/^	struct obj_data *in_obj;       \/* In what object NULL when none    *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::obj_data
in_room	mods/js.cpp	/^		static duk_ret_t in_room(duk_context *ctx) {$/;"	f	namespace:mods::js
in_room	shop.h	/^	room_vnum *in_room;		\/* Where is the shop?			*\/$/;"	m	struct:shop_data
in_room	structs.h	/^	room_rnum in_room;		\/* In what room -1 when conta\/carr	*\/$/;"	m	struct:obj_data
in_room	structs.h	/^	room_rnum in_room;                    \/* Location (real room number)	  *\/$/;"	m	struct:char_data
inbuf	structs.h	/^		buffer_type_t inbuf;  \/* buffer for raw input		*\/$/;"	m	struct:mods::descriptor_data
include	mods/js.hpp	/^				include(duk_context *ctx,std::string_view directory,std::string_view file)$/;"	f	struct:mods::js::include
include	mods/js.hpp	/^				include(duk_context *ctx,std::string_view file)$/;"	f	struct:mods::js::include
include	mods/js.hpp	/^		struct include {$/;"	s	namespace:mods::js
include_file	mods/js.cpp	/^		bool include::include_file() {$/;"	f	class:mods::js::include
increment_bad_password_count	mods/player.cpp	/^			void player::increment_bad_password_count(){$/;"	f	class:mods::player
index_boot	db.cpp	/^void index_boot(int mode) {$/;"	f
index_boot_hlp	mods/hell.hpp	/^	constexpr inline bool index_boot_hlp = true;$/;"	m	namespace:mods::hell
index_data	structs.h	/^struct index_data {$/;"	s
index_mail	mail.cpp	/^void index_mail(long id_to_index, long pos) {$/;"	f
info	db.cpp	/^char *info = NULL;		\/* info page			 *\/$/;"	v
init	config.cpp	/^	void init(int argc,char** argv){$/;"	f	namespace:config
init	globals.cpp	/^		void init(int argc,char** argv) {$/;"	f	namespace:mods::globals
init	mods/player.cpp	/^	void player::init(){$/;"	f	class:mods::player
init	structs.cpp	/^	void char_data::init(){$/;"	f	class:char_data
init_boards	boards.cpp	/^void init_boards(void) {$/;"	f
init_char	db.cpp	/^void init_char(std::shared_ptr<mods::player> player) {$/;"	f
init_game	comm.cpp	/^void init_game(ush_int port) {$/;"	f
init_player	globals.cpp	/^		void init_player(char_data* ch) {$/;"	f	namespace:mods::globals
init_socket	comm.cpp	/^socket_t init_socket(ush_int port) {$/;"	f
init_spell_levels	class.cpp	/^void init_spell_levels(void) {$/;"	f
init_spell_levels	mods/hell.hpp	/^	constexpr inline bool init_spell_levels = false;$/;"	m	namespace:mods::hell
initialize_builder	mods/builder.cpp	/^	inline void initialize_builder(char_data* player){$/;"	f	namespace:mods::builder
initialize_player	mods/player-scaffolding.cpp	/^	int player_scaffolding::initialize_player(std::shared_ptr<mods::player> player,int to_room){$/;"	f	class:mods::player_scaffolding
initialize_row	mods/db.cpp	/^aligned_int_t initialize_row($/;"	f	namespace:mods::db
initialize_table_schema	mods/db.hpp	/^static inline int_status_t initialize_table_schema(std::string table){$/;"	f
inner_join	mods/sql.hpp	/^			compositor<T>& inner_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
input	structs.h	/^		struct txt_q input;             \/* q of unprocessed input               *\/$/;"	m	struct:mods::descriptor_data	typeref:struct:mods::descriptor_data::txt_q
insert	mods/lmdb.hpp	/^	inline transaction_ptr insert(std::string table){$/;"	f	namespace:mods::lmdb
insert	mods/sql.hpp	/^			compositor<T>& insert() {$/;"	f	struct:mods::sql::compositor
instantiate_object_by_index	mods/builder.cpp	/^	std::optional<object_data*> instantiate_object_by_index(int index) {$/;"	f	namespace:mods::builder
instantiate_object_by_vnum	mods/builder.cpp	/^	std::optional<object_data*> instantiate_object_by_vnum(object_vnum vnum) {$/;"	f	namespace:mods::builder
instantiate_object_vector	mods/builder_util.hpp	/^	void instantiate_object_vector($/;"	f	namespace:mods::builder_util
int_app	constants.cpp	/^cpp_extern const struct int_app_type int_app[] = {$/;"	v	typeref:struct:int_app_type
int_app	constants.hpp	/^cpp_extern const struct int_app_type int_app[] = {$/;"	v	typeref:struct:int_app_type
int_app_type	structs.h	/^struct int_app_type {$/;"	s
intel	structs.h	/^	sbyte intel;$/;"	m	struct:char_ability_data
interpret	mods/drone.cpp	/^	 bool drone::interpret(struct char_data *owner,const std::string& argument) {$/;"	f	class:mods::drone
interpret_espec	db.cpp	/^void interpret_espec(const char *keyword, const char *value, int i, int nr) {$/;"	f
into	mods/sql.hpp	/^			compositor<T>& into(str_object table) {$/;"	f	struct:mods::sql::compositor
invalid_align	handler.cpp	/^int invalid_align(struct char_data *ch, struct obj_data *obj) {$/;"	f
invalid_class	class.cpp	/^int invalid_class(struct char_data *ch, struct obj_data *obj) {$/;"	f
invalid_list	ban.cpp	/^char *invalid_list[MAX_INVALID_NAMES];$/;"	v
invis_level	structs.h	/^	sh_int invis_level;		\/* level of invisibility		*\/$/;"	m	struct:player_special_data_saved
invoke	mods/catch.hpp	/^			virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase
isBinaryExpression	mods/catch.hpp	/^			virtual bool isBinaryExpression() const {$/;"	f	struct:Catch::DecomposedExpression
isFalseTest	mods/catch.hpp	/^	inline bool isFalseTest(int flags)                {$/;"	f	namespace:Catch
isJustInfo	mods/catch.hpp	/^	inline bool isJustInfo(int flags) {$/;"	f	namespace:Catch
isOk	mods/catch.hpp	/^	inline bool isOk(ResultWas::OfType resultType) {$/;"	f	namespace:Catch
isTrue	mods/catch.hpp	/^	inline bool isTrue(bool value) {$/;"	f	namespace:Catch
is_abbrev	interpreter.cpp	/^int is_abbrev(const char *arg1, const char *arg2) {$/;"	f
is_empty	db.cpp	/^int is_empty(zone_rnum zone_nr) {$/;"	f
is_executing_js	mods/player.cpp	/^	bool player::is_executing_js() const {$/;"	f	class:mods::player
is_number	interpreter.cpp	/^int is_number(const char *str) {$/;"	f
is_ok	shop.cpp	/^int is_ok(struct char_data *keeper, struct char_data *ch, int shop_nr) {$/;"	f
is_ok_char	shop.cpp	/^int is_ok_char(struct char_data *keeper, struct char_data *ch, int shop_nr) {$/;"	f
is_open	shop.cpp	/^int is_open(struct char_data *keeper, int shop_nr, int msg) {$/;"	f
is_tell_ok	act.comm.cpp	/^int is_tell_ok(struct char_data *ch, struct char_data *vict) {$/;"	f
is_trash	castle.cpp	/^int is_trash(struct obj_data *i) {$/;"	f
is_using_pluck_filter	mods/lmdb.cpp	/^		bool _db_handle::is_using_pluck_filter() const { $/;"	f	class:mods::lmdb::_db_handle
is_valid_name	login.cpp	/^	bool is_valid_name(std::string_view name){$/;"	f	namespace:login
is_weapon_loaded	mods/player.cpp	/^	bool player::is_weapon_loaded() {$/;"	f	class:mods::player
isascii	sysdep.h	343;"	d
isbanned	ban.cpp	/^int isbanned(const char *hostname) {$/;"	f
isbanned	mods/ban_system.hpp	/^		bool isbanned(const std::string &m){ \/** FIXME *\/ return false; }$/;"	f	namespace:mods::ban_system
isname	handler.cpp	/^int isname(const char *str, const char *namelist) {$/;"	f
item_number	structs.h	/^	obj_vnum item_number;	\/* Where in data-base			*\/$/;"	m	struct:obj_data
item_number	structs.h	/^	obj_vnum item_number;$/;"	m	struct:obj_file_elem
item_types	constants.cpp	/^const char *item_types[] = {$/;"	v
item_types	constants.hpp	/^const char *item_types[] = {$/;"	v
iteration	mods/deferred.cpp	/^	void deferred::iteration() {$/;"	f	class:mods::deferred
itoa	mods/util.cpp	/^	std::string itoa(int number) {$/;"	f	namespace:mods::util
janitor	spec_assign.cpp	/^SPECIAL(janitor);$/;"	v
janitor	spec_procs.cpp	/^SPECIAL(janitor);$/;"	v
jerry	castle.cpp	/^SPECIAL(jerry);$/;"	v
js	mods/js.cpp	/^	namespace js {$/;"	n	namespace:mods	file:
js	mods/js.hpp	/^	namespace js {$/;"	n	namespace:mods
js_object	mods/player.cpp	/^	std::string player::js_object() {$/;"	f	class:mods::player
js_profile_initialized	structs.h	/^	bool js_profile_initialized;$/;"	m	struct:player_special_data
just_color_evaluation	mods/player.cpp	/^	std::string just_color_evaluation(std::string final_buffer) {$/;"	f	namespace:mods
jx	mods/jx.hpp	/^namespace mods::jx {$/;"	n	class:mods
keeper	shop.h	/^	mob_rnum	 keeper;	\/* The mobile who owns the shop (rnum)	*\/$/;"	m	struct:shop_data
key	structs.h	/^	obj_vnum key;		\/* Key's number (-1 for no key)		*\/$/;"	m	struct:room_direction_data
keyval_first	mods/util-map.hpp	/^			Tkey keyval_first(std::map<Tkey,Tval>& m,const Tval value,Tkey default_value) {$/;"	f	namespace:mods::util::maps
keyword	db.h	/^	char	*keyword;$/;"	m	struct:help_index_element
keyword	structs.h	/^	char	*keyword;                 \/* Keyword in look\/examine          *\/$/;"	m	struct:extra_descr_data
keyword	structs.h	/^	mods::string keyword;		\/* for open\/close			*\/$/;"	m	struct:room_direction_data
keywords	shop.h	/^	char *keywords;$/;"	m	struct:shop_buy_data
king_welmar	castle.cpp	/^SPECIAL(king_welmar);$/;"	v
large_outbuf	structs.h	/^		struct txt_block *large_outbuf; \/* ptr to large buffer, if we need it *\/$/;"	m	struct:mods::descriptor_data	typeref:struct:mods::descriptor_data::txt_block
last_fight_timestamp	structs.h	/^	time_t last_fight_timestamp;			\/* timestamp of the last time the user fought *\/$/;"	m	struct:char_data
last_input	structs.h	/^		buffer_type_t last_input; \/* the last input			*\/$/;"	m	struct:mods::descriptor_data
last_logon	structs.h	/^	time_t last_logon;		\/* Time (in secs) of last logon *\/$/;"	m	struct:char_file_u
last_olc_mode	structs.h	/^	int last_olc_mode;		\/* olc control				*\/$/;"	m	struct:player_special_data
last_olc_targ	structs.h	/^	void *last_olc_targ;		\/* olc control				*\/$/;"	m	struct:player_special_data
last_payment	house.h	/^	time_t last_payment;		\/* date of last house payment   *\/$/;"	m	struct:house_control_rec
last_tell	structs.h	/^	long last_tell;		\/* idnum of last tell from		*\/$/;"	m	struct:player_special_data
lastsort	shop.h	/^	int	 lastsort;		\/* How many items are sorted in inven?	*\/$/;"	m	struct:shop_data
learn	structs.h	/^	byte learn;       \/* how many % a player learns a spell\/skill *\/$/;"	m	struct:int_app_type
leave_quest	mods/quests.cpp	/^		void leave_quest(struct char_data* ch,int quest_id) {$/;"	f	namespace:mods::quests
left_join	mods/sql.hpp	/^			compositor<T>& left_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
left_outer_join	mods/sql.hpp	/^			compositor<T>& left_outer_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
len	shop.h	/^	int len;$/;"	m	struct:stack_data
length	modify.cpp	/^int length[] = {$/;"	v
length	mods/string.cpp	/^	unsigned int string::length() const {$/;"	f	class:mods::string
level	act.wizard.cpp	/^	const char level;$/;"	m	struct:set_struct	file:
level	boards.h	/^	int	level;        \/* level of poster *\/$/;"	m	struct:board_msginfo
level	mods/player.hpp	/^			byte& level(){$/;"	f	class:mods::player
level	structs.h	/^	byte level;         \/* PC \/ NPC's level                     *\/$/;"	m	struct:char_player_data
level	structs.h	/^	byte level;$/;"	m	struct:char_file_u
level_can_shout	config.cpp	/^int level_can_shout = 1;$/;"	v
level_exp	class.cpp	/^int level_exp(int chclass, int level) {$/;"	f
lifespan	db.h	/^	int	lifespan;           \/* how long between resets (minutes)  *\/$/;"	m	struct:zone_data
light	structs.h	/^	byte light;                  \/* Number of lightsources in room     *\/$/;"	m	struct:room_data
line	db.h	/^	int line;		\/* line number this command appears on  *\/$/;"	m	struct:reset_com
line	mods/catch.hpp	/^		std::size_t line;$/;"	m	struct:Catch::SourceLineInfo
lineInfo	mods/catch.hpp	/^		SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo
linked_list_remove	mods/util.hpp	/^	inline void linked_list_remove(T item, T head) {$/;"	f	namespace:mods::util
list_all_shops	shop.cpp	/^void list_all_shops(struct char_data *ch) {$/;"	f
list_char_to_char	act.informative.cpp	/^void list_char_to_char(struct char_data *list, struct char_data *ch) {$/;"	f
list_container	mods/acl_list.cpp	/^	namespace list_container{$/;"	n	namespace:mods::acl_list	file:
list_detailed_shop	shop.cpp	/^void list_detailed_shop(struct char_data *ch, int shop_nr) {$/;"	f
list_obj_to_char	act.informative.cpp	/^void list_obj_to_char(struct obj_data *list, struct char_data *ch, int mode, int show) {$/;"	f
list_object	shop.cpp	/^char *list_object(struct obj_data *obj, int cnt, int aindex, int shop_nr, struct char_data *keeper, struct char_data *ch) {$/;"	f
list_object_vector	mods/builder_util.hpp	/^	void list_object_vector($/;"	f	namespace:mods::builder_util
list_one_char	act.informative.cpp	/^void list_one_char(struct char_data *i, struct char_data *ch) {$/;"	f
list_quests	mods/quests.cpp	/^		static duk_ret_t list_quests(duk_context *ctx) {$/;"	f	namespace:mods::quests
list_quests	mods/quests.cpp	/^		std::vector<std::string> list_quests(room_rnum room_id) {$/;"	f	namespace:mods::quests
list_skills	spec_procs.cpp	/^void list_skills(struct char_data *ch) {$/;"	f
list_start	mail.h	/^	position_list_type *list_start;	\/* list of mail positions	*\/$/;"	m	struct:mail_index_type_d
list_top	act.social.cpp	/^static int list_top = -1;$/;"	v	file:
lmdb	mods/lmdb.cpp	/^namespace mods::lmdb {$/;"	n	class:mods	file:
lmdb	mods/lmdb.hpp	/^namespace mods::lmdb {$/;"	n	class:mods
lmdb_export_char	mods/db.cpp	/^void lmdb_export_char(std::shared_ptr<mods::player> player_ptr, mutable_map_t &values){$/;"	f	namespace:mods::db
lmdb_write_values	mods/db.cpp	/^tuple_status_t lmdb_write_values($/;"	f	namespace:mods::db
load_banned	ban.cpp	/^void load_banned(void) {$/;"	f
load_banned	mods/hell.hpp	/^	constexpr inline bool load_banned = false;$/;"	m	namespace:mods::hell
load_base_functions	mods/js.cpp	/^		void load_base_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_c_functions	mods/js.cpp	/^		void load_c_functions() {$/;"	f	namespace:mods::js
load_c_functions	mods/js.cpp	/^		void load_c_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_c_functions	mods/quests.cpp	/^		void load_c_functions(duk_context *ctx) {$/;"	f	namespace:mods::quests
load_c_require_functions	mods/js.cpp	/^		void load_c_require_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_c_test_functions	mods/js.cpp	/^		void load_c_test_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_help	db.cpp	/^void load_help(FILE *fl) {$/;"	f
load_into_inventory	config.cpp	/^int load_into_inventory = NO;$/;"	v
load_library	mods/js.cpp	/^		int load_library(duk_context *ctx,std::string_view file) {$/;"	f	namespace:mods::js
load_messages	fight.cpp	/^void load_messages(void) {$/;"	f
load_messages	mods/hell.hpp	/^	constexpr inline bool load_messages = false;$/;"	m	namespace:mods::hell
load_mods_player_functions	mods/js.cpp	/^		void load_mods_player_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_quest_code	mods/quests.cpp	/^		void load_quest_code(struct char_data* ch) {$/;"	f	namespace:mods::quests
load_record	mods/db.cpp	/^int load_record(const std::string& table, aligned_int_t pk, mutable_map_t& values){$/;"	f	namespace:mods::db
load_record	mods/db.cpp	/^int load_record(const std::string& table, const std::string& pk, mutable_map_t& values){$/;"	f	namespace:mods::db
load_record_by_meta	mods/db.cpp	/^int load_record_by_meta(const std::string& table, mutable_map_t* values,mutable_map_t& out_record){$/;"	f	namespace:mods::db
load_room	structs.h	/^	room_vnum load_room;		\/* Which room to place char in		*\/$/;"	m	struct:player_special_data_saved
load_trees	mods/behaviour_tree_impl.cpp	/^	void load_trees(){$/;"	f	namespace:mods::behaviour_tree_impl
load_zones	db.cpp	/^void load_zones(FILE *fl, char *zonename) {$/;"	f
loaded	structs.h	/^	short loaded;$/;"	m	struct:obj_data
location	structs.h	/^	byte location;        \/* Tells which ability to change(APPLY_XXX)*\/$/;"	m	struct:affected_type
location	structs.h	/^	byte location;      \/* Which ability to change (APPLY_XXX) *\/$/;"	m	struct:obj_affected_type
location	structs.h	/^	sh_int location;$/;"	m	struct:obj_file_elem
log	utils.cpp	/^void log(const char* format,...) {$/;"	f
log_death_trap	utils.cpp	/^void log_death_trap(struct char_data *ch) {$/;"	f
log_js_error	mods/js.cpp	/^		void log_js_error(std::string_view error) {$/;"	f	namespace:mods::js
log_zone_error	db.cpp	/^void log_zone_error(zone_rnum zone, int cmd_no, const char *message) {$/;"	f
logfile	comm.cpp	/^FILE *logfile = NULL;		\/* Where to send the log messages. *\/$/;"	v
login	login.cpp	/^namespace login {$/;"	n	file:
login	login.hpp	/^namespace login {$/;"	n
login_time	structs.h	/^		time_t login_time;		\/* when the person connected		*\/$/;"	m	struct:mods::descriptor_data
logon	structs.h	/^	time_t logon;    \/* Time of the last logon (used to calculate played) *\/$/;"	m	struct:time_data
logtypes	act.wizard.cpp	/^const char *logtypes[] = {$/;"	v
long_descr	structs.h	/^	mods::string long_descr;   \/* for 'look'			       *\/$/;"	m	struct:char_player_data
look_at_char	act.informative.cpp	/^void look_at_char(struct char_data *i, struct char_data *ch) {$/;"	f
look_at_room	act.informative.cpp	/^void look_at_room(struct char_data *ch, int ignore_brief) {$/;"	f
look_at_target	act.informative.cpp	/^void look_at_target(struct char_data *ch, char *arg) {$/;"	f
look_in_direction	act.informative.cpp	/^void look_in_direction(struct char_data *ch, int dir) {$/;"	f
look_in_obj	act.informative.cpp	/^void look_in_obj(struct char_data *ch, char *arg) {$/;"	f
loops	mods/loops.cpp	/^namespace mods::loops {$/;"	n	class:mods	file:
loops	mods/loops.hpp	/^namespace mods::loops {$/;"	n	class:mods
los_find	mods/scan.cpp	/^		find_results_t los_find(chptr hunter,chptr hunted){$/;"	f	namespace:mods::scan
los_list_rooms	mods/scan.cpp	/^		void los_list_rooms(chptr hunter,room_list_t & room_list,unsigned depth){$/;"	f	namespace:mods::scan
los_scan	mods/scan.cpp	/^		void los_scan(struct char_data* ch,int depth,vec_player_data* vec_room_list) {$/;"	f	namespace:mods::scan
los_scan_foreach	mods/scan.cpp	/^		void los_scan_foreach(struct char_data* ch,int depth,los_scan_foreach_callback lambda_cb) {$/;"	f	namespace:mods::scan
los_scan_foreach_callback	mods/scan.hpp	/^		typedef std::function<bool (room_rnum,int,vec_player_data)> los_scan_foreach_callback;$/;"	t	namespace:mods::scan
m	random.cpp	45;"	d	file:
m_affected	mods/player.hpp	/^			std::map<int64_t,bool> m_affected;$/;"	m	class:mods::player
m_affected_plr	mods/player.hpp	/^			std::map<int64_t,bool> m_affected_plr;$/;"	m	class:mods::player
m_allocate	mods/string.cpp	/^	void string::m_allocate(){$/;"	f	class:mods::string
m_assertionInfo	mods/catch.hpp	/^			AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder
m_bui_mode	mods/player.hpp	/^			bool m_bui_mode;$/;"	m	class:mods::player
m_cachedToString	mods/catch.hpp	/^					mutable std::string m_cachedToString;$/;"	m	class:Catch::Matchers::Impl::MatcherUntypedBase
m_capture_output	mods/player.hpp	/^			bool         m_capture_output;$/;"	m	class:mods::player
m_captured_output	mods/player.hpp	/^			std::string  m_captured_output;$/;"	m	class:mods::player
m_char_data	mods/ai_state.hpp	/^			struct char_data* m_char_data;$/;"	m	class:mods::ai_state	typeref:struct:mods::ai_state::char_data
m_char_data	mods/drone.hpp	/^			char_data* m_char_data;$/;"	m	class:mods::drone
m_char_data	mods/player.hpp	/^			char_data*   m_char_data;$/;"	m	class:mods::player
m_children	mods/behaviour_tree_node.hpp	/^			children_t  m_children;$/;"	m	struct:mods::behaviour_tree_node
m_class_capability	mods/player.hpp	/^			class_capability_t m_class_capability;$/;"	m	class:mods::player
m_class_info	mods/player.hpp	/^			class_info_t m_class_info;$/;"	m	class:mods::player
m_clear_status	mods/lmdb.hpp	/^		void m_clear_status(){$/;"	f	struct:mods::lmdb::_db_handle
m_closed	mods/lmdb.hpp	/^		bool m_closed;$/;"	m	struct:mods::lmdb::_db_handle
m_context	mods/js.hpp	/^				duk_context* m_context;$/;"	m	struct:mods::js::include
m_count	mods/catch.hpp	/^		std::size_t m_count;$/;"	m	struct:Catch::pluralise
m_cptr	mods/string.hpp	/^			char* m_cptr;$/;"	m	struct:mods::string
m_current_join	mods/sql.hpp	/^			std::string m_current_join;$/;"	m	struct:mods::sql::compositor
m_current_level	mods/jx.hpp	/^			uint32_t m_current_level;$/;"	m	struct:mods::jx::compositor
m_current_page	mods/player.hpp	/^			unsigned int m_current_page;$/;"	m	class:mods::player
m_current_page_fragment	mods/player.hpp	/^			std::string  m_current_page_fragment;$/;"	m	class:mods::player
m_data	mods/catch.hpp	/^			AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder
m_db_id	mods/player.hpp	/^			aligned_int_t m_db_id;$/;"	m	class:mods::player
m_dbi	mods/lmdb.hpp	/^		MDB_dbi	m_dbi;$/;"	m	struct:mods::lmdb::_db_handle
m_dbi_opened	mods/lmdb.hpp	/^		bool m_dbi_opened;$/;"	m	struct:mods::lmdb::_db_handle
m_deallocate	mods/string.cpp	/^	void string::m_deallocate(){$/;"	f	class:mods::string
m_debug	mods/string.hpp	7;"	d
m_desc	mods/player.hpp	/^			std::shared_ptr<mods::descriptor_data> m_desc;$/;"	m	class:mods::player
m_dir	mods/js.hpp	/^				std::string m_dir;$/;"	m	struct:mods::js::include
m_dir	mods/lmdb.hpp	/^		std::string m_dir;$/;"	m	struct:mods::lmdb::_db_handle
m_do_paging	mods/player.hpp	/^			bool         m_do_paging;$/;"	m	class:mods::player
m_env	mods/lmdb.hpp	/^		MDB_env*	m_env;$/;"	m	struct:mods::lmdb::_db_handle
m_env	mods/lmdb.hpp	/^		MDB_env* m_env;$/;"	m	struct:mods::lmdb::transaction_t
m_errors	mods/player-scaffolding.hpp	/^			std::vector<std::string> m_errors;$/;"	m	struct:mods::player_scaffolding
m_executing_js	mods/player.hpp	/^			bool         m_executing_js;$/;"	m	class:mods::player
m_file	mods/js.hpp	/^				std::string m_file;$/;"	m	struct:mods::js::include
m_flags	mods/lmdb.hpp	/^		uint64_t m_flags;$/;"	m	struct:mods::lmdb::_db_handle
m_god_mode	mods/player.hpp	/^			bool m_god_mode;$/;"	m	class:mods::player
m_good	mods/lmdb.hpp	/^		bool m_good;$/;"	m	struct:mods::lmdb::_db_handle
m_imp_mode	mods/player.hpp	/^			bool m_imp_mode;$/;"	m	class:mods::player
m_include_success	mods/js.hpp	/^				bool m_include_success;$/;"	m	struct:mods::js::include
m_info	mods/catch.hpp	/^			AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult
m_iterations	mods/deferred.hpp	/^			uint64_t m_iterations;$/;"	m	class:mods::deferred
m_joins	mods/sql.hpp	/^			std::vector<std::string> m_joins;$/;"	m	struct:mods::sql::compositor
m_jx	mods/jx.hpp	/^			std::string m_jx;$/;"	m	struct:mods::jx::compositor
m_label	mods/catch.hpp	/^		std::string m_label;$/;"	m	struct:Catch::pluralise
m_levels	mods/jx.hpp	/^			std::map<uint32_t,uint32_t> m_levels;$/;"	m	struct:mods::jx::compositor
m_lineInfo	mods/catch.hpp	/^			SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException
m_logic	mods/behaviour_tree_node.hpp	/^			callback_t  m_logic;$/;"	m	struct:mods::behaviour_tree_node
m_mallocd	mods/string.hpp	/^			bool m_mallocd;$/;"	m	struct:mods::string
m_matchers	mods/catch.hpp	/^				std::vector<MatcherBase<ArgT> const*> m_matchers;$/;"	m	struct:Catch::Matchers::Impl::MatchAllOf
m_matchers	mods/catch.hpp	/^				std::vector<MatcherBase<ArgT> const*> m_matchers;$/;"	m	struct:Catch::Matchers::Impl::MatchAnyOf
m_method	mods/catch.hpp	/^			void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase
m_mode	mods/lmdb.hpp	/^		uint16_t m_mode;$/;"	m	struct:mods::lmdb::_db_handle
m_name	mods/chat.hpp	/^			std::string m_name;$/;"	m	struct:mods::mods::chat::channel
m_name	mods/lmdb.hpp	/^		std::string m_name;$/;"	m	struct:mods::lmdb::_db_handle
m_name	mods/player.hpp	/^			std::string	m_name;$/;"	m	class:mods::player
m_node	mods/behaviour_tree.hpp	/^		node m_node;$/;"	m	struct:mods::behaviour_tree
m_node_type	mods/behaviour_tree_node.hpp	/^			node_type_t m_node_type;$/;"	m	struct:mods::behaviour_tree_node
m_p	mods/catch.hpp	/^			T* m_p;$/;"	m	class:Catch::Ptr
m_page	mods/player.hpp	/^			unsigned int m_page;$/;"	m	class:mods::player
m_pages	mods/player.hpp	/^			std::vector<std::string> m_pages;$/;"	m	class:mods::player
m_parts	mods/jx.hpp	/^			std::vector<std::string> m_parts;$/;"	m	struct:mods::jx::compositor
m_passwd	structs.h	/^	std::array<char,max_pwd_length>	m_passwd; \/* character's password      *\/$/;"	m	struct:char_player_data
m_password	mods/player.hpp	/^			std::string m_password;$/;"	m	class:mods::player
m_players	mods/player-scaffolding.hpp	/^			std::vector<std::shared_ptr<mods::player>> m_players;$/;"	m	struct:mods::player_scaffolding
m_pluck	mods/lmdb.hpp	/^		std::vector<std::string> m_pluck;$/;"	m	struct:mods::lmdb::_db_handle
m_private	mods/chat.hpp	/^			bool m_private;$/;"	m	struct:mods::mods::chat::channel
m_private_publishers	mods/chat.hpp	/^			std::vector<std::string> m_private_publishers;$/;"	m	struct:mods::mods::chat::channel
m_q	mods/cron.hpp	/^			std::queue<std::function<void()>> m_q;$/;"	m	class:mods::cron
m_q	mods/deferred.hpp	/^			std::multimap<uint64_t,std::function<void()>> m_q;$/;"	m	class:mods::deferred
m_query	mods/sql.hpp	/^			std::array<std::string, query_parts> m_query;$/;"	m	struct:mods::sql::compositor
m_queue_behaviour	structs.h	/^		queue_behaviour_enum_t m_queue_behaviour;$/;"	m	struct:mods::descriptor_data
m_rc	mods/catch.hpp	/^		mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl
m_realloc	mods/string.cpp	/^	void string::m_realloc(){$/;"	f	class:mods::string
m_resultData	mods/catch.hpp	/^			AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult
m_secs	mods/deferred.hpp	/^			std::multimap<seconds,std::function<void()>> m_secs;$/;"	m	class:mods::deferred
m_set_time	mods/player.cpp	/^	void player::m_set_time(){$/;"	f	class:mods::player
m_shared_ptr	mods/player.hpp	/^			std::shared_ptr<char_data> m_shared_ptr;$/;"	m	class:mods::player
m_shouldDebugBreak	mods/catch.hpp	/^			bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder
m_shouldThrow	mods/catch.hpp	/^			bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder
m_size	mods/string.hpp	/^			std::size_t m_size;$/;"	m	struct:mods::string
m_sql	mods/sql.hpp	/^			std::string m_sql;$/;"	m	struct:mods::sql::compositor
m_state	mods/ai_state.hpp	/^			uint8_t m_state;$/;"	m	class:mods::ai_state
m_status	mods/lmdb.hpp	/^		status_type_t m_status;$/;"	m	struct:mods::lmdb::_db_handle
m_str	mods/string.hpp	/^			std::string m_str;$/;"	m	struct:mods::string
m_str_table	mods/lmdb.hpp	/^		std::string m_str_table;$/;"	m	struct:mods::lmdb::transaction_t
m_stream	mods/catch.hpp	/^			CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder
m_subscribers	mods/chat.hpp	/^			std::vector<socket_t> m_subscribers;$/;"	m	struct:mods::mods::chat::channel
m_table	mods/lmdb.hpp	/^		table_type_t m_table;$/;"	m	struct:mods::lmdb::transaction_t
m_table	mods/sql.hpp	/^			std::string m_table;$/;"	m	struct:mods::sql::compositor
m_tick	mods/deferred.hpp	/^			uint64_t m_tick;$/;"	m	class:mods::deferred
m_time	mods/player.hpp	/^			time_type_t	m_time;$/;"	m	class:mods::player
m_transaction_good	mods/lmdb.hpp	/^		bool m_transaction_good;$/;"	m	struct:mods::lmdb::_db_handle
m_transaction_open	mods/lmdb.hpp	/^		bool m_transaction_open;$/;"	m	struct:mods::lmdb::_db_handle
m_tree_name	mods/behaviour_tree.hpp	/^		std::string m_tree_name;$/;"	m	struct:mods::behaviour_tree
m_tres	mods/cron.hpp	/^			uint64_t m_tres;$/;"	m	class:mods::cron
m_tres	mods/deferred.hpp	/^			uint64_t m_tres;$/;"	m	class:mods::deferred
m_txn	mods/lmdb.hpp	/^		MDB_txn*	m_txn;$/;"	m	struct:mods::lmdb::_db_handle
m_txn_ptr	mods/sql.hpp	/^			T* m_txn_ptr;$/;"	m	struct:mods::sql::compositor
m_type	mods/lmdb.hpp	/^		transact_type_t m_type;$/;"	m	struct:mods::lmdb::transaction_t
m_type	mods/player.hpp	/^			player_type_enum_t m_type;$/;"	m	class:mods::player
m_underlyingMatcher	mods/catch.hpp	/^				MatcherBase<ArgT> const& m_underlyingMatcher;$/;"	m	struct:Catch::Matchers::Impl::MatchNotOf
m_use_pluck	mods/lmdb.hpp	/^		bool m_use_pluck;$/;"	m	struct:mods::lmdb::_db_handle
m_verb	mods/chat.hpp	/^			std::string m_verb;$/;"	m	struct:mods::mods::chat::channel
m_weapon_cooldown	mods/player.hpp	/^			std::array<unsigned long,WEAPON_SET_NUM> m_weapon_cooldown;$/;"	m	class:mods::player
m_weapon_set	mods/player.hpp	/^			weapon_set   m_weapon_set;$/;"	m	class:mods::player
m_what	mods/catch.hpp	/^			std::string m_what;$/;"	m	class:Catch::NotImplementedException
macroName	mods/catch.hpp	/^		std::string macroName;$/;"	m	struct:Catch::AssertionInfo
mag_affects	magic.cpp	/^void mag_affects(int level, struct char_data *ch, struct char_data *victim,$/;"	f
mag_alter_objs	magic.cpp	/^void mag_alter_objs(int level, struct char_data *ch, struct obj_data *obj,$/;"	f
mag_areas	magic.cpp	/^void mag_areas(int level, struct char_data *ch, int spellnum, int savetype) {$/;"	f
mag_assign_spells	mods/hell.hpp	/^	constexpr inline bool mag_assign_spells = false;$/;"	m	namespace:mods::hell
mag_assign_spells	spell_parser.cpp	/^void mag_assign_spells(void) {$/;"	f
mag_creations	magic.cpp	/^void mag_creations(int level, struct char_data *ch, int spellnum) {$/;"	f
mag_damage	magic.cpp	/^int mag_damage(int level, struct char_data *ch, struct char_data *victim,$/;"	f
mag_groups	magic.cpp	/^void mag_groups(int level, struct char_data *ch, int spellnum, int savetype) {$/;"	f
mag_manacost	spell_parser.cpp	/^int mag_manacost(struct char_data *ch, int spellnum) {$/;"	f
mag_masses	magic.cpp	/^void mag_masses(int level, struct char_data *ch, int spellnum, int savetype) {$/;"	f
mag_materials	magic.cpp	/^int mag_materials(struct char_data *ch, int item0, int item1, int item2,$/;"	f
mag_objectmagic	spell_parser.cpp	/^void mag_objectmagic(struct char_data *ch, struct obj_data *obj,$/;"	f
mag_points	magic.cpp	/^void mag_points(int level, struct char_data *ch, struct char_data *victim,$/;"	f
mag_savingthrow	magic.cpp	/^int mag_savingthrow(struct char_data *ch, int type, int modifier) {$/;"	f
mag_summon_fail_msgs	magic.cpp	/^const char *mag_summon_fail_msgs[] = {$/;"	v
mag_summon_msgs	magic.cpp	/^const char *mag_summon_msgs[] = {$/;"	v
mag_summons	magic.cpp	/^void mag_summons(int level, struct char_data *ch, struct obj_data *obj,$/;"	f
mag_unaffects	magic.cpp	/^void mag_unaffects(int level, struct char_data *ch, struct char_data *victim,$/;"	f
magic_user	spec_assign.cpp	/^SPECIAL(magic_user);$/;"	v
magic_user	spec_procs.cpp	/^SPECIAL(magic_user);$/;"	v
mail_index	mail.cpp	/^mail_index_type *mail_index = NULL;	\/* list of recs in the mail file  *\/$/;"	v
mail_index_type	mail.h	/^typedef struct mail_index_type_d mail_index_type;$/;"	t	typeref:struct:mail_index_type_d
mail_index_type_d	mail.h	/^struct mail_index_type_d {$/;"	s
mail_recip_ok	mail.cpp	/^int mail_recip_ok(const char *name) {$/;"	f
mail_time	mail.h	/^	time_t mail_time;		\/* when was the letter mailed?		*\/$/;"	m	struct:header_data_type
mail_to	structs.h	/^		long	mail_to;		\/* name for mail system			*\/$/;"	m	struct:mods::descriptor_data
main	bsd-snprintf.cpp	/^main(void) {$/;"	f
main	comm.cpp	/^int main(int argc, char **argv) {$/;"	f
makeSafe	mods/catch.hpp	/^			static type makeSafe(bool value) {$/;"	f	class:Catch::SafeBool
make_corpse	fight.cpp	/^void make_corpse(struct char_data *ch) {$/;"	f
make_prompt	comm.cpp	/^char *make_prompt(mods::descriptor_data &d) {$/;"	f
mana	mods/player.hpp	/^			sh_int& mana() {$/;"	f	class:mods::player
mana	structs.h	/^	sh_int mana;$/;"	m	struct:char_point_data
mana_change	spells.h	/^	int mana_change;	\/* Change in mana used by spell from lev to lev *\/$/;"	m	struct:spell_info_type
mana_gain	limits.cpp	/^int mana_gain(struct char_data *ch) {$/;"	f
mana_max	spells.h	/^	int mana_max;	\/* Max amount of mana used by a spell (lowest lev) *\/$/;"	m	struct:spell_info_type
mana_min	spells.h	/^	int mana_min;	\/* Min amount of mana used by a spell (highest lev) *\/$/;"	m	struct:spell_info_type
map_object_list	structs.h	/^typedef std::map<obj_vnum,obj_data*> map_object_list;$/;"	t
mapped	config.hpp	/^	static std::map<std::string,std::string> mapped;$/;"	m	namespace:config
maps	mods/util-map.hpp	/^		namespace maps {$/;"	n	namespace:mods::util
mask	mods/weapon.hpp	/^		struct mask {$/;"	s	namespace:mods::weapon
mask_type	mods/player.hpp	/^		enum mask_type { SMG, SNIPE, SHOTGUN, GRENADE };$/;"	g	namespace:mods::weapon
master	structs.h	/^	char_data *master;             \/* Who is char following?        *\/$/;"	m	struct:char_data
max	mods/util-map.hpp	/^			Tval max(std::map<Tkey,Tval>& m) {$/;"	f	namespace:mods::util::maps
max_bad_pws	config.cpp	/^int max_bad_pws = 3;$/;"	v
max_exp_gain	config.cpp	/^int max_exp_gain = 100000;	\/* max gainable per kill *\/$/;"	v
max_exp_loss	config.cpp	/^int max_exp_loss = 500000;	\/* max losable per death *\/$/;"	v
max_filesize	config.cpp	/^int max_filesize = 50000;$/;"	v
max_hit	structs.h	/^	sh_int max_hit;      \/* Max hit for PC\/NPC                      *\/$/;"	m	struct:char_point_data
max_hp	mods/player.hpp	/^			sh_int& max_hp() {$/;"	f	class:mods::player
max_mana	mods/player.hpp	/^			sh_int& max_mana() {$/;"	f	class:mods::player
max_mana	structs.h	/^	sh_int max_mana;     \/* Max mana for PC\/NPC			   *\/$/;"	m	struct:char_point_data
max_move	mods/player.hpp	/^			sh_int& max_move() {$/;"	f	class:mods::player
max_move	structs.h	/^	sh_int max_move;     \/* Max move for PC\/NPC                     *\/$/;"	m	struct:char_point_data
max_npc_corpse_time	config.cpp	/^int max_npc_corpse_time = 5;$/;"	v
max_obj_save	config.cpp	/^int max_obj_save = 30;$/;"	v
max_pc_corpse_time	config.cpp	/^int max_pc_corpse_time = 10;$/;"	v
max_players	comm.cpp	/^int max_players = 0;		\/* max descriptors available *\/$/;"	v
max_playing	config.cpp	/^int max_playing = 300;$/;"	v
max_pwd_length	structs.h	/^	constexpr static unsigned max_pwd_length = MAX_PWD_LENGTH+1;$/;"	m	struct:char_player_data
max_skills	structs.h	/^	constexpr static unsigned max_skills = MAX_SKILLS;$/;"	m	struct:player_special_data_saved
max_str	structs.h	/^		size_t max_str;	        \/*		-			*\/$/;"	m	struct:mods::descriptor_data
max_tongue	structs.h	/^	constexpr static unsigned max_tongue = MAX_TONGUE;$/;"	m	struct:player_special_data_saved
mayor	spec_assign.cpp	/^SPECIAL(mayor);$/;"	v
mayor	spec_procs.cpp	/^SPECIAL(mayor);$/;"	v
member_of_royal_guard	castle.cpp	/^int member_of_royal_guard(struct char_data *chChar) {$/;"	f
member_of_staff	castle.cpp	/^int member_of_staff(struct char_data *chChar) {$/;"	f
memory	structs.h	/^	memory_rec_t memory;$/;"	m	struct:mob_special_data
memory_rec	structs.h	/^typedef struct memory_rec_struct memory_rec;$/;"	t	typeref:struct:memory_rec_struct
memory_rec_struct	structs.h	/^struct memory_rec_struct {$/;"	s
memory_rec_t	structs.h	/^typedef std::set<char_data*> memory_rec_t;$/;"	t
message	mods/catch.hpp	/^		std::string message;$/;"	m	struct:Catch::AssertionResultData
message_buy	shop.h	/^	char	*message_buy;		\/* Message when player buys item	*\/$/;"	m	struct:shop_data
message_len	boards.h	/^	int	message_len;  \/* size of message text (for file write) *\/$/;"	m	struct:board_msginfo
message_list	structs.h	/^struct message_list {$/;"	s
message_sell	shop.h	/^	char	*message_sell;		\/* Message when player sells item	*\/$/;"	m	struct:shop_data
message_type	structs.h	/^struct message_type {$/;"	s
meta	mods/meta_utils.cpp	/^	constexpr static const char* meta = "meta";$/;"	m	namespace:mods::meta_utils	file:
meta_utils	mods/meta_utils.cpp	/^namespace mods::meta_utils {$/;"	n	class:mods	file:
meta_utils	mods/meta_utils.hpp	/^namespace mods::meta_utils {$/;"	n	class:mods
min_level	spells.h	/^	int min_level[NUM_CLASSES];$/;"	m	struct:spell_info_type
min_position	spells.h	/^	byte min_position;	\/* Position for caster	 *\/$/;"	m	struct:spell_info_type
min_rent_cost	config.cpp	/^int min_rent_cost = 100;$/;"	v
min_victim_position	act.social.cpp	/^	int min_victim_position;	\/* Position of victim *\/$/;"	m	struct:social_messg	file:
min_wizlist_lev	config.cpp	/^int min_wizlist_lev = LVL_GOD;$/;"	v
mini_mud	db.cpp	/^int mini_mud = 0;		\/* mini-mud mode?		 *\/$/;"	v
minimum_level	interpreter.h	/^	sh_int minimum_level;$/;"	m	struct:command_info
minimum_position	interpreter.h	/^	byte minimum_position;$/;"	m	struct:command_info
miss_att	structs.h	/^	sh_int miss_att;$/;"	m	struct:dex_app_type
miss_msg	structs.h	/^	struct msg_type miss_msg;	\/* messages when miss			*\/$/;"	m	struct:message_type	typeref:struct:message_type::msg_type
missing_cash1	shop.h	/^	char	*missing_cash1;		\/* Message if keeper hasn't got cash	*\/$/;"	m	struct:shop_data
missing_cash2	shop.h	/^	char	*missing_cash2;		\/* Message if player hasn't got cash	*\/$/;"	m	struct:shop_data
mob	structs.h	/^	mob_pavements_t mob;$/;"	m	struct:zone_pavement_t
mob_act_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,19> mob_act_flags = { {$/;"	m	namespace:mods::builder	file:
mob_death_trigger	mods/js.cpp	/^		static duk_ret_t mob_death_trigger(duk_context *ctx) {$/;"	f	namespace:mods::js
mob_has_tree	mods/behaviour_tree_impl.hpp	/^		constexpr int mob_has_tree = ((1 << 19));$/;"	m	namespace:mods::behaviour_tree_impl
mob_index	db.cpp	/^std::vector<index_data> mob_index;	\/* index table for mobile file	 *\/$/;"	v
mob_list	db.cpp	/^std::deque<char_data> mob_list;		\/* list of mobs *\/$/;"	v
mob_list_t	mods/behaviour_tree_impl.hpp	/^		typedef std::vector<argument_type> mob_list_t;$/;"	t	namespace:mods::behaviour_tree_impl
mob_pavements_t	structs.h	/^	typedef std::vector<mob_vnum> mob_pavements_t;$/;"	t	struct:zone_pavement_t
mob_proto	db.cpp	/^std::vector<char_data> mob_proto;	\/* prototypes for mobs		 *\/$/;"	v
mob_rnum	structs.h	/^typedef IDXTYPE mob_rnum;$/;"	t
mob_special_data	structs.h	/^struct mob_special_data {$/;"	s
mob_specials	structs.h	/^	mob_special_data mob_specials;	\/* NPC specials		  *\/$/;"	m	struct:char_data
mob_vnum	structs.h	/^typedef IDXTYPE mob_vnum;$/;"	t
mobile_activity	globals.cpp	/^		int mobile_activity(char_data* ch) {$/;"	f	namespace:mods::globals
mobile_activity	mobact.cpp	/^void mobile_activity(void) {$/;"	f
mobs_with_trees	mods/behaviour_tree_impl.cpp	/^	mob_list_t mobs_with_trees;$/;"	m	namespace:mods::behaviour_tree_impl	file:
mode	house.h	/^	int mode;			\/* mode of ownership		*\/$/;"	m	struct:house_control_rec
modifier	structs.h	/^	sbyte modifier;       \/* This is added to apropriate ability     *\/$/;"	m	struct:affected_type
modifier	structs.h	/^	sbyte modifier;     \/* How much it changes by              *\/$/;"	m	struct:obj_affected_type
modify_affected_flags	mods/js.cpp	/^		static duk_ret_t modify_affected_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
modify_plr_flags	mods/js.cpp	/^		static duk_ret_t modify_plr_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
mods	globals.cpp	/^namespace mods {$/;"	n	file:
mods	globals.hpp	/^namespace mods {$/;"	n
mods	mods/ai_state.cpp	/^namespace mods {$/;"	n	file:
mods	mods/ai_state.hpp	/^namespace mods {$/;"	n
mods	mods/ban_system.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree_impl.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree_node.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree_status.hpp	/^namespace mods {$/;"	n
mods	mods/cron.hpp	/^namespace mods {$/;"	n
mods	mods/crypto.hpp	/^namespace mods {$/;"	n
mods	mods/deferred.cpp	/^namespace mods {$/;"	n	file:
mods	mods/deferred.hpp	/^namespace mods {$/;"	n
mods	mods/drone.cpp	/^namespace mods {$/;"	n	file:
mods	mods/drone.hpp	/^namespace mods {$/;"	n
mods	mods/js.cpp	/^namespace mods {$/;"	n	file:
mods	mods/js.hpp	/^namespace mods {$/;"	n
mods	mods/player-scaffolding.cpp	/^namespace mods {$/;"	n	file:
mods	mods/player-scaffolding.hpp	/^namespace mods {$/;"	n
mods	mods/player.cpp	/^namespace mods {$/;"	n	file:
mods	mods/player.hpp	/^namespace mods {$/;"	n
mods	mods/prefs.cpp	/^namespace mods {$/;"	n	file:
mods	mods/prefs.hpp	/^namespace mods {$/;"	n
mods	mods/projectile.cpp	/^namespace mods {$/;"	n	file:
mods	mods/projectile.hpp	/^namespace mods {$/;"	n
mods	mods/quests.cpp	/^namespace mods {$/;"	n	file:
mods	mods/quests.hpp	/^namespace mods {$/;"	n
mods	mods/scan.cpp	/^namespace mods {$/;"	n	file:
mods	mods/scan.hpp	/^namespace mods {$/;"	n
mods	mods/string.cpp	/^namespace mods {$/;"	n	file:
mods	mods/string.hpp	/^namespace mods {$/;"	n
mods	mods/util-conf.hpp	/^namespace mods {$/;"	n
mods	mods/util-map.hpp	/^namespace mods {$/;"	n
mods	mods/util.cpp	/^namespace mods {$/;"	n	file:
mods	mods/weapon.hpp	/^namespace mods {$/;"	n
mods	structs.cpp	/^namespace mods{$/;"	n	file:
mods	structs.h	/^namespace mods {$/;"	n
mods	utils.h	/^namespace mods{$/;"	n
money_desc	handler.cpp	/^const char *money_desc(int amount) {$/;"	f
month	structs.h	/^	int hours, day, month;$/;"	m	struct:time_info_data
month_name	constants.cpp	/^const char *month_name[] = {$/;"	v
month_name	constants.hpp	/^const char *month_name[] = {$/;"	v
mortal_start	config.cpp	/^		room_type_t mortal_start(){$/;"	f	namespace:config::rooms
mortal_start_room	config.cpp	/^config::rooms::room_type_t mortal_start_room = 27089;$/;"	v
motd	db.cpp	/^char *motd = NULL;		\/* message of the day - mortals *\/$/;"	v
move	mods/player.hpp	/^			sh_int& move() {$/;"	f	class:mods::player
move	structs.h	/^	sh_int move;$/;"	m	struct:char_point_data
move_gain	limits.cpp	/^int move_gain(struct char_data *ch) {$/;"	f
movement_loss	constants.cpp	/^int movement_loss[] = {$/;"	v
movement_loss	constants.hpp	/^int movement_loss[] =$/;"	v
mpub_aggro	mods/ai_state.hpp	/^			int32_t mpub_aggro;$/;"	m	class:mods::ai_state
mpub_dead	mods/ai_state.hpp	/^			uint32_t mpub_dead;$/;"	m	class:mods::ai_state
mpub_intelligence	mods/ai_state.hpp	/^			int32_t mpub_intelligence;$/;"	m	class:mods::ai_state
mpub_lenient	mods/ai_state.hpp	/^			int32_t mpub_lenient;$/;"	m	class:mods::ai_state
mpub_stunned	mods/ai_state.hpp	/^			uint32_t mpub_stunned;$/;"	m	class:mods::ai_state
mpub_suspicious	mods/ai_state.hpp	/^			int32_t mpub_suspicious;$/;"	m	class:mods::ai_state
msg	structs.h	/^	struct message_type *msg;	\/* List of messages.			*\/$/;"	m	struct:message_list	typeref:struct:message_list::message_type
msg_index	boards.cpp	/^struct board_msginfo msg_index[NUM_OF_BOARDS][MAX_BOARD_MESSAGES];$/;"	v	typeref:struct:board_msginfo
msg_storage	boards.cpp	/^char *msg_storage[INDEX_SIZE];$/;"	v
msg_storage_taken	boards.cpp	/^int msg_storage_taken[INDEX_SIZE];$/;"	v
msg_type	structs.h	/^struct msg_type {$/;"	s
mud_time_passed	utils.cpp	/^struct time_info_data *mud_time_passed(time_t t2, time_t t1) {$/;"	f
mud_time_to_secs	utils.cpp	/^time_t mud_time_to_secs(struct time_info_data *now) {$/;"	f
mudlog	utils.cpp	/^void mudlog(int type, int level, int file, const char *str, ...) {$/;"	f
my_signal	comm.cpp	/^sigfunc *my_signal(int signo, sigfunc *func) {$/;"	f
my_signal	comm.cpp	2103;"	d	file:
name	db.h	/^	char	*name;		    \/* name of this zone                  *\/$/;"	m	struct:zone_data
name	db.h	/^	char	name[MAX_NAME_LENGTH+1];$/;"	m	struct:ban_list_element
name	db.h	/^	mods::string name;$/;"	m	struct:player_index_element
name	mods/behaviour_tree.hpp	/^		std::string_view name() const { return m_tree_name; }$/;"	f	struct:mods::behaviour_tree
name	mods/catch.hpp	/^		const char* name;$/;"	m	struct:Catch::NameAndDesc
name	mods/drone.hpp	/^			const char* name() {$/;"	f	class:mods::drone
name	mods/player.hpp	/^			std::string& name() {$/;"	f	class:mods::player
name	spells.h	/^	const char *name;	\/* Input size not limited. Originates from string constants. *\/$/;"	m	struct:spell_info_type
name	structs.h	/^	char	*name;                    \/* Title of object :get etc.        *\/$/;"	m	struct:obj_data
name	structs.h	/^	mods::string	name;                  \/* Rooms name 'You are ...'           *\/$/;"	m	struct:room_data
name	structs.h	/^	mods::string name;	       \/* PC \/ NPC s name (kill ...  )         *\/$/;"	m	struct:char_player_data
name	structs.h	/^	mods::string name;$/;"	m	struct:char_file_u
name_from_drinkcon	act.item.cpp	/^void name_from_drinkcon(struct obj_data *obj) {$/;"	f
name_to_drinkcon	act.item.cpp	/^void name_to_drinkcon(struct obj_data *obj, int type) {$/;"	f
nameserver_is_slow	config.cpp	/^int nameserver_is_slow = NO;$/;"	v
namify	mods/prefs.cpp	/^	std::string prefs::namify(const std::string& key,struct char_data* c) {$/;"	f	class:mods::prefs
nanny	interpreter.cpp	/^void nanny(std::shared_ptr<mods::player> p, char * in_arg) {$/;"	f
negate	mods/catch.hpp	/^		void negate(bool parenthesize) {$/;"	f	struct:Catch::AssertionResultData
negated	mods/catch.hpp	/^		bool negated;$/;"	m	struct:Catch::AssertionResultData
net_cost_per_diem	structs.h	/^	int	net_cost_per_diem;$/;"	m	struct:rent_info
new_blank_character	mods/builder.cpp	/^	char_data new_blank_character(bool npc = false) {$/;"	f	namespace:mods::builder
new_context	mods/js.cpp	/^		duk_context* new_context() {$/;"	f	namespace:mods::js
new_descriptor	comm.cpp	/^int new_descriptor(socket_t s) {$/;"	f
new_npc	mods/builder.cpp	/^	char_data new_npc() {$/;"	f	namespace:mods::builder
new_room	mods/builder.cpp	/^	struct room_data new_room(struct char_data* ch,int direction) {$/;"	f	namespace:mods::builder
new_txn	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::new_txn(){$/;"	f	class:mods::lmdb::_db_handle
news	db.cpp	/^char *news = NULL;		\/* mud news			 *\/$/;"	v
news	spell_parser.cpp	/^	const char *news;$/;"	m	struct:syllable	file:
next	db.h	/^	struct ban_list_element *next;$/;"	m	struct:ban_list_element	typeref:struct:ban_list_element::ban_list_element
next	db.h	/^	struct reset_q_element *next;$/;"	m	struct:reset_q_element	typeref:struct:reset_q_element::reset_q_element
next	graph.cpp	/^	struct bfs_queue_struct *next;$/;"	m	struct:bfs_queue_struct	typeref:struct:bfs_queue_struct::bfs_queue_struct	file:
next	interpreter.h	/^	struct alias_data *next;$/;"	m	struct:alias_data	typeref:struct:alias_data::alias_data
next	mail.h	/^	struct mail_index_type_d *next;	\/* link to next one		*\/$/;"	m	struct:mail_index_type_d	typeref:struct:mail_index_type_d::mail_index_type_d
next	mail.h	/^	struct position_list_type_d *next;$/;"	m	struct:position_list_type_d	typeref:struct:position_list_type_d::position_list_type_d
next	structs.h	/^	char_data *next;             \/* For either monster or ppl-list  *\/$/;"	m	struct:char_data
next	structs.h	/^	struct affected_type *next;$/;"	m	struct:affected_type	typeref:struct:affected_type::affected_type
next	structs.h	/^	struct extra_descr_data *next; \/* Next in list                     *\/$/;"	m	struct:extra_descr_data	typeref:struct:extra_descr_data::extra_descr_data
next	structs.h	/^	struct follow_type *next;$/;"	m	struct:follow_type	typeref:struct:follow_type::follow_type
next	structs.h	/^	struct memory_rec_struct *next;$/;"	m	struct:memory_rec_struct	typeref:struct:memory_rec_struct::memory_rec_struct
next	structs.h	/^	struct message_type *next;	\/* to next messages of this kind.	*\/$/;"	m	struct:message_type	typeref:struct:message_type::message_type
next	structs.h	/^	struct obj_data *next;         \/* For the object list              *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::obj_data
next	structs.h	/^	struct txt_block *next;$/;"	m	struct:txt_block	typeref:struct:txt_block::txt_block
next_block	mail.h	/^	long	next_block;		\/* if header block, link to next block	*\/$/;"	m	struct:header_data_type
next_combat_list	fight.cpp	/^struct char_data *next_combat_list = NULL;$/;"	v	typeref:struct:char_data
next_content	structs.h	/^	struct obj_data *next_content; \/* For 'contains' lists             *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::obj_data
next_fighting	structs.h	/^	char_data *next_fighting;    \/* For fighting list               *\/$/;"	m	struct:char_data
next_in_room	structs.h	/^	char_data *next_in_room;     \/* For room->people - list         *\/$/;"	m	struct:char_data
next_page	modify.cpp	/^char *next_page(char *str) {$/;"	f
nitems	structs.h	/^	int	nitems;$/;"	m	struct:rent_info
no_mail	db.cpp	/^int no_mail = 0;		\/* mail disabled?		 *\/$/;"	v
no_rent_check	db.cpp	/^int no_rent_check = 0;		\/* skip rent check on boot?	 *\/$/;"	v
no_specials	comm.cpp	/^int no_specials = 0;		\/* Suppress special routines *\/$/;"	v
no_such_item1	shop.h	/^	char	*no_such_item1;		\/* Message if keeper hasn't got an item	*\/$/;"	m	struct:shop_data
no_such_item2	shop.h	/^	char	*no_such_item2;		\/* Message if player hasn't got an item	*\/$/;"	m	struct:shop_data
node_type_t	mods/behaviour_tree_node.hpp	/^		enum node_type_t { SELECTOR, SEQUENCE, LEAF };$/;"	g	struct:mods::behaviour_tree_node
nonblock	comm.cpp	/^void nonblock(socket_t s) {$/;"	f
not_found	act.social.cpp	/^	char *not_found;$/;"	m	struct:social_messg	file:
npc_class_types	constants.cpp	/^const char *npc_class_types[] = {$/;"	v
npc_class_types	constants.hpp	/^const char *npc_class_types[] = {$/;"	v
npc_steal	spec_procs.cpp	/^void npc_steal(struct char_data *ch, struct char_data *victim) {$/;"	f
nr	structs.h	/^	mob_rnum nr;                          \/* Mob's rnum			  *\/$/;"	m	struct:char_data
null_time	comm.cpp	/^struct timeval null_time;	\/* zero-valued time structure *\/$/;"	v	typeref:struct:timeval
num_directions	mods/scan.hpp	/^		constexpr unsigned num_directions = 6;$/;"	m	namespace:mods::scan
num_followers_charmed	utils.cpp	/^int num_followers_charmed(struct char_data *ch) {$/;"	f
num_invalid	ban.cpp	/^int num_invalid = 0;$/;"	v
num_of_guests	house.h	/^	int num_of_guests;		\/* how many guests for house	*\/$/;"	m	struct:house_control_rec
num_of_houses	house.cpp	/^int num_of_houses = 0;$/;"	v
num_of_msgs	boards.cpp	/^int num_of_msgs[NUM_OF_BOARDS];$/;"	v
num_pc_in_room	utils.cpp	/^int num_pc_in_room(struct room_data *room) {$/;"	f
num_type_t	db.h	/^} num_type_t;$/;"	t	typeref:enum:__anon1
number	db.h	/^	zone_vnum number;	    \/* virtual number of this zone	  *\/$/;"	m	struct:zone_data
number	structs.h	/^	int		number;	\/* number of existing units of this mob\/obj	*\/$/;"	m	struct:index_data
number	structs.h	/^	room_vnum number;		\/* Rooms number	(vnum)		      *\/$/;"	m	struct:room_data
number_of_attacks	structs.h	/^	int	number_of_attacks;	\/* How many attack messages to chose from. *\/$/;"	m	struct:message_list
obj	structs.h	/^	obj_pavements_t obj;$/;"	m	struct:zone_pavement_t
obj_affected_type	structs.h	/^struct obj_affected_type {$/;"	s
obj_data	structs.h	/^struct obj_data {$/;"	s
obj_file_elem	structs.h	/^struct obj_file_elem {$/;"	s
obj_flag_data	structs.h	/^struct obj_flag_data {$/;"	s
obj_flags	structs.h	/^	struct obj_flag_data obj_flags;\/* Object information               *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::obj_flag_data
obj_from_char	handler.cpp	/^void obj_from_char(struct obj_data *object) {$/;"	f
obj_from_obj	handler.cpp	/^void obj_from_obj(struct obj_data *obj) {$/;"	f
obj_from_room	handler.cpp	/^void obj_from_room(struct obj_data *object) {$/;"	f
obj_index	db.cpp	/^std::vector<index_data> obj_index;	\/* index table for object file	 *\/$/;"	v
obj_map	globals.cpp	/^		map_object_list obj_map;$/;"	m	namespace:mods::globals	file:
obj_pavements_t	structs.h	/^	typedef std::vector<obj_vnum> obj_pavements_t;$/;"	t	struct:zone_pavement_t
obj_proto	db.cpp	/^std::vector<obj_data> obj_proto;	\/* prototypes for objs		 *\/$/;"	v
obj_rnum	structs.h	/^typedef IDXTYPE obj_rnum;$/;"	t
obj_to_char	handler.cpp	/^void obj_to_char(struct obj_data *object, struct char_data *ch) {$/;"	f
obj_to_obj	handler.cpp	/^void obj_to_obj(struct obj_data *obj, struct obj_data *obj_to) {$/;"	f
obj_to_room	handler.cpp	/^void obj_to_room(struct obj_data *object, room_rnum room) {$/;"	f
obj_uuid	globals.cpp	/^		uuid_t obj_uuid() {$/;"	f	namespace:mods::globals
obj_vnum	structs.h	/^typedef IDXTYPE obj_vnum;$/;"	t
object	mods/object.hpp	/^namespace mods::object {$/;"	n	class:mods
object_end	mods/jx.hpp	/^			compositor& object_end() {$/;"	f	struct:mods::jx::compositor
object_list	db.cpp	/^std::deque<obj_data> object_list;	\/* list of objs	 *\/$/;"	v
object_list_new_owner	handler.cpp	/^void object_list_new_owner(struct obj_data *list, struct char_data *ch) {$/;"	f
object_start	mods/jx.hpp	/^			compositor& object_start(const std::string& key) {$/;"	f	struct:mods::jx::compositor
ok_damage_shopkeeper	shop.cpp	/^int ok_damage_shopkeeper(struct char_data *ch, struct char_data *victim) {$/;"	f
ok_pick	act.movement.cpp	/^	int ok_pick(struct char_data *ch, obj_vnum keynum, int pickproof, int scmd) {$/;"	f
ok_shop_room	shop.cpp	/^int ok_shop_room(int shop_nr, room_vnum room) {$/;"	f
olc_bitvector	olc.cpp	/^void olc_bitvector(int *bv, const char **names, char *arg) {$/;"	f
olc_ch	olc.cpp	/^struct char_data *olc_ch;$/;"	v	typeref:struct:char_data
olc_commands	olc.cpp	/^const char *olc_commands[] = {$/;"	v
olc_interpreter	olc.cpp	/^void olc_interpreter(void *targ, int mode, char *arg) {$/;"	f
olc_modes	olc.cpp	/^const char *olc_modes[] = {$/;"	v
olc_set_show	olc.cpp	/^void olc_set_show(struct char_data *ch, int olc_mode, char *arg) {$/;"	f
olc_string	olc.cpp	/^void olc_string(char **string, size_t maxlen, char *arg) {$/;"	f
on	mods/sql.hpp	/^			compositor<T>& on(std::string_view lhs,$/;"	f	struct:mods::sql::compositor
one_argument	interpreter.cpp	/^char *one_argument(char *argument, char *first_arg) {$/;"	f
one_argument	interpreter.cpp	/^char *one_argument(char *argument, char *first_arg,unsigned int max_char) {$/;"	f
one_word	interpreter.cpp	/^char *one_word(char *argument, char *first_arg) {$/;"	f
opCast	mods/catch.hpp	/^		inline T& opCast(T const& t) {$/;"	f	namespace:Catch::Internal
opCast	mods/catch.hpp	/^		inline std::nullptr_t opCast(std::nullptr_t) {$/;"	f	namespace:Catch::Internal
op_and	mods/sql.hpp	/^			compositor<T>& op_and(str_object lhs,$/;"	f	struct:mods::sql::compositor
op_or	mods/sql.hpp	/^			compositor<T>& op_or(str_object lhs,$/;"	f	struct:mods::sql::compositor
open	mods/lmdb.cpp	/^	bool _db_handle::open(){$/;"	f	class:mods::lmdb::_db_handle
open1	shop.h	/^	int	 open1, open2;		\/* When does the shop open?		*\/$/;"	m	struct:shop_data
open2	shop.h	/^	int	 open1, open2;		\/* When does the shop open?		*\/$/;"	m	struct:shop_data
open_dbi	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::open_dbi(){$/;"	f	class:mods::lmdb::_db_handle
open_logfile	comm.cpp	/^int open_logfile(const char *filename, FILE *stderr_fp) {$/;"	f
operator !	mods/catch.hpp	/^			MatchNotOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator !() const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator !	mods/catch.hpp	/^			bool operator !() const {$/;"	f	class:Catch::Ptr
operator &&	mods/catch.hpp	/^				MatchAllOf<ArgT>& operator && (MatcherBase<ArgT> const& other) {$/;"	f	struct:Catch::Matchers::Impl::MatchAllOf
operator &&	mods/catch.hpp	/^			MatchAllOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator && (MatcherBase const& other) const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator *	mods/catch.hpp	/^			T& operator*() const {$/;"	f	class:Catch::Ptr
operator *	mods/string.hpp	/^		const char* operator*(){ return m_str.c_str(); }$/;"	f	struct:mods::string
operator +	mods/catch.hpp	/^		std::string operator+() {$/;"	f	struct:Catch::StreamEndStop
operator +	mods/catch.hpp	/^	T const& operator + (T const& value, StreamEndStop) {$/;"	f	namespace:Catch
operator ->	mods/catch.hpp	/^			T* operator->() const {$/;"	f	class:Catch::Ptr
operator <<	mods/ai_state.hpp	/^			ai_state& operator<<(const state& m) {$/;"	f	class:mods::ai_state
operator <<	mods/catch.hpp	/^			ResultBuilder& operator << (T const& value) {$/;"	f	class:Catch::ResultBuilder
operator <<	mods/cron.hpp	/^			cron& operator<<(const char* m) {$/;"	f	class:mods::cron
operator <<	mods/cron.hpp	/^			cron& operator<<(const std::string m) {$/;"	f	class:mods::cron
operator <<	mods/cron.hpp	/^			cron& operator<<(int m) {$/;"	f	class:mods::cron
operator <<	mods/deferred.hpp	/^			deferred& operator<<(const char* m) {$/;"	f	class:mods::deferred
operator <<	mods/deferred.hpp	/^			deferred& operator<<(const std::string m) {$/;"	f	class:mods::deferred
operator <<	mods/deferred.hpp	/^			deferred& operator<<(int m) {$/;"	f	class:mods::deferred
operator <<	mods/drone.hpp	/^			drone& operator<<(const char* m) {$/;"	f	class:mods::drone
operator <<	mods/drone.hpp	/^			drone& operator<<(const std::string m) {$/;"	f	class:mods::drone
operator <<	mods/drone.hpp	/^			drone& operator<<(int m) {$/;"	f	class:mods::drone
operator <<	mods/player.hpp	/^			player& operator<<(const char* m) {$/;"	f	class:mods::player
operator <<	mods/player.hpp	/^			player& operator<<(const std::string& m) {$/;"	f	class:mods::player
operator <<	mods/player.hpp	/^			player& operator<<(int m) {$/;"	f	class:mods::player
operator =	mods/catch.hpp	/^			Ptr& operator = (Ptr const& other) {$/;"	f	class:Catch::Ptr
operator =	mods/catch.hpp	/^			Ptr& operator = (T* p) {$/;"	f	class:Catch::Ptr
operator =	mods/catch.hpp	/^		CopyableStream& operator=(CopyableStream const& other) {$/;"	f	struct:Catch::CopyableStream
operator =	mods/string.cpp	/^	string& string::operator=(char* other){$/;"	f	class:mods::string
operator =	mods/string.cpp	/^	string& string::operator=(const char* other){$/;"	f	class:mods::string
operator =	mods/string.cpp	/^	string& string::operator=(const std::string & other){$/;"	f	class:mods::string
operator =	mods/string.cpp	/^	string& string::operator=(string other){$/;"	f	class:mods::string
operator SafeBool::type	mods/catch.hpp	/^			operator SafeBool::type() const {$/;"	f	class:Catch::Ptr
operator bool	mods/string.hpp	/^		operator bool() const { return m_str.length(); }$/;"	f	struct:mods::string
operator bool	structs.h	/^		operator bool() const {$/;"	f	struct:mods::descriptor_data
operator char*	mods/string.hpp	/^		operator char*() const { return const_cast<char*>(c_str()); }$/;"	f	struct:mods::string
operator chdata_ptr	mods/player.hpp	/^			operator chdata_ptr() const {$/;"	f	class:mods::player
operator const char*	mods/string.hpp	/^		operator const char*() const { return m_str.length() == 0 ? nullptr : m_str.c_str(); }$/;"	f	struct:mods::string
operator std::string	mods/string.hpp	/^		explicit operator std::string() const { return m_str; }$/;"	f	struct:mods::string
operator |	mods/catch.hpp	/^	inline ResultDisposition::Flags operator | (ResultDisposition::Flags lhs, ResultDisposition::Flags rhs) {$/;"	f	namespace:Catch
operator ||	mods/catch.hpp	/^				MatchAnyOf<ArgT>& operator || (MatcherBase<ArgT> const& other) {$/;"	f	struct:Catch::Matchers::Impl::MatchAnyOf
operator ||	mods/catch.hpp	/^			MatchAnyOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator || (MatcherBase const& other) const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator_str	shop.cpp	/^const char *operator_str[] = {$/;"	v
opposite_dir	globals.cpp	/^		int opposite_dir(int dir) {$/;"	f	namespace:mods::globals
org	spell_parser.cpp	/^	const char *org;$/;"	m	struct:syllable	file:
original	structs.h	/^		char_data *original;    \/** FIXME: turn to mods::player *\/$/;"	m	struct:mods::descriptor_data
oss	mods/catch.hpp	/^		std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream
other	mods/catch.hpp	/^		SourceLineInfo(SourceLineInfo const& other)          = default;$/;"	m	struct:Catch::SourceLineInfo
others_auto	act.social.cpp	/^	char *others_auto;$/;"	m	struct:social_messg	file:
others_found	act.social.cpp	/^	char *others_found;$/;"	m	struct:social_messg	file:
others_no_arg	act.social.cpp	/^	char *others_no_arg;$/;"	m	struct:social_messg	file:
output	structs.h	/^		std::string output;		\/* ptr to the current output buffer	*\/$/;"	m	struct:mods::descriptor_data
owner	house.h	/^	long owner;			\/* idnum of house's owner	*\/$/;"	m	struct:house_control_rec
p_locks	structs.h	/^	sh_int p_locks;$/;"	m	struct:dex_skill_type
p_pocket	structs.h	/^	sh_int p_pocket;$/;"	m	struct:dex_skill_type
page	mods/player.cpp	/^	void player::page(int pg) {$/;"	f	class:mods::player
page_string	modify.cpp	/^void page_string(mods::descriptor_data d, char *str, int keep_internal) {$/;"	f
pager_clear	mods/player.cpp	/^	void player::pager_clear() {$/;"	f	class:mods::player
pager_end	mods/player.cpp	/^	player& player::pager_end() {$/;"	f	class:mods::player
pager_next_page	mods/player.cpp	/^	void player::pager_next_page() {$/;"	f	class:mods::player
pager_start	mods/player.cpp	/^	player& player::pager_start() {$/;"	f	class:mods::player
paginate_string	modify.cpp	/^void paginate_string(char *str, mods::descriptor_data d) {$/;"	f
paging	mods/player.hpp	/^			bool paging() const {$/;"	f	class:mods::player
parenthesized	mods/catch.hpp	/^		bool parenthesized;$/;"	m	struct:Catch::AssertionResultData
parse_class	class.cpp	/^int parse_class(char arg) {$/;"	f
parse_enhanced_mob	db.cpp	/^void parse_enhanced_mob(FILE *mob_f, int i, int nr) {$/;"	f
parse_espec	db.cpp	/^void parse_espec(char *buf, int i, int nr) {$/;"	f
parse_ip	comm.cpp	/^int parse_ip(const char *addr, struct in_addr *inaddr) {$/;"	f
parse_mobile	db.cpp	/^void parse_mobile(FILE *mob_f, int nr) {$/;"	f
parse_object	db.cpp	/^char *parse_object(FILE *obj_f, int nr) {$/;"	f
parse_room	db.cpp	/^void parse_room(FILE *fl, int virtual_nr) {$/;"	f
parse_simple_mob	db.cpp	/^void parse_simple_mob(FILE *mob_f, int i, int nr) {$/;"	f
parse_sql_mobiles	db.cpp	/^void parse_sql_mobiles() {$/;"	f
parse_sql_objects	db.cpp	/^int parse_sql_objects() {$/;"	f
parse_sql_player	db.cpp	/^bool parse_sql_player(std::shared_ptr<mods::player> player_ptr){$/;"	f
parse_sql_rooms	db.cpp	/^void parse_sql_rooms() {$/;"	f
parse_sql_zones	db.cpp	/^void parse_sql_zones() {$/;"	f
passwd	structs.h	/^	mods::string passwd;$/;"	m	struct:char_player_data
pave_to	mods/builder.cpp	/^	void pave_to(char_data* ch,room_data * current_room,int direction) {$/;"	f	namespace:mods::builder
pc_class	structs.h	/^	int pc_class;$/;"	m	struct:guild_info_type
pc_class_types	class.cpp	/^const char *pc_class_types[] = {$/;"	v
pcnpc	act.wizard.cpp	/^	const char pcnpc;$/;"	m	struct:set_struct	file:
people	structs.h	/^	struct char_data *people;    \/* List of NPC \/ PC in room           *\/$/;"	m	struct:room_data	typeref:struct:room_data::char_data
performOptionalSelector	mods/catch.hpp	/^inline id performOptionalSelector(id obj, SEL sel) {$/;"	f
perform_act	comm.cpp	/^void perform_act(const char *orig, struct char_data *ch, struct obj_data *obj,$/;"	f
perform_alias	interpreter.cpp	/^int perform_alias(mods::descriptor_data d, char *orig, size_t maxlen) {$/;"	f
perform_complex_alias	interpreter.cpp	/^void perform_complex_alias(struct txt_q *input_q, char *orig, struct alias_data *a) {$/;"	f
perform_drop	act.item.cpp	/^int perform_drop(struct char_data *ch, struct obj_data *obj,$/;"	f
perform_drop_gold	act.item.cpp	/^void perform_drop_gold(struct char_data *ch, int amount,$/;"	f
perform_dupe_check	interpreter.cpp	/^int64_t perform_dupe_check(mods::descriptor_data& d) {$/;"	f
perform_dupe_check	interpreter.cpp	/^int64_t perform_dupe_check(std::shared_ptr<mods::player> p){$/;"	f
perform_get_from_container	act.item.cpp	/^void perform_get_from_container(struct char_data *ch, struct obj_data *obj,$/;"	f
perform_get_from_room	act.item.cpp	/^int perform_get_from_room(struct char_data *ch, struct obj_data *obj) {$/;"	f
perform_give	act.item.cpp	/^void perform_give(struct char_data *ch, struct char_data *vict,$/;"	f
perform_give_gold	act.item.cpp	/^void perform_give_gold(struct char_data *ch, struct char_data *vict,$/;"	f
perform_group	act.other.cpp	/^int perform_group(struct char_data *ch, struct char_data *vict) {$/;"	f
perform_group_gain	fight.cpp	/^void perform_group_gain(struct char_data *ch, int base,$/;"	f
perform_immort_invis	act.wizard.cpp	/^void perform_immort_invis(struct char_data *ch, int level) {$/;"	f
perform_immort_vis	act.wizard.cpp	/^void perform_immort_vis(struct char_data *ch) {$/;"	f
perform_immort_where	act.informative.cpp	/^void perform_immort_where(struct char_data *ch, char *arg) {$/;"	f
perform_mag_groups	magic.cpp	/^void perform_mag_groups(int level, struct char_data *ch,$/;"	f
perform_mortal_where	act.informative.cpp	/^void perform_mortal_where(struct char_data *ch, char *arg) {$/;"	f
perform_move	act.movement.cpp	/^int perform_move(struct char_data *ch, int dir, int need_specials_check) {$/;"	f
perform_put	act.item.cpp	/^void perform_put(struct char_data *ch, struct obj_data *obj,$/;"	f
perform_remove	act.item.cpp	/^void perform_remove(struct char_data *ch, int pos) {$/;"	f
perform_set	act.wizard.cpp	/^int perform_set(struct char_data *ch, struct char_data *vict, int mode,$/;"	f
perform_socket_read	comm.cpp	/^ssize_t perform_socket_read(socket_t desc, char *read_point, size_t space_left) {$/;"	f
perform_socket_write	comm.cpp	/^ssize_t perform_socket_write(socket_t desc, const char *txt, size_t length) {$/;"	f
perform_subst	comm.cpp	/^int perform_subst(mods::descriptor_data &t, char *orig, char *subst) {$/;"	f
perform_tell	act.comm.cpp	/^void perform_tell(struct char_data *ch, struct char_data *vict, char *arg) {$/;"	f
perform_violence	fight.cpp	/^void perform_violence(void) {$/;"	f
perform_wear	act.item.cpp	/^void perform_wear(struct char_data *ch, struct obj_data *obj, int where) {$/;"	f
pet_shops	spec_assign.cpp	/^SPECIAL(pet_shops);$/;"	v
pet_shops	spec_procs.cpp	/^SPECIAL(pet_shops);$/;"	v
peter	castle.cpp	/^SPECIAL(peter);$/;"	v
pfilepos	structs.h	/^	int pfilepos;			 \/* playerfile pos		  *\/$/;"	m	struct:char_data
pk_allowed	config.cpp	/^int pk_allowed = YES;$/;"	v
played	structs.h	/^	int	played;     \/* This is the total accumulated time played in secs *\/$/;"	m	struct:time_data
played	structs.h	/^	int	played;    \/* Number of secs played in total *\/$/;"	m	struct:char_file_u
player	mods/js.cpp	/^				std::shared_ptr<mods::player> player;$/;"	m	struct:mods::js::utils::find_player_payload_t	file:
player	mods/player.cpp	/^	player::player(){$/;"	f	class:mods::player
player	mods/player.cpp	/^	player::player(char_data* ch) : m_executing_js(false), m_char_data(ch),m_do_paging(false),$/;"	f	class:mods::player
player	mods/player.cpp	/^	player::player(mods::player* ptr) {$/;"	f	class:mods::player
player	mods/player.cpp	/^	player::player(player_type_enum_t type){$/;"	f	class:mods::player
player	mods/player.hpp	/^	class player {$/;"	c	namespace:mods
player	structs.h	/^	char_player_data player;       \/* Normal data                   *\/$/;"	m	struct:char_data
player_bits	constants.cpp	/^const char *player_bits[] = {$/;"	v
player_bits	constants.hpp	/^const char *player_bits[] = {$/;"	v
player_index_element	db.h	/^struct player_index_element {$/;"	s
player_list	globals.cpp	/^		player_list_t player_list;$/;"	m	namespace:mods::globals	file:
player_name	mods/js.cpp	/^				std::string player_name;$/;"	m	struct:mods::js::utils::find_player_payload_t	file:
player_nobody	globals.cpp	/^		std::shared_ptr<player> player_nobody;$/;"	m	namespace:mods::globals	file:
player_ptr	structs.h	/^	std::shared_ptr<mods::player> player_ptr;$/;"	m	struct:char_data
player_scaffolding	mods/player-scaffolding.hpp	/^	struct player_scaffolding {$/;"	s	namespace:mods
player_special_data	structs.h	/^	player_special_data() :  poofin(""),$/;"	f	struct:player_special_data
player_special_data	structs.h	/^struct player_special_data {$/;"	s
player_special_data_saved	structs.h	/^	player_special_data_saved() : PADDING0(0),$/;"	f	struct:player_special_data_saved
player_special_data_saved	structs.h	/^struct player_special_data_saved {$/;"	s
player_specials	structs.h	/^	std::shared_ptr<player_special_data> player_specials; \/* PC specials		  *\/$/;"	m	struct:char_data
player_specials_saved	structs.h	/^	struct player_special_data_saved player_specials_saved;$/;"	m	struct:char_file_u	typeref:struct:char_file_u::player_special_data_saved
player_table	db.cpp	/^std::deque<player_index_element> player_table;	\/* index to plr file	 *\/$/;"	v
player_type_enum_t	mods/player.hpp	/^			enum player_type_enum_t { $/;"	g	class:mods::player
plural	spells.h	/^	const char	*plural;$/;"	m	struct:attack_hit_type
pluralise	mods/catch.hpp	/^	struct pluralise {$/;"	s	namespace:Catch
point_update	limits.cpp	/^void point_update(void) {$/;"	f
points	structs.h	/^	char_point_data points;        \/* Points                        *\/$/;"	m	struct:char_data
points	structs.h	/^	struct char_point_data points;$/;"	m	struct:char_file_u	typeref:struct:char_file_u::char_point_data
policies	db.cpp	/^char *policies = NULL;		\/* policies page		 *\/$/;"	v
poofin	structs.h	/^	std::string	poofin;		\/* Description on arrival of a god.     *\/$/;"	m	struct:player_special_data
poofout	structs.h	/^	std::string poofout;		\/* Description upon a god's exit.       *\/$/;"	m	struct:player_special_data
pop	shop.cpp	/^int pop(struct stack_data *stack) {$/;"	f
pop_free_list	mail.cpp	/^long pop_free_list(void) {$/;"	f
position	mail.h	/^	long	position;$/;"	m	struct:position_list_type_d
position	structs.h	/^	byte position;		\/* Standing, fighting, sleeping, etc.	*\/$/;"	m	struct:char_special_data
position_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,9> position_flags = { {$/;"	m	namespace:mods::builder	file:
position_list_type	mail.h	/^typedef struct position_list_type_d position_list_type;$/;"	t	typeref:struct:position_list_type_d
position_list_type_d	mail.h	/^struct position_list_type_d {$/;"	s
position_types	constants.cpp	/^const char *position_types[] = {$/;"	v
position_types	constants.hpp	/^const char *position_types[] = {$/;"	v
post_boot_db	globals.cpp	/^		void post_boot_db() {$/;"	f	namespace:mods::globals
post_command_interpreter	globals.cpp	/^		void post_command_interpreter(struct char_data *ch,char* argument) {$/;"	f	namespace:mods::globals
post_modify_callback	mods/builder_util.hpp	/^	typedef std::function<std::pair<bool,std::string>()> post_modify_callback;$/;"	t	namespace:mods::builder_util
postgres_db	mods/conf.cpp	/^	std::string postgres_db = "postgres_mud";$/;"	m	namespace:mods::conf	file:
postgres_password	mods/conf.cpp	/^	std::string postgres_password = "postgresmudpassword";$/;"	m	namespace:mods::conf	file:
postgres_port	mods/conf.cpp	/^	short postgres_port = 0;$/;"	m	namespace:mods::conf	file:
postgres_user	mods/conf.cpp	/^	std::string postgres_user = "postgres";$/;"	m	namespace:mods::conf	file:
postmaster	mail.cpp	/^SPECIAL(postmaster);$/;"	v
postmaster	spec_assign.cpp	/^SPECIAL(postmaster);$/;"	v
postmaster_check_mail	mail.cpp	/^void postmaster_check_mail(struct char_data *ch, struct char_data *mailman,$/;"	f
postmaster_receive_mail	mail.cpp	/^void postmaster_receive_mail(struct char_data *ch, struct char_data *mailman,$/;"	f
postmaster_send_mail	mail.cpp	/^void postmaster_send_mail(struct char_data *ch, struct char_data *mailman,$/;"	f
pow10	bsd-snprintf.cpp	/^pow10(int exp) {$/;"	f	file:
pq	mods/pq.cpp	/^namespace mods::pq {$/;"	n	class:mods	file:
pq	mods/pq.hpp	/^namespace pq {$/;"	n
prac_params	class.cpp	/^int prac_params[4][NUM_CLASSES] = {$/;"	v
prac_types	spec_procs.cpp	/^const char *prac_types[] = {$/;"	v
pre_game_loop	globals.cpp	/^		void pre_game_loop() {$/;"	f	namespace:mods::globals
pref	structs.h	/^	long \/*bitvector_t*\/	pref;	\/* preference flags for PC's.		*\/$/;"	m	struct:player_special_data_saved
preference_bits	constants.cpp	/^const char *preference_bits[] = {$/;"	v
preference_bits	constants.hpp	/^const char *preference_bits[] = {$/;"	v
prefs	mods/prefs.hpp	/^	class prefs {$/;"	c	namespace:mods
preg_match	mods/util.cpp	/^		bool preg_match(std::string_view regex,std::string_view haystack) {$/;"	f	namespace:mods::util
pregame	mods/pregame.cpp	/^namespace mods::pregame {$/;"	n	class:mods	file:
pregame	mods/pregame.hpp	/^namespace mods::pregame {$/;"	n	class:mods
pressure	structs.h	/^	int	pressure;	\/* How is the pressure ( Mb ) *\/$/;"	m	struct:weather_data
print_group	act.other.cpp	/^void print_group(struct char_data *ch) {$/;"	f
print_object_location	act.informative.cpp	/^void print_object_location(int num, struct obj_data *obj, struct char_data *ch,$/;"	f
print_zone_to_buf	act.wizard.cpp	/^size_t print_zone_to_buf(char *bufptr, size_t left, zone_rnum zone) {$/;"	f
process_input	comm.cpp	/^int process_input(mods::descriptor_data & t) {$/;"	f
process_output	comm.cpp	/^int process_output(mods::descriptor_data &in_t) {$/;"	f
producing	shop.h	/^	obj_vnum *producing;		\/* Which item to produce (virtual)	*\/$/;"	m	struct:shop_data
profit_buy	shop.h	/^	float profit_buy;		\/* Factor to multiply cost with		*\/$/;"	m	struct:shop_data
profit_sell	shop.h	/^	float profit_sell;		\/* Factor to multiply cost with		*\/$/;"	m	struct:shop_data
projectile	mods/projectile.cpp	/^	namespace projectile {$/;"	n	namespace:mods	file:
projectile	mods/projectile.hpp	/^	namespace projectile {$/;"	n	namespace:mods
prune_crlf	utils.cpp	/^void prune_crlf(char *txt) {$/;"	f
pt_allowed	config.cpp	/^int pt_allowed = NO;$/;"	v
ptr	mods/string.hpp	/^		char* ptr() {$/;"	f	struct:mods::string
ptrptr	mods/string.hpp	/^		char** ptrptr(){$/;"	f	struct:mods::string
puff	spec_assign.cpp	/^SPECIAL(puff);$/;"	v
puff	spec_procs.cpp	/^SPECIAL(puff);$/;"	v
push	mods/deferred.cpp	/^	void deferred::push(uint64_t ticks_in_future,std::function<void()> lambda) {$/;"	f	class:mods::deferred
push	mods/jx.hpp	/^			compositor& push(bool value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const char* value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, const std::string& value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, double value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, float value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, int value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, unsigned int value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(double value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(float value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(int value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(std::nullptr_t value) {$/;"	f	struct:mods::jx::compositor
push	shop.cpp	/^void push(struct stack_data *stack, int pushval) {$/;"	f
push_free_list	mail.cpp	/^void push_free_list(long pos) {$/;"	f
push_secs	mods/deferred.cpp	/^	void deferred::push_secs(seconds secs,std::function<void()> lambda) {$/;"	f	class:mods::deferred
put	mods/lmdb.cpp	/^	int _db_handle::put(std::string key,std::string value){$/;"	f	class:mods::lmdb::_db_handle
put	mods/lmdb.cpp	/^	int _db_handle::put(std::string key,std::string value,bool renew){$/;"	f	class:mods::lmdb::_db_handle
pwd	structs.h	/^	char	pwd[MAX_PWD_LENGTH+1];    \/* character's password *\/$/;"	m	struct:char_file_u
q	random.cpp	46;"	d	file:
query_parts	mods/sql.hpp	/^			constexpr static int query_parts = 5;$/;"	m	struct:mods::sql::compositor
quest_abort	mods/quests.cpp	/^		static duk_ret_t quest_abort(duk_context *ctx) {$/;"	f	namespace:mods::quests
quest_complete	mods/quests.cpp	/^		static duk_ret_t quest_complete(duk_context *ctx) {$/;"	f	namespace:mods::quests
quests	mods/quests.cpp	/^	namespace quests {$/;"	n	namespace:mods	file:
quests	mods/quests.hpp	/^	namespace quests {$/;"	n	namespace:mods
quests_file_to_lmdb	mods/quests.cpp	/^		int quests_file_to_lmdb(struct char_data* ch,const std::string& quests_file,const std::string& lmdb_key) {$/;"	f	namespace:mods::quests
queue_behaviour_enum_t	structs.h	/^		enum queue_behaviour_enum_t {$/;"	g	struct:mods::descriptor_data
queue_head	graph.cpp	/^static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;$/;"	v	typeref:struct:bfs_queue_struct	file:
queue_output	structs.cpp	/^		size_t descriptor_data::queue_output(const std::string &s){$/;"	f	class:mods::descriptor_data
queue_page_fragment	mods/player.hpp	/^			void                queue_page_fragment(std::string_view fragment) {$/;"	f	class:mods::player
queue_tail	graph.cpp	/^static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;$/;"	v	typeref:struct:	file:
r	random.cpp	49;"	d	file:
r_frozen_start_room	db.cpp	/^room_rnum r_frozen_start_room;	\/* rnum of frozen start room	 *\/$/;"	v
r_immort_start_room	db.cpp	/^room_rnum r_immort_start_room;	\/* rnum of immort start room	 *\/$/;"	v
r_mortal_start_room	db.cpp	/^room_rnum r_mortal_start_room;	\/* rnum of mortal start room	 *\/$/;"	v
rand_number	utils.cpp	/^int rand_number(int from, int to) {$/;"	f
random_element	globals.cpp	/^			I random_element(I begin, I end) {$/;"	f	namespace:mods::globals
rawMemoryToString	mods/catch.hpp	/^		inline std::string rawMemoryToString(const T& object) {$/;"	f	namespace:Catch::Detail
raw_kill	fight.cpp	/^void raw_kill(struct char_data *ch) {$/;"	f
reaction	structs.h	/^	sh_int reaction;$/;"	m	struct:dex_app_type
read_aliases	alias.cpp	/^void read_aliases(struct char_data *ch) {$/;"	f
read_delete	mail.cpp	/^char *read_delete(long recipient) {$/;"	f
read_from_file	mail.cpp	/^void read_from_file(void *buf, int size, long filepos) {$/;"	f
read_line	shop.cpp	/^void read_line(FILE *shop_f, const char *string, void *data) {$/;"	f
read_list	shop.cpp	/^int read_list(FILE *shop_f, struct shop_buy_data *list, int new_format,$/;"	f
read_lvl	boards.h	/^	int	read_lvl;	\/* min level to read messages on this board *\/$/;"	m	struct:board_info_type
read_mobile	db.cpp	/^struct char_data *read_mobile(mob_vnum nr, int type) { \/* and mob_rnum *\/$/;"	f
read_mobile	globals.cpp	/^		char_data* read_mobile(const mob_vnum & nr,const int & type){$/;"	f	namespace:mods::globals
read_mobile	mods/js.cpp	/^		static duk_ret_t read_mobile(duk_context *ctx){$/;"	f	namespace:mods::js
read_object	db.cpp	/^struct obj_data *read_object(obj_vnum nr, int type) { \/* and obj_rnum *\/$/;"	f
read_shop_message	shop.cpp	/^char *read_shop_message(int mnum, room_vnum shr, FILE *shop_f, const char *why) {$/;"	f
read_type_list	shop.cpp	/^int read_type_list(FILE *shop_f, struct shop_buy_data *list,$/;"	f
real_abils	structs.h	/^	char_ability_data real_abils;	 \/* Abilities without modifiers   *\/$/;"	m	struct:char_data
real_mobile	db.cpp	/^mob_rnum real_mobile(mob_vnum vnum) {$/;"	f
real_object	db.cpp	/^obj_rnum real_object(obj_vnum vnum) {$/;"	f
real_room	db.cpp	/^room_rnum real_room(room_vnum vnum) {$/;"	f
real_time_passed	utils.cpp	/^struct time_info_data *real_time_passed(time_t t2, time_t t1) {$/;"	f
real_zone	db.cpp	/^room_rnum real_zone(room_vnum vnum) {$/;"	f
reap	comm.cpp	/^RETSIGTYPE reap(int sig) {$/;"	f
reboot_wizlists	db.cpp	/^void reboot_wizlists(void) {$/;"	f
receptionist	objsave.cpp	/^SPECIAL(receptionist);$/;"	v
receptionist	spec_assign.cpp	/^SPECIAL(receptionist);$/;"	v
recipient	mail.h	/^	long recipient;			\/* who is this mail for?	*\/$/;"	m	struct:mail_index_type_d
reconstructExpression	mods/catch.hpp	/^		std::string const& reconstructExpression() const {$/;"	f	class:Catch::AssertionResultData::std
reconstructedExpression	mods/catch.hpp	/^		mutable std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData
record_usage	comm.cpp	/^void record_usage(void) {$/;"	f
reference_field_index	mods/meta_utils.cpp	/^	constexpr static std::size_t reference_field_index = 1;$/;"	m	namespace:mods::meta_utils	file:
refresh_player_states	globals.cpp	/^		void refresh_player_states() {$/;"	f	namespace:mods::globals
register_mob	mods/behaviour_tree_impl.cpp	/^	void register_mob(const argument_type & mob,const type & tree){$/;"	f	namespace:mods::behaviour_tree_impl
register_object	globals.cpp	/^		void register_object(obj_data& obj) {$/;"	f	namespace:mods::globals
register_object_list	globals.cpp	/^		void register_object_list() {$/;"	f	namespace:mods::globals
register_room	globals.cpp	/^		void register_room(const room_rnum& r) {$/;"	f	namespace:mods::globals
release	mods/catch.hpp	/^		virtual void release() const {$/;"	f	struct:Catch::SharedImpl
remember	mobact.cpp	/^void remember(char_data *ch,char_data *victim) {$/;"	f
remove_affect	mods/player.cpp	/^			void player::remove_affect(int64_t flag){$/;"	f	class:mods::player
remove_affect_plr	mods/player.cpp	/^			void player::remove_affect_plr(int64_t flag){$/;"	f	class:mods::player
remove_lvl	boards.h	/^	int	remove_lvl;	\/* min level to remove messages from this board *\/$/;"	m	struct:board_info_type
remove_subscriber	mods/chat.cpp	/^	void channel::remove_subscriber(const socket_t& sock) {$/;"	f	class:mods::chat::channel
renew_txn	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::renew_txn(){$/;"	f	class:mods::lmdb::_db_handle
rent_file_timeout	config.cpp	/^int rent_file_timeout = 30;$/;"	v
rent_info	structs.h	/^struct rent_info {$/;"	s
rentcode	structs.h	/^	int	rentcode;$/;"	m	struct:rent_info
renum_world	db.cpp	/^void renum_world(void) {$/;"	f
renum_zone_table	db.cpp	/^void renum_zone_table(void) {$/;"	f
replace_all	globals.cpp	/^		std::string replace_all(std::string str, const std::string& from, const std::string& to) {$/;"	f	namespace:mods::globals
replace_string	fight.cpp	/^char *replace_string(const char *str, const char *weapon_singular, const char *weapon_plural) {$/;"	f
replacement	interpreter.h	/^	char *replacement;$/;"	m	struct:alias_data
report_error	mods/builder.hpp	/^	void report_error(T player,std::string_view message) {$/;"	f	namespace:mods::builder
report_status	mods/builder.hpp	/^	void report_status(T player,std::string_view message) {$/;"	f	namespace:mods::builder
report_success	mods/builder.hpp	/^	void report_success(T player,std::string_view message) {$/;"	f	namespace:mods::builder
require_js	mods/js.cpp	/^		static duk_ret_t require_js(duk_context *ctx) {$/;"	f	namespace:mods::js
require_test	mods/js.cpp	/^			static duk_ret_t require_test(duk_context *ctx) {$/;"	f	namespace:mods::js::test
reread_wizlist	comm.cpp	/^byte reread_wizlist;		\/* signal: SIGUSR1 *\/$/;"	v
reread_wizlists	comm.cpp	/^RETSIGTYPE reread_wizlists(int sig) {$/;"	f
reserved	interpreter.cpp	/^const char *reserved[] = {$/;"	v
reserved	mods/lmdb.hpp	/^		uint32_t reserved;$/;"	m	struct:mods::lmdb::_selector
reserved_word	interpreter.cpp	/^int reserved_word(char *argument) {$/;"	f
reset	mods/catch.hpp	/^			void reset() {$/;"	f	class:Catch::Ptr
reset_char	db.cpp	/^void reset_char(char_data *ch) {$/;"	f
reset_com	db.h	/^struct reset_com {$/;"	s
reset_mode	db.h	/^	int	reset_mode;         \/* conditions for reset (see below)   *\/$/;"	m	struct:zone_data
reset_points	mods/player-scaffolding.cpp	/^	void player_scaffolding::reset_points(std::shared_ptr<mods::player> player,std::map<std::string_view,int> * points_map){$/;"	f	class:mods::player_scaffolding
reset_q	db.cpp	/^struct reset_q_type reset_q;	\/* queue of zones to be reset	 *\/$/;"	v	typeref:struct:reset_q_type
reset_q_element	db.h	/^struct reset_q_element {$/;"	s
reset_q_type	db.h	/^struct reset_q_type {$/;"	s
reset_time	db.cpp	/^void reset_time(void) {$/;"	f
reset_zone	db.cpp	/^void reset_zone(zone_rnum zone) {$/;"	f
resolve_room	mods/projectile.cpp	/^		room_rnum resolve_room(room_rnum source_room,int direction,int depth) {$/;"	f	namespace:mods::projectile
resultDisposition	mods/catch.hpp	/^		ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo
resultType	mods/catch.hpp	/^		ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData
return_codes	mods/meta_utils.cpp	/^	enum return_codes {$/;"	g	namespace:mods::meta_utils	file:
rev_dir	constants.cpp	/^int rev_dir[] = {$/;"	v
rev_dir	constants.hpp	/^int rev_dir[] =$/;"	v
right_join	mods/sql.hpp	/^			compositor<T>& right_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
right_outer_join	mods/sql.hpp	/^			compositor<T>& right_outer_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
rnum	boards.h	/^	obj_rnum rnum;	\/* rnum of this board *\/$/;"	m	struct:board_info_type
roll_real_abils	class.cpp	/^void roll_real_abils(struct char_data *ch) {$/;"	f
room	graph.cpp	/^	room_rnum room;$/;"	m	struct:bfs_queue_struct	file:
room	mods/js.cpp	/^		static duk_ret_t room(duk_context *ctx){$/;"	f	namespace:mods::js
room	mods/player.hpp	/^			room_rnum& room(){$/;"	f	class:mods::player
room_bits	constants.cpp	/^const char *room_bits[] = {$/;"	v
room_bits	constants.hpp	/^const char *room_bits[] = {$/;"	v
room_bits_count	constants.cpp	/^size_t	room_bits_count = sizeof(room_bits) \/ sizeof(room_bits[0]) - 1,$/;"	v
room_bits_count	constants.hpp	/^size_t	room_bits_count = sizeof(room_bits) \/ sizeof(room_bits[0]) - 1,$/;"	v
room_data	structs.h	/^	room_data() : number(0),zone(0),sector_type(0),$/;"	f	struct:room_data
room_data	structs.h	/^struct room_data {$/;"	s
room_direction_data	structs.h	/^struct room_direction_data {$/;"	s
room_event	globals.cpp	/^		void room_event(room_vnum room,mods::ai_state::event_type_t event) {$/;"	f	namespace:mods::globals
room_event	globals.cpp	/^		void room_event(struct char_data* ch,mods::ai_state::event_type_t event) { }$/;"	f	namespace:mods::globals
room_flags	structs.h	/^	int \/*bitvector_t*\/ room_flags;		\/* DEATH,DARK ... etc *\/$/;"	m	struct:room_data
room_is_dark	utils.cpp	/^int room_is_dark(room_rnum room) {$/;"	f
room_list	globals.cpp	/^		std::vector<std::vector<char_data*>> room_list;$/;"	m	namespace:mods::globals	file:
room_list_t	mods/scan.hpp	/^		typedef std::array<std::vector<room_rnum>,num_directions> room_list_t;$/;"	t	namespace:mods::scan
room_msg	structs.h	/^	char	*room_msg;      \/* message to room     *\/$/;"	m	struct:msg_type
room_pave_mode	mods/player.cpp	/^			bool player::room_pave_mode(){$/;"	f	class:mods::player
room_pave_mode	structs.h	/^	bool room_pave_mode;$/;"	m	struct:builder_data_t
room_pavement_t	structs.h	/^	room_pavement_t() : start_room(0), transact_id(-1),$/;"	f	struct:room_pavement_t
room_pavement_t	structs.h	/^	room_pavement_t(room_vnum start,int z_id) :  start_room(start), transact_id(0),$/;"	f	struct:room_pavement_t
room_pavement_t	structs.h	/^struct room_pavement_t {$/;"	s
room_pavements	structs.h	/^	room_pavement_t room_pavements;$/;"	m	struct:builder_data_t
room_rnum	structs.h	/^typedef IDXTYPE room_rnum;$/;"	t
room_vnum	structs.h	/^typedef IDXTYPE room_vnum;$/;"	t
rooms	config.cpp	/^	namespace rooms {$/;"	n	namespace:config	file:
rooms	config.hpp	/^	namespace rooms {$/;"	n	namespace:config
rooms	globals.cpp	/^		namespace rooms {$/;"	n	namespace:mods::globals	file:
rooms	globals.hpp	/^		namespace rooms {$/;"	n	namespace:mods::globals
rooms	structs.h	/^	std::vector<room_rnum> rooms;$/;"	m	struct:room_pavement_t
round	bsd-snprintf.cpp	/^round(long double value) {$/;"	f	file:
routines	spells.h	/^	int routines;$/;"	m	struct:spell_info_type
row_id	mods/lmdb.hpp	/^		uint64_t row_id;$/;"	m	struct:mods::lmdb::_selector
run	mods/behaviour_tree.hpp	/^		run_status run(LambdaArgument arg) {$/;"	f	struct:mods::behaviour_tree
run	mods/behaviour_tree_node.hpp	/^		run_status_t run(LambdaArgument & arg){$/;"	f	struct:mods::behaviour_tree_node
run_autowiz	limits.cpp	/^void run_autowiz(void) {$/;"	f
run_profile_scripts	mods/js.cpp	/^		void run_profile_scripts(std::string_view player_name){$/;"	f	namespace:mods::js
run_status_t	mods/behaviour_tree_node.hpp	/^		} run_status_t;$/;"	t	struct:mods::behaviour_tree_node	typeref:struct:mods::behaviour_tree_node::__anon2
run_test_suite	mods/js.cpp	/^		bool run_test_suite(mods::player& player,std::string_view suite) {$/;"	f	namespace:mods::js
run_trees	mods/behaviour_tree_impl.cpp	/^	void run_trees(){$/;"	f	namespace:mods::behaviour_tree_impl
run_trigger	mods/quests.cpp	/^		int run_trigger(struct char_data* ch) {$/;"	f	namespace:mods::quests
s	mods/catch.hpp	/^			static std::ostream& s;$/;"	m	struct:Catch::Detail::IsStreamInsertable
s_addr	sysdep.h	/^	unsigned long int s_addr;	\/* for inet_addr, etc. *\/$/;"	m	struct:in_addr
salt	mods/crypto.hpp	/^			constexpr static const char* salt = "tmnt1`9*$$jzz8N++";$/;"	m	class:mods::crypto
same_obj	shop.cpp	/^int same_obj(struct obj_data *obj1, struct obj_data *obj2) {$/;"	f
sanitize	mods/util.cpp	/^		std::function<void(const std::string&,std::string&)> sanitize = [](const std::string & command,std::string& sanitized){$/;"	m	namespace:mods::util	file:
save_char	db.cpp	/^	int16_t save_char(std::shared_ptr<mods::player> player_ptr){$/;"	f	namespace:db
save_char	db.cpp	/^void save_char(std::shared_ptr<mods::player> player_ptr){$/;"	f
save_char	mods/db.cpp	/^tuple_status_t save_char($/;"	f	namespace:mods::db
save_etext	db.cpp	/^void save_etext(struct char_data *ch) {$/;"	f
save_mud_time	db.cpp	/^void save_mud_time(struct time_info_data *when) {$/;"	f
save_object	mods/builder.cpp	/^	std::pair<bool,std::string> save_object(object_data* obj) {$/;"	f	namespace:mods::builder
save_object_vector	mods/builder_util.hpp	/^	void save_object_vector($/;"	f	namespace:mods::builder_util
save_player	mods/builder.cpp	/^	std::pair<bool,std::string> save_player(char_data* obj) {$/;"	f	namespace:mods::builder
save_record	mods/db.cpp	/^tuple_status_t save_record(const std::string& table,mutable_map_t* values){$/;"	f	namespace:mods::db
save_record_get_id	mods/db.cpp	/^aligned_int_t save_record_get_id($/;"	f	namespace:mods::db
save_to_db	mods/builder.cpp	/^	int save_to_db(room_rnum in_room) {$/;"	f	namespace:mods::builder
save_to_db	mods/builder_util.hpp	/^	std::pair<bool,std::string> save_to_db($/;"	f	namespace:mods::builder_util
save_zone_to_db	mods/builder.cpp	/^	bool save_zone_to_db(std::string_view name,int room_start,int room_end,int lifespan,int reset_mode) {$/;"	f	namespace:mods::builder
saved	structs.h	/^	char_special_data_saved saved; \/* constants saved in plrfile	*\/$/;"	m	struct:char_special_data
saved	structs.h	/^	struct player_special_data_saved saved;$/;"	m	struct:player_special_data	typeref:struct:player_special_data::player_special_data_saved
saving_throws	class.cpp	/^byte saving_throws(int class_num, int type, int level) {$/;"	f
say_random	globals.cpp	/^		const char* say_random(const mods::ai_state::event_type_t& event) {$/;"	f	namespace:mods::globals
say_spell	spell_parser.cpp	/^void say_spell(struct char_data *ch, int spellnum, struct char_data *tch,$/;"	f
sbyte	structs.h	/^typedef signed char		sbyte;$/;"	t
scan	mods/scan.cpp	/^	namespace scan {$/;"	n	namespace:mods	file:
scan	mods/scan.hpp	/^	namespace scan {$/;"	n	namespace:mods
scan_file	mail.cpp	/^int scan_file(void) {$/;"	f
scan_file	mods/hell.hpp	/^	constexpr inline bool scan_file = false;$/;"	m	namespace:mods::hell
scheck	comm.cpp	/^int scheck = 0;			\/* for syntax checking mode *\/$/;"	v
schema	mods/schema.hpp	/^namespace mods::schema { $/;"	n	class:mods
search_block	interpreter.cpp	/^int search_block(char *arg, const char **list, int exact) { \/** FIXME: arg 2  *\/$/;"	f
seconds	mods/deferred.hpp	/^			typedef unsigned long seconds;$/;"	t	class:mods::deferred
sector_type	structs.h	/^	int	sector_type;            \/* sector type (move\/hide)            *\/$/;"	m	struct:room_data
sector_types	constants.cpp	/^const char *sector_types[] = {$/;"	v
sector_types	constants.hpp	/^const char *sector_types[] = {$/;"	v
seed	mods/ai_state.cpp	/^	void seed() {$/;"	f	namespace:mods
seed	random.cpp	/^static unsigned long seed;$/;"	v	file:
select	mods/sql.hpp	/^			compositor<T>& select(str_object fields) {$/;"	f	struct:mods::sql::compositor
select_randomly	globals.cpp	/^			Iter select_randomly(Iter start, Iter end) {$/;"	f	namespace:mods::globals
select_randomly	globals.cpp	/^			Iter select_randomly(Iter start, Iter end, RandomGenerator& g) {$/;"	f	namespace:mods::globals
selector	mods/lmdb.cpp	/^	selector_type_t transaction_t::selector(const key_type_t & column,const uint64_t & row_id){$/;"	f	class:mods::lmdb::transaction_t
sell_price	shop.cpp	/^int sell_price(struct obj_data *obj, int shop_nr, struct char_data *keeper, struct char_data *seller) {$/;"	f
send	mods/js.cpp	/^		static duk_ret_t send(duk_context *ctx) {$/;"	f	namespace:mods::js
send_to_all	comm.cpp	/^void send_to_all(const char *messg, ...) {$/;"	f
send_to_char	comm.cpp	/^size_t send_to_char(struct char_data *ch, const char *messg, ...) {$/;"	f
send_to_char	mods/js.cpp	/^		static duk_ret_t send_to_char(duk_context *ctx) {$/;"	f	namespace:mods::js
send_to_outdoor	comm.cpp	/^void send_to_outdoor(const char *messg, ...) {$/;"	f
send_to_room	comm.cpp	/^void send_to_room(room_rnum room, const char *messg, ...) {$/;"	f
send_to_room_except	comm.cpp	/^void send_to_room_except(room_rnum room, const std::vector<char_data*>& except, const char *messg, ...) {$/;"	f
send_to_uuid	mods/js.cpp	/^		static duk_ret_t send_to_uuid(duk_context *ctx) {$/;"	f	namespace:mods::js
serialize_affect	mods/player.cpp	/^			std::string player::serialize_affect(){$/;"	f	class:mods::player
serialize_affect_plr	mods/player.cpp	/^			std::string player::serialize_affect_plr(){$/;"	f	class:mods::player
set	config.hpp	/^	static inline void set(std::string_view option,T value){$/;"	f	namespace:config
set	mods/lmdb.cpp	/^	tuple_status_t transaction_t::set($/;"	f	class:mods::lmdb::transaction_t
set	mods/prefs.cpp	/^	void prefs::set(const std::string& key,const std::string& value,struct char_data* ch) {$/;"	f	class:mods::prefs
set	mods/sql.hpp	/^			compositor<T>& set(const value_map& values) {$/;"	f	struct:mods::sql::compositor
set_access_rights	mods/acl_list.cpp	/^	void set_access_rights(std::shared_ptr<mods::player> player,$/;"	f	namespace:mods::acl_list
set_affect_by_serialized	mods/player.cpp	/^			void player::set_affect_by_serialized(std::string data){$/;"	f	class:mods::player
set_affect_plr_by_serialized	mods/player.cpp	/^			void player::set_affect_plr_by_serialized(std::string data){$/;"	f	class:mods::player
set_attribute_on_object_vector	mods/builder_util.hpp	/^	void set_attribute_on_object_vector($/;"	f	namespace:mods::builder_util
set_bad_password_count	mods/player.cpp	/^			void player::set_bad_password_count(int i){$/;"	f	class:mods::player
set_bui_mode	mods/player.cpp	/^			void player::set_bui_mode(bool b){$/;"	f	class:mods::player
set_cd	mods/drone.hpp	/^			void set_cd(char_data* ch) {$/;"	f	class:mods::drone
set_cd	mods/player.cpp	/^			void player::set_cd(char_data* ch) {$/;"	f	class:mods::player
set_char_on_descriptor	mods/player.cpp	/^	void player::set_char_on_descriptor(std::deque<descriptor_data>::iterator it){$/;"	f	class:mods::player
set_char_pk_id	mods/js.cpp	/^		static duk_ret_t set_char_pk_id(duk_context *ctx){$/;"	f	namespace:mods::js
set_children	mods/behaviour_tree_node.hpp	/^		void set_children(const children_t & child_nodes){$/;"	f	struct:mods::behaviour_tree_node
set_class_capability	mods/player.cpp	/^	void player::set_class_capability(const class_capability_t& caps) {$/;"	f	class:mods::player
set_context	mods/js.hpp	/^				inline void set_context(duk_context *ctx) {$/;"	f	struct:mods::js::include
set_db_id	mods/player.cpp	/^			void player::set_db_id(aligned_int_t id){$/;"	f	class:mods::player
set_desc	mods/player.cpp	/^			void player::set_desc(std::deque<descriptor_data>::iterator it){ $/;"	f	class:mods::player
set_desc	mods/player.cpp	/^			void player::set_desc(std::shared_ptr<descriptor_data> it){ $/;"	f	class:mods::player
set_dir	mods/js.hpp	/^				inline void set_dir(const std::string& m) {$/;"	f	struct:mods::js::include
set_fields	act.wizard.cpp	/^} set_fields[] = {$/;"	v	typeref:struct:set_struct
set_fighting	fight.cpp	/^void set_fighting(struct char_data *ch, struct char_data *vict) {$/;"	f
set_file	mods/js.hpp	/^				inline void set_file(const std::string& m) {$/;"	f	struct:mods::js::include
set_god_mode	mods/player.cpp	/^			void player::set_god_mode(bool b){$/;"	f	class:mods::player
set_host	mods/player.cpp	/^			void player::set_host(std::string host){$/;"	f	class:mods::player
set_imp_mode	mods/player.cpp	/^			void player::set_imp_mode(bool b){$/;"	f	class:mods::player
set_logic	mods/behaviour_tree_node.hpp	/^		void set_logic(const callback_t & logic){$/;"	f	struct:mods::behaviour_tree_node
set_name	mods/chat.cpp	/^	void channel::set_name(std::string_view name) {$/;"	f	class:mods::chat::channel
set_node	mods/behaviour_tree.hpp	/^		void set_node(const node & btree_node){$/;"	f	struct:mods::behaviour_tree
set_node_type	mods/behaviour_tree_node.hpp	/^		void set_node_type(const node_type_t & n){ $/;"	f	struct:mods::behaviour_tree_node
set_password	mods/player.cpp	/^			void player::set_password(std::string pw){$/;"	f	class:mods::player
set_players	mods/player-scaffolding.cpp	/^	int player_scaffolding::set_players(std::shared_ptr<mods::player> ch,$/;"	f	class:mods::player_scaffolding
set_players	mods/player-scaffolding.cpp	/^	int player_scaffolding::set_players(std::string_view main_player,$/;"	f	class:mods::player_scaffolding
set_players	mods/player-scaffolding.cpp	/^	std::vector<std::shared_ptr<mods::player>>& player_scaffolding::set_players(std::string_view main_player,$/;"	f	class:mods::player_scaffolding
set_pluck_filter	mods/lmdb.cpp	/^	void _db_handle::set_pluck_filter(const std::vector<std::string> & cols){$/;"	f	class:mods::lmdb::_db_handle
set_points	mods/js.cpp	/^		static duk_ret_t set_points(duk_context *ctx) {$/;"	f	namespace:mods::js
set_private	mods/chat.hpp	/^			void set_private(bool b_private) {$/;"	f	struct:mods::mods::chat::channel
set_queue_behaviour	structs.h	/^		void set_queue_behaviour(queue_behaviour_enum_t queue_behaviour){ $/;"	f	struct:mods::descriptor_data
set_room	mods/player.hpp	/^			void set_room(room_rnum r){$/;"	f	class:mods::player
set_sendbuf	comm.cpp	/^int set_sendbuf(socket_t s) {$/;"	f
set_sex	mods/player.hpp	/^			void set_sex(byte s){$/;"	f	class:mods::player
set_shared_ptr	mods/player.cpp	/^	void player::set_shared_ptr(std::shared_ptr<mods::player>& self_ptr) {$/;"	f	class:mods::player
set_state	mods/player.cpp	/^			void player::set_state(int state){$/;"	f	class:mods::player
set_state	structs.h	/^		void set_state(int c) { connected = c; }$/;"	f	struct:mods::descriptor_data
set_str_table	mods/lmdb.hpp	/^		void set_str_table(table_type_t e_table){$/;"	f	struct:mods::lmdb::transaction_t
set_struct	act.wizard.cpp	/^struct set_struct {$/;"	s	file:
set_time_birth	mods/player.cpp	/^			void player::set_time_birth(time_t b){$/;"	f	class:mods::player
set_time_logon	mods/player.cpp	/^			void player::set_time_logon(time_t t){$/;"	f	class:mods::player
set_time_played	mods/player.cpp	/^			void player::set_time_played(int t){$/;"	f	class:mods::player
set_title	limits.cpp	/^void set_title(struct char_data *ch, char *title) {$/;"	f
set_type	mods/player.cpp	/^	void player::set_type(player_type_enum_t type){$/;"	f	class:mods::player
set_verb	mods/chat.cpp	/^	void channel::set_verb(std::string_view verb) {$/;"	f	class:mods::chat::channel
setup_dir	db.cpp	/^void setup_dir(FILE *fl, int room, int dir) {$/;"	f
setup_log	comm.cpp	/^void setup_log(const char *filename, int fd) {$/;"	f
sex	mods/player.hpp	/^			byte& sex(){$/;"	f	class:mods::player
sex	structs.h	/^	byte sex;           \/* PC \/ NPC's sex                       *\/$/;"	m	struct:char_player_data
sex	structs.h	/^	byte sex;$/;"	m	struct:char_file_u
sex_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,3> sex_flags = { {$/;"	m	namespace:mods::builder	file:
sh_int	structs.h	/^typedef signed short int	sh_int;$/;"	t
shock	structs.h	/^	sh_int shock;$/;"	m	struct:con_app_type
shop_bits	shop.cpp	/^const char *shop_bits[] = {$/;"	v
shop_buy_data	shop.h	/^struct shop_buy_data {$/;"	s
shop_data	shop.h	/^struct shop_data {$/;"	s
shop_index	shop.cpp	/^std::vector<shop_data> shop_index;$/;"	v
shop_keeper	act.other.cpp	/^SPECIAL(shop_keeper);$/;"	v
shop_keeper	shop.cpp	/^SPECIAL(shop_keeper);$/;"	v
shop_producing	shop.cpp	/^int shop_producing(struct obj_data *item, int shop_nr) {$/;"	f
shop_rnum	structs.h	/^typedef IDXTYPE shop_rnum;$/;"	t
shop_vnum	structs.h	/^typedef IDXTYPE shop_vnum;$/;"	t
shopping_buy	shop.cpp	/^void shopping_buy(char *arg, struct char_data *ch, struct char_data *keeper, int shop_nr) {$/;"	f
shopping_list	shop.cpp	/^void shopping_list(char *arg, struct char_data *ch, struct char_data *keeper, int shop_nr) {$/;"	f
shopping_sell	shop.cpp	/^void shopping_sell(char *arg, struct char_data *ch, struct char_data *keeper, int shop_nr) {$/;"	f
shopping_value	shop.cpp	/^void shopping_value(char *arg, struct char_data *ch, struct char_data *keeper, int shop_nr) {$/;"	f
short_descr	structs.h	/^	mods::string short_descr;  \/* for NPC 'actions'                    *\/$/;"	m	struct:char_player_data
short_description	structs.h	/^	char	*short_description;       \/* when worn\/carry\/in cont.         *\/$/;"	m	struct:obj_data
shouldContinueOnFailure	mods/catch.hpp	/^	inline bool shouldContinueOnFailure(int flags)    {$/;"	f	namespace:Catch
shouldSuppressFailure	mods/catch.hpp	/^	inline bool shouldSuppressFailure(int flags)      {$/;"	f	namespace:Catch
show_obj_modifiers	act.informative.cpp	/^void show_obj_modifiers(struct obj_data *obj, struct char_data *ch) {$/;"	f
show_obj_to_char	act.informative.cpp	/^void show_obj_to_char(struct obj_data *obj, struct char_data *ch, int mode) {$/;"	f
show_object_vector	mods/builder_util.hpp	/^	void show_object_vector($/;"	f	namespace:mods::builder_util
show_shops	shop.cpp	/^void show_shops(struct char_data *ch, char *arg) {$/;"	f
show_string	modify.cpp	/^void show_string(mods::descriptor_data d, char *input) {$/;"	f
showstr_count	structs.h	/^		int  showstr_count;		\/* number of pages to page through	*\/$/;"	m	struct:mods::descriptor_data
showstr_head	structs.h	/^		char *showstr_head;		\/* for keeping track of an internal str	*\/$/;"	m	struct:mods::descriptor_data
showstr_page	structs.h	/^		int  showstr_page;		\/* which page are we currently showing?	*\/$/;"	m	struct:mods::descriptor_data
showstr_vector	structs.h	/^		char **showstr_vector;	\/* for paging through texts		*\/$/;"	m	struct:mods::descriptor_data
shutdown	globals.cpp	/^		void shutdown(void){$/;"	f	namespace:mods::globals
sigfunc	comm.h	/^typedef RETSIGTYPE sigfunc(int);$/;"	t
signal_setup	comm.cpp	/^void signal_setup(void) {$/;"	f
simulate	mods/drone.cpp	/^	 void drone::simulate(struct char_data* owner,bool value) {$/;"	f	class:mods::drone
singular	spells.h	/^	const char	*singular;$/;"	m	struct:attack_hit_type
site	db.h	/^	char	site[BANNED_SITE_LENGTH+1];$/;"	m	struct:ban_list_element
siteok_everyone	config.cpp	/^int siteok_everyone = TRUE;$/;"	v
sizer	mods/catch.hpp	/^			char sizer[1];$/;"	m	struct:Catch::Detail::TrueType
sizer	mods/catch.hpp	/^			char sizer[2];$/;"	m	struct:Catch::Detail::FalseType
skill_message	fight.cpp	/^int skill_message(int dam, struct char_data *ch, struct char_data *vict,$/;"	f
skill_name	spell_parser.cpp	/^const char *skill_name(int num) {$/;"	f
skillo	spell_parser.cpp	825;"	d	file:
skills	structs.h	/^	std::array<byte,max_skills> skills;	\/* array of skills plus skill 0		*\/$/;"	m	struct:player_special_data_saved
skip_spaces	interpreter.cpp	/^void skip_spaces(char **string) {$/;"	f
sky	structs.h	/^	int	sky;	\/* How is the sky. *\/$/;"	m	struct:weather_data
slc_names	telnet.h	/^char *slc_names[] = {$/;"	v
slide_obj	shop.cpp	/^struct obj_data *slide_obj(struct obj_data *obj, struct char_data *keeper,$/;"	f
slot_num	boards.h	/^	int	slot_num;     \/* pos of message in "master index" *\/$/;"	m	struct:board_msginfo
small_outbuf	structs.h	/^		buffer_type_t small_outbuf;  \/* standard output buffer		*\/$/;"	m	struct:mods::descriptor_data
smash_tilde	modify.cpp	/^void smash_tilde(char *str) {$/;"	f
snake	spec_assign.cpp	/^SPECIAL(snake);$/;"	v
snake	spec_procs.cpp	/^SPECIAL(snake);$/;"	v
sneak	structs.h	/^	sh_int sneak;$/;"	m	struct:dex_skill_type
snipe	mods/weapon.hpp	/^			static constexpr int snipe = 1;$/;"	m	struct:mods::weapon::mask
snipe_damage	fight.cpp	/^int snipe_damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype) {$/;"	f
snipe_hit	fight.cpp	/^int snipe_hit(struct char_data *ch, struct char_data *victim, int type,uint16_t distance) {$/;"	f
snipe_tracking	mods/behaviour_tree_impl.hpp	/^			snipe_tracking = 0,$/;"	e	enum:mods::behaviour_tree_impl::type
snipe_tracking	structs.h	/^	char_data* snipe_tracking;$/;"	m	struct:mob_special_data
snoop_by	structs.h	/^		std::shared_ptr<mods::descriptor_data> snoop_by; \/* And who is snooping this char	*\/$/;"	m	struct:mods::descriptor_data
snoop_check	act.wizard.cpp	/^void snoop_check(struct char_data *ch) {$/;"	f
snooping	structs.h	/^		std::shared_ptr<mods::descriptor_data> snooping; \/* Who is this char snooping	*\/$/;"	m	struct:mods::descriptor_data
snprintf	bsd-snprintf.cpp	/^snprintf(char *str,size_t count,const char *fmt,...) {$/;"	f
snprintf	sysdep.h	350;"	d
soc_mess_list	act.social.cpp	/^} *soc_mess_list;$/;"	v	typeref:struct:social_messg
social_messg	act.social.cpp	/^struct social_messg {$/;"	s	file:
socket_map	globals.cpp	/^		socket_map_t socket_map;$/;"	m	namespace:mods::globals	file:
socket_t	mods/ban_system.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/builder.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/chat.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/conf.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/immortal.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/js.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/projectile.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/quests.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/scan.hpp	/^typedef int socket_t;$/;"	t
socket_t	sysdep.h	/^typedef SOCKET		socket_t;$/;"	t
solo_gain	fight.cpp	/^void solo_gain(struct char_data *ch, struct char_data *victim) {$/;"	f
sort_commands	act.informative.cpp	/^void sort_commands(void) {$/;"	f
sort_commands	mods/hell.hpp	/^	constexpr inline bool sort_commands = false;$/;"	m	namespace:mods::hell
sort_commands_helper	act.informative.cpp	/^int sort_commands_helper(const void *a, const void *b) {$/;"	f
sort_keeper_objs	shop.cpp	/^void sort_keeper_objs(struct char_data *keeper, int shop_nr) {$/;"	f
sort_spells	mods/hell.hpp	/^	constexpr inline bool sort_spells = false;$/;"	m	namespace:mods::hell
sort_spells	spec_procs.cpp	/^void sort_spells(void) {$/;"	f
spare0	house.h	/^	long spare0;$/;"	m	struct:house_control_rec
spare0	structs.h	/^	int	spare0;$/;"	m	struct:rent_info
spare1	house.h	/^	long spare1;$/;"	m	struct:house_control_rec
spare1	structs.h	/^	int	spare1;$/;"	m	struct:rent_info
spare2	house.h	/^	long spare2;$/;"	m	struct:house_control_rec
spare2	structs.h	/^	int	spare2;$/;"	m	struct:rent_info
spare3	house.h	/^	long spare3;$/;"	m	struct:house_control_rec
spare3	structs.h	/^	int	spare3;$/;"	m	struct:rent_info
spare4	house.h	/^	long spare4;$/;"	m	struct:house_control_rec
spare4	structs.h	/^	int	spare4;$/;"	m	struct:rent_info
spare5	house.h	/^	long spare5;$/;"	m	struct:house_control_rec
spare5	structs.h	/^	int	spare5;$/;"	m	struct:rent_info
spare6	house.h	/^	long spare6;$/;"	m	struct:house_control_rec
spare6	structs.h	/^	int	spare6;$/;"	m	struct:rent_info
spare7	house.h	/^	long spare7;$/;"	m	struct:house_control_rec
spare7	structs.h	/^	int	spare7;$/;"	m	struct:rent_info
special	interpreter.cpp	/^int special(struct char_data *ch, int cmd, char *arg) {$/;"	f
spell_charm	spells.h	/^ASPELL(spell_charm);$/;"	v
spell_create_water	spells.h	/^ASPELL(spell_create_water);$/;"	v
spell_detect_poison	spells.h	/^ASPELL(spell_detect_poison);$/;"	v
spell_enchant_weapon	spells.h	/^ASPELL(spell_enchant_weapon);$/;"	v
spell_identify	spells.h	/^ASPELL(spell_identify);$/;"	v
spell_info	spell_parser.cpp	/^struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];$/;"	v	typeref:struct:spell_info_type
spell_info_type	spells.h	/^struct spell_info_type {$/;"	s
spell_information	spells.h	/^ASPELL(spell_information);$/;"	v
spell_level	spell_parser.cpp	/^void spell_level(int spell, int chclass, int level) {$/;"	f
spell_locate_object	spells.h	/^ASPELL(spell_locate_object);$/;"	v
spell_recall	spells.h	/^ASPELL(spell_recall);$/;"	v
spell_sort_info	spec_procs.cpp	/^int spell_sort_info[MAX_SKILLS + 1];$/;"	v
spell_summon	spells.h	/^ASPELL(spell_summon);$/;"	v
spell_teleport	spells.h	/^ASPELL(spell_teleport);$/;"	v
spello	spell_parser.cpp	/^void spello(int spl, const char *name, int max_mana, int min_mana,$/;"	f
split	mods/util-conf.hpp	/^			std::vector<std::string> split(const std::string& in_string,const std::string& delimiter,unsigned int limit = 1024) {$/;"	f	namespace:mods::util::text
sprintbit	utils.cpp	/^size_t sprintbit(bitvector_t bitvector, const char *names[], char *result, size_t reslen) {$/;"	f
sprinttype	utils.cpp	/^size_t sprinttype(int type, const char *names[], char *result, size_t reslen) {$/;"	f
sql	mods/sql.hpp	/^			str_object sql() {$/;"	f	struct:mods::sql::compositor
sql	mods/sql.hpp	/^namespace mods::sql {$/;"	n	class:mods
sql_compositor	mods/builder_util.hpp	/^typedef mods::sql::compositor<mods::pq::transaction> sql_compositor;$/;"	t
stack_data	shop.h	/^struct stack_data {$/;"	s
start	mods/drone.cpp	/^	 void drone::start(struct char_data* owner) {$/;"	f	class:mods::drone
start_quest	mods/quests.cpp	/^		void start_quest(struct char_data* ch,int quest_id) {$/;"	f	namespace:mods::quests
start_room	structs.h	/^	room_vnum start_room;$/;"	m	struct:room_pavement_t
started	mods/drone.cpp	/^	 bool drone::started(struct char_data* owner) {$/;"	f	class:mods::drone
state	mods/ai_state.hpp	/^			enum state {$/;"	g	class:mods::ai_state
state	mods/player.cpp	/^			int player::state(){$/;"	f	class:mods::player
state	structs.h	/^	ai_state_t state;$/;"	m	struct:char_data
state_fetch	globals.cpp	/^		std::unique_ptr<ai_state>& state_fetch(struct char_data* ch) {$/;"	f	namespace:mods::globals
states	globals.cpp	/^		ai_state_map states;$/;"	m	namespace:mods::globals	file:
status	mods/behaviour_tree_node.hpp	/^			behaviour_tree_status status;\\$/;"	m	struct:mods::behaviour_tree_node::__anon2
status_step_count	mods/lmdb.hpp	/^		constexpr static std::size_t status_step_count = 5;$/;"	m	struct:mods::lmdb::_db_handle
stc	mods/drone.hpp	/^			void stc(const char* m) {$/;"	f	class:mods::drone
stc	mods/drone.hpp	/^			void stc(const std::string m) {$/;"	f	class:mods::drone
stc	mods/drone.hpp	/^			void stc(int m) {$/;"	f	class:mods::drone
stc	mods/player.cpp	/^	void player::stc(const char* m) {$/;"	f	class:mods::player
stc	mods/player.cpp	/^	void player::stc(const std::string m) {$/;"	f	class:mods::player
stc	mods/player.cpp	/^	void player::stc(int m) {$/;"	f	class:mods::player
stc_color_evaluation	mods/player.cpp	/^	void stc_color_evaluation(const std::string& title,player* p) {$/;"	f	namespace:mods
stc_room	mods/player.cpp	/^	void player::stc_room(const room_rnum& rnum) {$/;"	f	class:mods::player
stc_room_desc	mods/player.cpp	/^	void player::stc_room_desc(const room_rnum& rnum) {$/;"	f	class:mods::player
stfu	mods/util-conf.hpp	/^			static bool stfu = true;$/;"	m	namespace:mods::util::conf
stoi	mods/util.cpp	/^		std::optional<int> stoi(std::string_view str) {$/;"	f	namespace:mods::util
stoi	mods/util.hpp	/^	T stoi(const std::string& i){$/;"	f	namespace:mods::util
stoi_optional	mods/util.hpp	/^	std::optional<T> stoi_optional(std::string_view str){$/;"	f	namespace:mods::util
stop	mods/drone.cpp	/^	 void drone::stop(struct char_data* owner) {$/;"	f	class:mods::drone
stop_fighting	fight.cpp	/^void stop_fighting(struct char_data *ch) {$/;"	f
stop_follower	utils.cpp	/^void stop_follower(struct char_data *ch) {$/;"	f
stop_snooping	act.wizard.cpp	/^void stop_snooping(struct char_data *ch) {$/;"	f
store_mail	mail.cpp	/^void store_mail(long to, long from, char *message_pointer) {$/;"	f
store_to_char	db.cpp	/^void store_to_char(struct char_file_u *st, struct char_data *ch) {$/;"	f
str	structs.h	/^		char	**str;			\/* for the modify-str system		*\/$/;"	m	struct:mods::descriptor_data
str	structs.h	/^	sbyte str;$/;"	m	struct:char_ability_data
str_add	structs.h	/^	sbyte str_add;      \/* 000 - 100 if strength 18             *\/$/;"	m	struct:char_ability_data
str_app	constants.cpp	/^cpp_extern const struct str_app_type str_app[] = {$/;"	v	typeref:struct:str_app_type
str_app	constants.hpp	/^cpp_extern const struct str_app_type str_app[] = {$/;"	v	typeref:struct:str_app_type
str_app_type	structs.h	/^struct str_app_type {$/;"	s
str_cmp	sysdep.h	326;"	d
str_cmp	utils.cpp	/^int str_cmp(const char *arg1, const char *arg2) {$/;"	f
str_escape	mods/jx.hpp	/^			std::string str_escape(const std::string& value) {$/;"	f	struct:mods::jx::compositor
str_object	mods/sql.hpp	/^typedef std::string str_object;$/;"	t
str_object	mods/sql.hpp	/^typedef std::string_view str_object;$/;"	t
strdup	utils.cpp	/^char *strdup(const char *source) {$/;"	f
string	mods/string.cpp	/^	string::string(){$/;"	f	class:mods::string
string	mods/string.cpp	/^	string::string(const char* str){$/;"	f	class:mods::string
string	mods/string.hpp	/^	struct string {$/;"	s	namespace:mods
string_add	modify.cpp	/^void string_add(mods::descriptor_data d, char *str) {$/;"	f
string_fields	modify.cpp	/^const char *string_fields[] = {$/;"	v
string_write	modify.cpp	/^void string_write(mods::descriptor_data d, char **writeto, size_t len, long mailto, void *data) {$/;"	f
strlcpy	utils.cpp	/^size_t strlcpy(char *dest, const char *source, size_t totalsize) {$/;"	f
strn_cmp	sysdep.h	333;"	d
strn_cmp	utils.cpp	/^int strn_cmp(const char *arg1, const char *arg2, int n) {$/;"	f
subcmd	interpreter.h	/^	int	subcmd;$/;"	m	struct:command_info
subcmd_args	mods/util.hpp	/^	inline std::optional<Container> subcmd_args(std::string argument,const char* subcmd) {$/;"	f	namespace:mods::util
success	mods/db.hpp	/^	constexpr static int_status_t success = 0;$/;"	m	namespace:mods::lmdb::error
sunlight	structs.h	/^	int	sunlight;	\/* And how much sun. *\/$/;"	m	struct:weather_data
super_users	globals.cpp	/^		const std::vector<std::string> super_users = {$/;"	m	namespace:mods::globals	file:
suspicious_roaming	mods/behaviour_tree_impl.hpp	/^			suspicious_roaming,$/;"	e	enum:mods::behaviour_tree_impl::type
swap	mods/catch.hpp	/^			void swap(Ptr& other) {$/;"	f	class:Catch::Ptr
syllable	spell_parser.cpp	/^struct syllable {$/;"	s	file:
syls	spell_parser.cpp	/^struct syllable syls[] = {$/;"	v	typeref:struct:syllable
t	mods/catch.hpp	/^			static T  const& t;$/;"	m	struct:Catch::Detail::IsStreamInsertable
table	mods/lmdb.hpp	/^		table_type_t table() const { return m_table; }$/;"	f	struct:mods::lmdb::transaction_t
table	mods/lmdb.hpp	/^		table_type_t table;$/;"	m	struct:mods::lmdb::_selector
table	mods/sql.hpp	/^			compositor<T>& table(str_object table) {$/;"	f	struct:mods::sql::compositor
table_cstr	mods/lmdb.hpp	/^		std::string table_cstr() const { return m_str_table; }$/;"	f	struct:mods::lmdb::transaction_t
tail	db.h	/^	struct reset_q_element *tail;$/;"	m	struct:reset_q_type	typeref:struct:reset_q_type::reset_q_element
tail	structs.h	/^	struct txt_block *tail;$/;"	m	struct:txt_q	typeref:struct:txt_q::txt_block
talks	structs.h	/^	std::array<bool,max_tongue> talks;	\/* PC s Tongues 0 for NPC		*\/$/;"	m	struct:player_special_data_saved
targets	spells.h	/^	int targets;         \/* See below for use with TAR_XXX  *\/$/;"	m	struct:spell_info_type
telcmds	telnet.h	/^char *telcmds[] = {$/;"	v
telopts	telnet.h	/^char *telopts[NTELOPTS+1] = {$/;"	v
temper1	shop.h	/^	int	 temper1;		\/* How does keeper react if no money	*\/$/;"	m	struct:shop_data
test	mods/js.cpp	/^		namespace test {$/;"	n	namespace:mods::js	file:
text	mods/util-conf.hpp	/^		namespace text {$/;"	n	namespace:mods::util
text	structs.h	/^	char	*text;$/;"	m	struct:txt_block
text_overflow	comm.cpp	/^const char *text_overflow = "**OVERFLOW**\\r\\n";$/;"	v
thaco	class.cpp	/^int thaco(int class_num, int level) {$/;"	f
thief	spec_assign.cpp	/^SPECIAL(thief);$/;"	v
thief	spec_procs.cpp	/^SPECIAL(thief);$/;"	v
three_arguments	interpreter.cpp	/^char* three_arguments(char* argument,char *first_arg,char* second_arg,char* third_arg) {$/;"	f
tics	comm.cpp	/^uint64_t tics = 0;			\/* for extern checkpointing *\/$/;"	v
tim	castle.cpp	/^SPECIAL(tim);$/;"	v
time	mods/player.cpp	/^			player::time_type_t player::time() const {$/;"	f	class:mods::player
time	structs.h	/^	int	time;$/;"	m	struct:rent_info
time	structs.h	/^	struct time_data time;  \/* PC's AGE in days                 *\/$/;"	m	struct:char_player_data	typeref:struct:char_player_data::time_data
time_data	structs.h	/^struct time_data {$/;"	s
time_info	db.cpp	/^struct time_info_data time_info;\/* the infomation about the time    *\/$/;"	v	typeref:struct:time_info_data
time_info_data	structs.h	/^struct time_info_data {$/;"	s
timeadd	comm.cpp	/^void timeadd(struct timeval *rslt, struct timeval *a, struct timeval *b) {$/;"	f
timediff	comm.cpp	/^void timediff(struct timeval *rslt, struct timeval *a, struct timeval *b) {$/;"	f
timer	structs.h	/^	int	timer;			\/* Timer for update			*\/$/;"	m	struct:char_special_data
timer	structs.h	/^	int	timer;		\/* Timer for object                 *\/$/;"	m	struct:obj_flag_data
timer	structs.h	/^	int	timer;$/;"	m	struct:obj_file_elem
times_message	shop.cpp	/^char *times_message(struct obj_data *obj, char *name, int num) {$/;"	f
title	mods/builder.cpp	/^	bool title(room_rnum room_id,std::string_view str_title) {$/;"	f	namespace:mods::builder
title	structs.h	/^	mods::string title;        \/* PC \/ NPC's title                     *\/$/;"	m	struct:char_player_data
title	structs.h	/^	mods::string title;$/;"	m	struct:char_file_u
title_female	class.cpp	/^const char *title_female(int chclass, int level) {$/;"	f
title_male	class.cpp	/^const char *title_male(int chclass, int level) {$/;"	f
to	mail.h	/^	long to;			\/* idnum of mail's recipient		*\/$/;"	m	struct:header_data_type
toString	mods/catch.hpp	/^					std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::MatcherUntypedBase
toString	mods/catch.hpp	/^	std::string toString(std::vector<T,Allocator> const& v) {$/;"	f	namespace:Catch
to_hex_digit	mods/util-conf.hpp	/^			char to_hex_digit(unsigned int target) {$/;"	f	namespace:mods::util::conf
to_room	structs.h	/^	room_rnum to_room;		\/* Where direction leads (NOWHERE)	*\/$/;"	m	struct:room_direction_data
todam	structs.h	/^	sh_int todam;    \/* Damage Bonus\/Penalty                *\/$/;"	m	struct:str_app_type
tohex	mods/util-conf.hpp	/^			std::string tohex(char c) {$/;"	f	namespace:mods::util::conf
tohit	structs.h	/^	sh_int tohit;    \/* To Hit (THAC0) Bonus\/Penalty        *\/$/;"	m	struct:str_app_type
tom	castle.cpp	/^SPECIAL(tom);$/;"	v
top	db.h	/^	uint64_t top;           \/* upper limit for rooms in this zone *\/$/;"	m	struct:zone_data
top	shop.cpp	/^int top(struct stack_data *stack) {$/;"	f
top_idnum	db.cpp	/^long top_idnum = 0;		\/* highest idnum in use		 *\/$/;"	v
top_of_helpt	db.cpp	/^int top_of_helpt = 0;		\/* top of help index table	 *\/$/;"	v
top_of_mobt	db.cpp	/^mob_rnum top_of_mobt = 0;	\/* top of mobile index table	 *\/$/;"	v
top_of_objt	db.cpp	/^obj_rnum top_of_objt = 0;	\/* top of object index table	 *\/$/;"	v
top_of_p_table	db.cpp	/^int top_of_p_table = 0;		\/* ref to top of table		 *\/$/;"	v
top_of_world	db.cpp	/^room_rnum top_of_world = 0;	\/* ref to top element of world	 *\/$/;"	v
top_of_zone_table	db.cpp	/^zone_rnum top_of_zone_table = 0;\/* top element of zone tab	 *\/$/;"	v
top_shop	shop.cpp	/^int top_shop = -1;$/;"	v
touch	utils.cpp	/^int touch(const char *path) {$/;"	f
track_through_doors	config.cpp	/^int track_through_doors = YES;$/;"	v
trade_letters	shop.cpp	/^const char *trade_letters[] = {$/;"	v
trade_with	shop.cpp	/^int trade_with(struct obj_data *item, int shop_nr) {$/;"	f
training_master	castle.cpp	/^SPECIAL(training_master);$/;"	v
transact_id	structs.h	/^	int transact_id;$/;"	m	struct:room_pavement_t
transact_type_t	mods/lmdb.hpp	/^	enum transact_type_t {$/;"	g	namespace:mods::lmdb
transaction	mods/pq.hpp	/^	inline void transaction(void){}$/;"	f	namespace:pq
transaction_amt	shop.cpp	/^int transaction_amt(char *arg) {$/;"	f
transaction_t	mods/lmdb.cpp	/^	transaction_t::transaction_t(std::string ce_table,transact_type_t type) : m_type(type){$/;"	f	class:mods::lmdb::transaction_t
transaction_t	mods/lmdb.cpp	/^	transaction_t::transaction_t(table_type_t e_table,transact_type_t type) : m_table(e_table), m_type(type){$/;"	f	class:mods::lmdb::transaction_t
transaction_t	mods/lmdb.hpp	/^	struct transaction_t {$/;"	s	namespace:mods::lmdb
transmit	mods/chat.cpp	/^	void channel::transmit(std::string_view user,std::string_view message) {$/;"	f	class:mods::chat::channel
traps	structs.h	/^	sh_int traps;$/;"	m	struct:dex_skill_type
trees	mods/behaviour_tree_impl.cpp	/^	container_t trees;$/;"	m	namespace:mods::behaviour_tree_impl	file:
trigger_exists	mods/quests.cpp	/^		bool trigger_exists(struct char_data *ch,int quest_id) {$/;"	f	namespace:mods::quests
trigger_key	mods/quests.cpp	/^		std::string trigger_key(struct char_data *ch,room_rnum room,int n_index) {$/;"	f	namespace:mods::quests
trueValue	mods/catch.hpp	/^			void trueValue() const {}$/;"	f	class:Catch::SafeBool
tunnel_size	config.cpp	/^int tunnel_size = 2;$/;"	v
two_arguments	interpreter.cpp	/^char *two_arguments(char *argument, char *first_arg, char *second_arg) {$/;"	f
txt	mail.h	/^	char	txt[DATA_BLOCK_DATASIZE+1]; \/* actual text plus 1 for null	*\/$/;"	m	struct:data_block_type_d
txt	mail.h	/^	char	txt[HEADER_BLOCK_DATASIZE+1]; \/* actual text plus 1 for null	*\/$/;"	m	struct:header_block_type_d
txt_block	structs.h	/^struct txt_block {$/;"	s
txt_q	structs.h	/^struct txt_q {$/;"	s
type	act.wizard.cpp	/^	const char type;$/;"	m	struct:set_struct	file:
type	db.h	/^	int	type;$/;"	m	struct:ban_list_element
type	interpreter.h	/^	int type;$/;"	m	struct:alias_data
type	mods/behaviour_tree_impl.hpp	/^		enum type { $/;"	g	namespace:mods::behaviour_tree_impl
type	mods/lmdb.hpp	/^		transact_type_t type() const { return m_type; }$/;"	f	struct:mods::lmdb::transaction_t
type	mods/object.hpp	/^	enum type {$/;"	g	namespace:mods::object
type	mods/player.hpp	/^			player_type_enum_t type(){$/;"	f	class:mods::player
type	shop.h	/^	int type;$/;"	m	struct:shop_buy_data
type	shop.h	/^	struct shop_buy_data *type;	\/* Which items to trade			*\/$/;"	m	struct:shop_data	typeref:struct:shop_data::shop_buy_data
type	structs.h	/^	int16_t type;$/;"	m	struct:obj_data
type	structs.h	/^	sh_int type;          \/* The type of spell that caused this      *\/$/;"	m	struct:affected_type
type2_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,3> type2_flags = { {$/;"	m	namespace:mods::builder	file:
type_flag	structs.h	/^	byte type_flag;	\/* Type of item			    *\/$/;"	m	struct:obj_flag_data
type_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,23> type_flags = { {$/;"	m	namespace:mods::builder	file:
ubyte	structs.h	/^typedef unsigned char		ubyte;$/;"	t
unequip_char	handler.cpp	/^struct obj_data *unequip_char(struct char_data *ch, int pos) {$/;"	f
unregister_mob	mods/behaviour_tree_impl.cpp	/^	void unregister_mob(const argument_type & mob){$/;"	f	namespace:mods::behaviour_tree_impl
unrestrict_game	comm.cpp	/^RETSIGTYPE unrestrict_game(int sig) {$/;"	f
unsafe_code	mods/js.cpp	/^		static duk_ret_t unsafe_code(duk_context *ctx,void* udata) {$/;"	f	namespace:mods::js
unused_spell	spell_parser.cpp	/^void unused_spell(int spl) {$/;"	f
unused_spellname	spell_parser.cpp	/^const char *unused_spellname = "!UNUSED!"; \/* So we can get &unused_spellname *\/$/;"	v
update	mods/lmdb.hpp	/^	inline transaction_ptr update(std::string table){$/;"	f	namespace:mods::lmdb
update	mods/lmdb.hpp	/^	inline transaction_ptr update(table_type_t table){$/;"	f	namespace:mods::lmdb
update	mods/sql.hpp	/^			compositor<T>& update(str_object table) {$/;"	f	struct:mods::sql::compositor
update_char_objects	handler.cpp	/^void update_char_objects(struct char_data *ch) {$/;"	f
update_db	config.cpp	/^	void update_db(std::string option,std::string value){$/;"	f	namespace:config
update_obj_file	mods/hell.hpp	/^	constexpr inline bool update_obj_file = false;$/;"	m	namespace:mods::hell
update_obj_file	objsave.cpp	/^void update_obj_file(void) {$/;"	f
update_object	handler.cpp	/^void update_object(struct obj_data *obj, int use) {$/;"	f
update_pos	fight.cpp	/^void update_pos(struct char_data *victim) {$/;"	f
update_zone_commands	mods/builder.cpp	/^	std::pair<bool,std::string> update_zone_commands(int zone_id) {$/;"	f	namespace:mods::builder
use_autowiz	config.cpp	/^int use_autowiz = YES;$/;"	v
use_pluck_filter	mods/lmdb.cpp	/^		void _db_handle::use_pluck_filter(bool b){$/;"	f	class:mods::lmdb::_db_handle
ush_int	structs.h	/^typedef unsigned short int	ush_int;$/;"	t
util	mods/util-conf.hpp	/^	namespace util {$/;"	n	namespace:mods
util	mods/util-map.hpp	/^	namespace util {$/;"	n	namespace:mods
util	mods/util.cpp	/^	namespace util {$/;"	n	namespace:mods	file:
util	mods/util.hpp	/^namespace mods::util {$/;"	n	class:mods
utils	globals.hpp	/^	namespace utils {$/;"	n	namespace:mods
utils	mods/js.cpp	/^		namespace utils {$/;"	n	namespace:mods::js	file:
uuid	mods/drone.hpp	/^			uuid_t uuid() const {$/;"	f	class:mods::drone
uuid	mods/js.cpp	/^		static duk_ret_t uuid(duk_context *ctx) {$/;"	f	namespace:mods::js
uuid	mods/player.hpp	/^			uuid_t& uuid() const {$/;"	f	class:mods::player
uuid	structs.h	/^	uuid_t uuid;$/;"	m	struct:char_data
uuid	structs.h	/^	uuid_t uuid;$/;"	m	struct:obj_data
uuid_t	structs.h	/^typedef uint64_t uuid_t;$/;"	t
value	mods/catch.hpp	/^			enum { value = sizeof(testStreamable(s << t)) == sizeof(TrueType) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon3
value	structs.h	/^	int	value[4];	\/* Values of the item (see list)    *\/$/;"	m	struct:obj_flag_data
value	structs.h	/^	int	value[4];$/;"	m	struct:obj_file_elem
value_callback	mods/builder_util.hpp	/^	typedef std::function<void(sql_compositor::value_map&)> value_callback;$/;"	t	namespace:mods::builder_util
value_map	mods/sql.hpp	/^			typedef std::map<std::string, std::string> value_map;$/;"	t	struct:mods::sql::compositor
values	mods/lmdb.cpp	/^	tuple_status_t transaction_t::values($/;"	f	class:mods::lmdb::transaction_t
values	mods/sql.hpp	/^			compositor<T>& values(const value_map& values) {$/;"	f	struct:mods::sql::compositor
vec_player_data	mods/scan.hpp	/^		typedef std::vector<vec_player_data_element> vec_player_data;$/;"	t	namespace:mods::scan
vec_player_data_element	mods/scan.hpp	/^		} vec_player_data_element;$/;"	t	namespace:mods::scan	typeref:struct:mods::scan::__anon4
vict_found	act.social.cpp	/^	char *vict_found;$/;"	m	struct:social_messg	file:
victim_msg	structs.h	/^	char	*victim_msg;    \/* message to victim   *\/$/;"	m	struct:msg_type
violent	spells.h	/^	byte violent;$/;"	m	struct:spell_info_type
vnum	boards.h	/^	obj_vnum vnum;	\/* vnum of this board *\/$/;"	m	struct:board_info_type
vnum	house.h	/^	room_vnum vnum;		\/* vnum of this house		*\/$/;"	m	struct:house_control_rec
vnum	shop.h	/^	room_vnum vnum;		\/* Virtual number of this shop		*\/$/;"	m	struct:shop_data
vnum	structs.h	/^	mob_vnum	vnum;	\/* virtual number of this mob\/obj		*\/$/;"	m	struct:index_data
vnum_mobile	db.cpp	/^int vnum_mobile(char *searchname, struct char_data *ch) {$/;"	f
vnum_object	db.cpp	/^int vnum_object(char *searchname, struct char_data *ch) {$/;"	f
vsnprintf	bsd-snprintf.cpp	/^vsnprintf(char *str, size_t count, const char *fmt, va_list args) {$/;"	f
vsnprintf	sysdep.h	351;"	d
vwrite_to_output	comm.cpp	/^size_t vwrite_to_output(mods::descriptor_data &t, const char *format, va_list args) {$/;"	f
wait	structs.h	/^	int wait;				 \/* wait for how many loops	  *\/$/;"	m	struct:char_data
was_in_room	structs.h	/^	room_rnum was_in_room;		 \/* location for linkdead people  *\/$/;"	m	struct:char_data
weapon	mods/player.cpp	/^	obj_data* player::weapon() {$/;"	f	class:mods::player
weapon	mods/player.hpp	/^	namespace weapon {$/;"	n	namespace:mods
weapon	mods/weapon.hpp	/^	namespace weapon {$/;"	n	namespace:mods
weapon_cooldown_expired	mods/player.cpp	/^	bool player::weapon_cooldown_expired(weapon_set set) {$/;"	f	class:mods::player
weapon_cooldown_start	mods/player.cpp	/^	void player::weapon_cooldown_start(unsigned long duration,weapon_set set) {$/;"	f	class:mods::player
weapon_set	mods/drone.hpp	/^			typedef short weapon_set;$/;"	t	class:mods::drone
weapon_set	mods/player.hpp	/^			typedef short weapon_set;$/;"	t	class:mods::player
weapon_type	structs.h	/^	weapon_type_t weapon_type;$/;"	m	struct:obj_data
weapon_type_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,4> weapon_type_flags = { {$/;"	m	namespace:mods::builder	file:
weapon_type_t	structs.h	/^typedef std::size_t weapon_type_t;$/;"	t
wear_bits	constants.cpp	/^const char *wear_bits[] = {$/;"	v
wear_bits	constants.hpp	/^const char *wear_bits[] = {$/;"	v
wear_bits_count	constants.cpp	/^        wear_bits_count = sizeof(wear_bits) \/ sizeof(wear_bits[0]) - 1;$/;"	v
wear_bits_count	constants.hpp	/^	wear_bits_count = sizeof(wear_bits) \/ sizeof(wear_bits[0]) - 1;$/;"	v
wear_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,15> wear_flags = { {$/;"	m	namespace:mods::builder	file:
wear_flags	structs.h	/^	int \/*bitvector_t*\/	wear_flags;	\/* Where you can wear it	    *\/$/;"	m	struct:obj_flag_data
wear_message	act.item.cpp	/^void wear_message(struct char_data *ch, struct obj_data *obj, int where) {$/;"	f
wear_off_msg	spells.h	/^	const char *wear_off_msg;	\/* Input size not limited. Originates from string constants. *\/$/;"	m	struct:spell_info_type
wear_where	constants.cpp	/^const char *wear_where[] = {$/;"	v
wear_where	constants.hpp	/^const char *wear_where[] = {$/;"	v
weather_and_time	weather.cpp	/^void weather_and_time(int mode) {$/;"	f
weather_change	weather.cpp	/^void weather_change(void) {$/;"	f
weather_data	structs.h	/^struct weather_data {$/;"	s
weather_info	db.cpp	/^struct weather_data weather_info;	\/* the infomation about the weather *\/$/;"	v	typeref:struct:weather_data
weekdays	constants.cpp	/^const char *weekdays[] = {$/;"	v
weekdays	constants.hpp	/^const char *weekdays[] = {$/;"	v
weight	structs.h	/^	int	weight;		\/* Weigt what else                  *\/$/;"	m	struct:obj_flag_data
weight	structs.h	/^	int	weight;$/;"	m	struct:obj_file_elem
weight	structs.h	/^	ubyte weight;       \/* PC \/ NPC's weight                    *\/$/;"	m	struct:char_player_data
weight	structs.h	/^	ubyte weight;$/;"	m	struct:char_file_u
weight_change_object	act.item.cpp	/^void weight_change_object(struct obj_data *obj, int weight) {$/;"	f
where	mods/sql.hpp	/^			compositor<T>& where(str_object lhs,$/;"	f	struct:mods::sql::compositor
wield_w	structs.h	/^	sh_int wield_w;  \/* Maximum weight that can be wielded  *\/$/;"	m	struct:str_app_type
wimp_level	structs.h	/^	int	wimp_level;		\/* Below this # of hit points, flee!	*\/$/;"	m	struct:player_special_data_saved
wis	structs.h	/^	sbyte wis;$/;"	m	struct:char_ability_data
wis_app	constants.cpp	/^cpp_extern const struct wis_app_type wis_app[] = {$/;"	v	typeref:struct:wis_app_type
wis_app	constants.hpp	/^cpp_extern const struct wis_app_type wis_app[] = {$/;"	v	typeref:struct:wis_app_type
wis_app_type	structs.h	/^struct wis_app_type {$/;"	s
with_who	shop.h	/^	int	 with_who;		\/* Who does the shop trade with?	*\/$/;"	m	struct:shop_data
wizlist	db.cpp	/^char *wizlist = NULL;		\/* list of higher gods		 *\/$/;"	v
word_wrap	mods/player.cpp	/^	std::string word_wrap(std::string_view paragraph,int width) {$/;"	f	namespace:mods
world	db.cpp	/^std::vector<room_data> world;	\/* array of rooms		 *\/$/;"	v
worn_by	structs.h	/^	struct char_data *worn_by;	  \/* Worn by?			      *\/$/;"	m	struct:obj_data	typeref:struct:obj_data::char_data
worn_on	structs.h	/^	sh_int worn_on;		  \/* Worn where?		      *\/$/;"	m	struct:obj_data
write	comm.cpp	1471;"	d	file:
write_aliases	alias.cpp	/^void write_aliases(struct char_data *ch) {$/;"	f
write_ban_list	ban.cpp	/^void write_ban_list(void) {$/;"	f
write_lvl	boards.h	/^	int	write_lvl;	\/* min level to write messages on this board *\/$/;"	m	struct:board_info_type
write_meta	mods/meta_utils.hpp	/^	void write_meta(std::string table,mutable_map_t* values){$/;"	f	namespace:mods::meta_utils
write_to_descriptor	comm.cpp	/^int write_to_descriptor(socket_t desc, const char *txt) {$/;"	f
write_to_file	mail.cpp	/^void write_to_file(void *buf, int size, long filepos) {$/;"	f
write_to_output	comm.cpp	/^size_t write_to_output(mods::descriptor_data &t, const char *txt, ...) {$/;"	f
write_to_q	comm.cpp	/^void write_to_q(const char *txt, struct txt_q *queue, int aliased) {$/;"	f
xEOF	telnet.h	61;"	d
year	structs.h	/^	sh_int year;$/;"	m	struct:time_info_data
zone	structs.h	/^	zone_rnum zone;              \/* Room zone (for resetting)          *\/$/;"	m	struct:room_data
zone_data	db.h	/^struct zone_data {$/;"	s
zone_id	structs.h	/^	int zone_id;$/;"	m	struct:room_pavement_t
zone_pave_mode	mods/player.cpp	/^			bool player::zone_pave_mode(){$/;"	f	class:mods::player
zone_pave_mode	structs.h	/^	bool zone_pave_mode;$/;"	m	struct:builder_data_t
zone_pavement_t	structs.h	/^struct zone_pavement_t {$/;"	s
zone_pavements	structs.h	/^	zone_pavement_t zone_pavements;$/;"	m	struct:builder_data_t
zone_place	mods/builder.cpp	/^	std::pair<bool,std::string> zone_place(int zone_id,std::string_view zone_command,std::string_view if_flag,std::string_view arg1,std::string_view arg2,std::string_view arg3) {$/;"	f	namespace:mods::builder
zone_rnum	structs.h	/^typedef IDXTYPE zone_rnum;$/;"	t
zone_table	db.cpp	/^std::vector<zone_data> zone_table;	\/* zone table			 *\/$/;"	v
zone_to_reset	db.h	/^	zone_rnum zone_to_reset;            \/* ref to zone_data *\/$/;"	m	struct:reset_q_element
zone_update	db.cpp	/^void zone_update(void) {$/;"	f
zone_vnum	structs.h	/^typedef IDXTYPE zone_vnum;$/;"	t
~DecomposedExpression	mods/catch.hpp	/^			virtual ~DecomposedExpression() {}$/;"	f	struct:Catch::DecomposedExpression
~MethodTestCase	mods/catch.hpp	/^			virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase
~Ptr	mods/catch.hpp	/^			~Ptr() {$/;"	f	class:Catch::Ptr
~_db_handle	mods/lmdb.cpp	/^	_db_handle::~_db_handle(){$/;"	f	class:mods::lmdb::_db_handle
~player	mods/player.cpp	/^	player::~player(){$/;"	f	class:mods::player
~string	mods/string.cpp	/^	string::~string(){$/;"	f	class:mods::string
