!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABORT	telnet.h	59;"	d
ABSORB_DAMAGE	mods/weapon-types.hpp	/^		ABSORB_DAMAGE,$/;"	e	enum:mods::weapon::capabilities::cap_t
ACCURACY	mods/skills.hpp	/^			ACCURACY,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ACMD	act.builder.cpp	/^ACMD(do_flush_holding){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_histfile){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_hold_anything){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_next_mob_number){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_next_obj_number){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_next_object_number){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_next_room_number){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_next_zone_number){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_pmw_obj_from_room){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_toggle_obj_from_room){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_uuid){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_yaml_example){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_yaml_import){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_yaml_log){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_yaml_log_clear){$/;"	f
ACMD	act.builder.cpp	/^ACMD(do_yaml_log_save){$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_gen_comm) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_gsay) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_qcomm) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_reply) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_say) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_spec_comm) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_tell) {$/;"	f
ACMD	act.comm.cpp	/^ACMD(do_write) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_feed_player){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_flush_player){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_get_ticks_per_minute){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_camera) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_emp_grenades) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_flashbang_grenades) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_frag_grenades) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_incendiary_grenades) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_night_vision_camera) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_sensor_grenades) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_smoke_grenades) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_sniper_rifle) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_giveme_thermal_camera) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_givemenades){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_my_uuid) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_one_punch){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_point_update) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_room_dark){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_room_fire){$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_room_list_uuid) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_send_report) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_set_ammo) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_set_npc_position) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_set_position) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_show_tics) {$/;"	f
ACMD	act.debug.cpp	/^ACMD(do_zero_socket) {$/;"	f
ACMD	act.demolitions.cpp	/^ACMD(do_breach) {$/;"	f
ACMD	act.demolitions.cpp	/^ACMD(do_cancel) {$/;"	f
ACMD	act.demolitions.cpp	/^ACMD(do_install) {$/;"	f
ACMD	act.demolitions.cpp	/^ACMD(do_thermite) {$/;"	f
ACMD	act.demolitions.cpp	/^ACMD(do_uninstall) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_color) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_commands) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_consider) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_diagnose) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_drone) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_equipment) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_examine) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_exits) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_gen_ps) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_givemegold) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_gold) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_help) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_inventory) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_js) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_jstest) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_levels) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_look) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_newjs) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_preferences) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_quest) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_recall) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_score) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_time) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_toggle) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_users) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_view) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_weather) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_where) {$/;"	f
ACMD	act.informative.cpp	/^ACMD(do_who) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_drink) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_drop) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_eat) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_get) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_give) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_grab) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_pour) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_put) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_remove) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_wear) {$/;"	f
ACMD	act.item.cpp	/^ACMD(do_wield) {$/;"	f
ACMD	act.medic.cpp	/^ACMD(do_heal) {$/;"	f
ACMD	act.medic.cpp	/^ACMD(do_revive) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_enter) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_follow) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_gen_door) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_leave) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_move) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_rest) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_sit) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_sleep) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_stand) {$/;"	f
ACMD	act.movement.cpp	/^	ACMD(do_wake) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(c4_brain) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_affect_me) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_assist) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_backstab) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_bash) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_command_sequence) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_engagement_mode) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_flee) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_go_loud) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_hit) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_kick) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_kill) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_order) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_regroup) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_reload) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_rescue) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_scan) { \/* !mods *\/$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_silencers_off) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_silencers_on) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_snipe) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_spray) {$/;"	f
ACMD	act.offensive.cpp	/^ACMD(do_throw) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_display) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_gen_tog) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_gen_write) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_group) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_hide) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_not_here) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_practice) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_quit) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_report) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_save) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_sneak) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_split) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_steal) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_title) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_ungroup) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_use) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_visible) {$/;"	f
ACMD	act.other.cpp	/^ACMD(do_wimpy) {$/;"	f
ACMD	act.social.cpp	/^ACMD(do_action) {$/;"	f
ACMD	act.social.cpp	/^ACMD(do_insult) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_advance) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_at) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_date) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_dc) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_echo) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_force) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_gecho) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_goto) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_invis) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_last) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_load) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_poofset) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_purge) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_restore) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_return) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_send) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_set) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_show) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_shutdown){$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_snoop) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_stat) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_switch) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_syslog) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_teleport) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_trans) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_vnum) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_vstat) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wiz_quote) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wizlock) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wiznet) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_wizutil) {$/;"	f
ACMD	act.wizard.cpp	/^ACMD(do_zreset) {$/;"	f
ACMD	ban.cpp	/^ACMD(do_ban) {$/;"	f
ACMD	ban.cpp	/^ACMD(do_unban) {$/;"	f
ACMD	db.cpp	/^ACMD(do_reboot) {$/;"	f
ACMD	graph.cpp	/^ACMD(do_track) {$/;"	f
ACMD	house.cpp	/^ACMD(do_hcontrol) {$/;"	f
ACMD	house.cpp	/^ACMD(do_house) {$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_alias) {$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_builder){$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_builder_help){$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_js_help){$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_require_js){$/;"	f
ACMD	interpreter.cpp	/^ACMD(do_room_list){$/;"	f
ACMD	interpreter.h	14;"	d
ACMD	limits.cpp	/^ACMD(do_idle){$/;"	f
ACMD	modify.cpp	/^ACMD(do_skillset) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_mbuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_obuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_rbuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_rbuild_sandbox) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_sbuild) {$/;"	f
ACMD	mods/builder.cpp	/^ACMD(do_zbuild) {$/;"	f
ACMD	mods/chat.cpp	/^ACMD(do_chanmgr) {$/;"	f
ACMD	mods/immortal.cpp	/^ACMD(do_rnumlist) {$/;"	f
ACMD	mods/immortal.cpp	/^ACMD(do_rnumtele) {$/;"	f
ACMD	mods/prefs.cpp	/^ACMD(do_pref) {$/;"	f
ACMD	mods/skills.cpp	/^ACMD(do_skills){$/;"	f
ACMD	olc.cpp	/^ACMD(do_olc) {$/;"	f
ACMD	shop.cpp	/^ACMD(do_buy){$/;"	f
ACMD	shop.cpp	/^ACMD(do_list){$/;"	f
ACMD	spell_parser.cpp	/^ACMD(do_cast) {$/;"	f
ACMD_EXAMINE	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_LOOK	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_READ	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_REMOVE	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACMD_WRITE	boards.cpp	/^int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;$/;"	v
ACOG	mods/weapon.hpp	/^		ACOG, LASER_DOT, HOLOGRAPHIC,$/;"	e	enum:mods::weapon::scope_t
ACTNULL	comm.cpp	/^const char *ACTNULL = "<NULL>";$/;"	v
ADRENALINE_BOOST	mods/skills.hpp	/^			ADRENALINE_BOOST,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ADVANCED_ARMOR	mods/skills.hpp	/^			ADVANCED_ARMOR,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ADVANCED_ASSAULT_RIFLE	mods/skills.hpp	/^			ADVANCED_ASSAULT_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ADVANCED_PISTOL	mods/skills.hpp	/^			ADVANCED_PISTOL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ADVANCED_SHOTGUN	mods/skills.hpp	/^			ADVANCED_SHOTGUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ADVANCED_SNIPER_RIFLE	mods/skills.hpp	/^			ADVANCED_SNIPER_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ADVANCED_SUB_MACHINE_GUN	mods/skills.hpp	/^			ADVANCED_SUB_MACHINE_GUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
AERIAL_DRONE	structs.h	/^	AERIAL_DRONE,$/;"	e	enum:lense_type_t
AERIAL_DRONE_NIGHT_VISION	structs.h	/^	AERIAL_DRONE_NIGHT_VISION,$/;"	e	enum:lense_type_t
AERIAL_DRONE_THERMAL	structs.h	/^	AERIAL_DRONE_THERMAL,$/;"	e	enum:lense_type_t
AFF	mods/affects.hpp	280;"	d
AFF	mods/flags.hpp	/^		AFF,PLR$/;"	e	enum:mods::flags::flag_group
AFFECT_DISSOLVE_COUNT	mods/affects.hpp	/^	constexpr static std::size_t AFFECT_DISSOLVE_COUNT = affect_t::__AFFECT_SIZE;$/;"	m	namespace:mods::affects
AFFECT_MAP	mods/affects.hpp	/^	constexpr static int AFFECT_MAP[] = {$/;"	m	namespace:mods::affects
AFFECT_MOVE	mods/weapon-types.hpp	/^		AFFECT_MOVE,$/;"	e	enum:mods::weapon::capabilities::cap_t
AFF_BLIND	structs.h	330;"	d
AFF_CHARM	structs.h	351;"	d
AFF_CURSE	structs.h	339;"	d
AFF_DETECT_ALIGN	structs.h	332;"	d
AFF_DETECT_INVIS	structs.h	333;"	d
AFF_DETECT_MAGIC	structs.h	334;"	d
AFF_DISORIENT	structs.h	352;"	d
AFF_FLAGGED	utils.h	237;"	d
AFF_FLAGS	utils.h	223;"	d
AFF_FLAG_COUNT	mods/flags.hpp	/^	constexpr static uint64_t AFF_FLAG_COUNT = aff::__AFF_LAST + 1;$/;"	m	namespace:mods::flags
AFF_GROUP	structs.h	338;"	d
AFF_HIDE	structs.h	349;"	d
AFF_INFRAVISION	structs.h	340;"	d
AFF_INTIMIDATED	structs.h	336;"	d
AFF_INVISIBLE	structs.h	331;"	d
AFF_NOTRACK	structs.h	345;"	d
AFF_POISON	structs.h	341;"	d
AFF_PROTECT_EVIL	structs.h	342;"	d
AFF_PROTECT_GOOD	structs.h	343;"	d
AFF_SANCTUARY	structs.h	337;"	d
AFF_SCANNED	structs.h	353;"	d
AFF_SENSE_LIFE	structs.h	335;"	d
AFF_SLEEP	structs.h	344;"	d
AFF_SNEAK	structs.h	348;"	d
AFF_UNUSED16	structs.h	346;"	d
AFF_UNUSED17	structs.h	347;"	d
AFF_UNUSED20	structs.h	350;"	d
AGGRESSIVE_PROTECT	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
AIM	mods/weapon-types.hpp	/^		AIM,$/;"	e	enum:mods::weapon::capabilities::cap_t
AI_EVENT_ATTACKER_FOUND	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
AI_EVENT_SNIPED	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
AI_EVENT_WANDER	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
AI_WITNESS_ATTACK	mods/ai_state.hpp	/^				AI_EVENT_SNIPED,AI_EVENT_ATTACKER_FOUND,AI_WITNESS_ATTACK,AI_EVENT_WANDER,$/;"	e	enum:mods::ai_state::event_type_t
ALIAS_COMPLEX	interpreter.h	70;"	d
ALIAS_FILE	utils.h	125;"	d
ALIAS_GLOB_CHAR	interpreter.h	74;"	d
ALIAS_SEP_CHAR	interpreter.h	72;"	d
ALIAS_SIMPLE	interpreter.h	69;"	d
ALIAS_VAR_CHAR	interpreter.h	73;"	d
ALTERNATE_EXPLOSION	mods/weapon-types.hpp	/^		ALTERNATE_EXPLOSION,$/;"	e	enum:mods::weapon::capabilities::cap_t
ALTEX_EMP	mods/yaml.hpp	/^	ALTEX_EMP = (1 << 2),$/;"	e	enum:alternate_explosion_t
ALTEX_FLASHBANG	mods/yaml.hpp	/^	ALTEX_FLASHBANG = (1 << 4)$/;"	e	enum:alternate_explosion_t
ALTEX_INCENDIARY	mods/yaml.hpp	/^	ALTEX_INCENDIARY = (1 << 3),$/;"	e	enum:alternate_explosion_t
ALTEX_NONE	mods/yaml.hpp	/^	ALTEX_NONE = 0,$/;"	e	enum:alternate_explosion_t
ALTEX_SCAN	mods/yaml.hpp	/^	ALTEX_SCAN = (1),$/;"	e	enum:alternate_explosion_t
ALTEX_SMOKE	mods/yaml.hpp	/^	ALTEX_SMOKE = (1 << 1),$/;"	e	enum:alternate_explosion_t
AMMO	mods/weapon.hpp	13;"	d
AN	utils.h	161;"	d
ANA	utils.h	434;"	d
ANACONDA_ASSAULT	mods/object.hpp	/^				ANACONDA_ASSAULT,$/;"	e	enum:mods::object::object_type_enum_t
AND_THEN	mods/catch.hpp	12218;"	d
AND_WHEN	mods/catch.hpp	12216;"	d
ANGLED_GRIP	mods/weapon.hpp	/^		VERTICAL_GRIP, ANGLED_GRIP$/;"	e	enum:mods::weapon::grip_t
AO	telnet.h	52;"	d
AOE_TYPES_NONE	mods/aoe.hpp	/^		AOE_TYPES_NONE = 0,$/;"	e	enum:mods::aoe::types_t
APPLY_AC	structs.h	524;"	d
APPLY_AGE	structs.h	516;"	d
APPLY_BARREL	structs.h	538;"	d
APPLY_CHA	structs.h	513;"	d
APPLY_CHAR_HEIGHT	structs.h	518;"	d
APPLY_CHAR_WEIGHT	structs.h	517;"	d
APPLY_CLASS	structs.h	514;"	d
APPLY_CON	structs.h	512;"	d
APPLY_CRITICAL_RANGE	structs.h	545;"	d
APPLY_DAMROLL	structs.h	526;"	d
APPLY_DEX	structs.h	509;"	d
APPLY_EXP	structs.h	523;"	d
APPLY_GOLD	structs.h	522;"	d
APPLY_HIT	structs.h	520;"	d
APPLY_HITROLL	structs.h	525;"	d
APPLY_INCENDIARY	structs.h	540;"	d
APPLY_INT	structs.h	510;"	d
APPLY_LEVEL	structs.h	515;"	d
APPLY_MAGAZINE_SIZE	structs.h	539;"	d
APPLY_MANA	structs.h	519;"	d
APPLY_MOVE	structs.h	521;"	d
APPLY_NONE	structs.h	507;"	d
APPLY_OPTIMAL_RANGE	structs.h	546;"	d
APPLY_PENETRATION	structs.h	543;"	d
APPLY_RANGE	structs.h	544;"	d
APPLY_RECOIL	structs.h	537;"	d
APPLY_SAVING_BREATH	structs.h	532;"	d
APPLY_SAVING_PARA	structs.h	529;"	d
APPLY_SAVING_PETRI	structs.h	531;"	d
APPLY_SAVING_ROD	structs.h	530;"	d
APPLY_SAVING_SPELL	structs.h	533;"	d
APPLY_SCOPE	structs.h	536;"	d
APPLY_SIDERAIL	structs.h	541;"	d
APPLY_STEALTH	structs.h	548;"	d
APPLY_STR	structs.h	508;"	d
APPLY_UNDER_BARREL	structs.h	542;"	d
APPLY_VISION	structs.h	547;"	d
APPLY_WIS	structs.h	511;"	d
ARM	mods/item.hpp	/^		ARM = (1 << 9)$/;"	e	enum:mods::item::capability_t
ARMOR	mods/skills.hpp	/^		ARMOR,$/;"	e	enum:mods::skills::fields_of_study
ARMOR_NONE	mods/item-types.hpp	/^		ARMOR_NONE = 0,$/;"	e	enum:mods::weapon::type::armor
ARMOR_PENETRATION_SHOT	mods/skills.hpp	/^			ARMOR_PENETRATION_SHOT,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ASPELL	spells.cpp	/^ASPELL(spell_charm) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_create_water) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_detect_poison) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_enchant_weapon) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_identify) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_locate_object) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_recall) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_summon) {$/;"	f
ASPELL	spells.cpp	/^ASPELL(spell_teleport) {$/;"	f
ASPELL	spells.h	255;"	d
ASSAULT_RIFLE	mods/object.hpp	/^				ASSAULT_RIFLE,$/;"	e	enum:mods::object::object_type_enum_t
ASSAULT_RIFLE	mods/weapon.hpp	/^		GRENADE = (1 << 4), ASSAULT_RIFLE = (1 << 5), PISTOL = (1 << 6),$/;"	e	enum:mods::weapon::mask_type
ASSAULT_RIFLE_SHRAPNEL	mods/skills.hpp	/^			ASSAULT_RIFLE_SHRAPNEL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ASSIGNMOB	spec_assign.cpp	/^void ASSIGNMOB(mob_vnum mob, SPECIAL(fname)) {$/;"	f
ASSIGNOBJ	spec_assign.cpp	/^void ASSIGNOBJ(obj_vnum obj, SPECIAL(fname)) {$/;"	f
ASSIGNROOM	spec_assign.cpp	/^void ASSIGNROOM(room_vnum room, SPECIAL(fname)) {$/;"	f
AS_YOU_WERE	mods/behaviour_tree_impl.hpp	/^			AS_YOU_WERE,$/;"	e	enum:mods::behaviour_tree_impl::dispatch_status_t
ATTACHMENT_NONE	mods/item-types.hpp	/^		ATTACHMENT_NONE = 0,$/;"	e	enum:mods::weapon::type::attachment
ATTACK_DRONE	mods/weapon.hpp	/^		ATTACK_DRONE = (1 << 13)$/;"	e	enum:mods::weapon::mask_type
AUDITORY_DISTRACTION	mods/aoe.hpp	/^		AUDITORY_DISTRACTION,	\/** Pre-recorded audio to distract or deceive *\/$/;"	e	enum:mods::aoe::types_t
AUTHTYPE_CNT	telnet.h	265;"	d
AUTHTYPE_KERBEROS_V4	telnet.h	261;"	d
AUTHTYPE_KERBEROS_V5	telnet.h	262;"	d
AUTHTYPE_MINK	telnet.h	264;"	d
AUTHTYPE_NAME	telnet.h	278;"	d
AUTHTYPE_NAME_OK	telnet.h	277;"	d
AUTHTYPE_NULL	telnet.h	260;"	d
AUTHTYPE_SPX	telnet.h	263;"	d
AUTHTYPE_TEST	telnet.h	267;"	d
AUTH_HOW_MASK	telnet.h	258;"	d
AUTH_HOW_MUTUAL	telnet.h	257;"	d
AUTH_HOW_ONE_WAY	telnet.h	256;"	d
AUTH_WHO_CLIENT	telnet.h	249;"	d
AUTH_WHO_MASK	telnet.h	251;"	d
AUTH_WHO_SERVER	telnet.h	250;"	d
AUTOMATIC	mods/object.hpp	/^				AUTOMATIC,$/;"	e	enum:mods::object::object_type_enum_t
AWAKE	utils.h	367;"	d
AYT	telnet.h	51;"	d
AllOf	mods/catch.hpp	/^		inline Impl::MatchAllOf<T> AllOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2) {$/;"	f	namespace:Catch::Matchers
AllOf	mods/catch.hpp	/^		inline Impl::MatchAllOf<T> AllOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3) {$/;"	f	namespace:Catch::Matchers
AnyOf	mods/catch.hpp	/^		inline Impl::MatchAnyOf<T> AnyOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2) {$/;"	f	namespace:Catch::Matchers
AnyOf	mods/catch.hpp	/^		inline Impl::MatchAnyOf<T> AnyOf(Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3) {$/;"	f	namespace:Catch::Matchers
AssertionInfo	mods/catch.hpp	/^		AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo
AssertionInfo	mods/catch.hpp	/^	struct AssertionInfo {$/;"	s	namespace:Catch
AssertionResult	mods/catch.hpp	/^	class AssertionResult {$/;"	c	namespace:Catch
AssertionResultData	mods/catch.hpp	/^		AssertionResultData() : decomposedExpression(CATCH_NULL)$/;"	f	struct:Catch::AssertionResultData
AssertionResultData	mods/catch.hpp	/^	struct AssertionResultData {$/;"	s	namespace:Catch
AutoReg	mods/catch.hpp	/^			AutoReg$/;"	f	struct:Catch::AutoReg
AutoReg	mods/catch.hpp	/^	struct AutoReg {$/;"	s	namespace:Catch
BACKGROUND_FILE	db.h	84;"	d
BALLISTIC	mods/object.hpp	/^				BALLISTIC,$/;"	e	enum:mods::object::object_type_enum_t
BANNED_SITE_LENGTH	db.h	254;"	d
BAN_ALL	db.h	252;"	d
BAN_FILE	db.h	97;"	d
BAN_LIST_FORMAT	ban.cpp	116;"	d	file:
BAN_LIST_FORMAT	ban.cpp	200;"	d	file:
BAN_NEW	db.h	250;"	d
BAN_NOT	db.h	249;"	d
BAN_SELECT	db.h	251;"	d
BARBED_TENDRILS	mods/aoe.hpp	/^		BARBED_TENDRILS, \/** explodes into barbed wire causing painful movement *\/$/;"	e	enum:mods::aoe::types_t
BARREL	mods/weapon.hpp	/^		BARREL,$/;"	e	enum:mods::weapon::attachment_t
BASIC_ARMOR	mods/skills.hpp	/^			BASIC_ARMOR,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BASIC_ASSAULT_RIFLE	mods/skills.hpp	/^			BASIC_ASSAULT_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BASIC_HP_RECOVERY	mods/skills.hpp	/^			BASIC_HP_RECOVERY,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BASIC_PISTOL	mods/skills.hpp	/^			BASIC_PISTOL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BASIC_SHOTGUN	mods/skills.hpp	/^			BASIC_SHOTGUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BASIC_SNIPER_RIFLE	mods/skills.hpp	/^			BASIC_SNIPER_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BASIC_SUB_MACHINE_GUN	mods/skills.hpp	/^			BASIC_SUB_MACHINE_GUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BEACON	mods/aoe.hpp	/^		BEACON,	\/** Serves as a radio beacon for communication purposes and tracking *\/$/;"	e	enum:mods::aoe::types_t
BETTER_EXPLOSIONS	mods/skills.hpp	/^			BETTER_EXPLOSIONS,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BETTER_SNIPING_ACCURACY	mods/skills.hpp	/^			BETTER_SNIPING_ACCURACY,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BETTER_WEAPON_ACCURACY	mods/skills.hpp	/^			BETTER_WEAPON_ACCURACY,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BFS_ALREADY_THERE	utils.h	129;"	d
BFS_ERROR	utils.h	128;"	d
BFS_NO_PATH	utils.h	130;"	d
BIGGER_CLAYMORES	mods/skills.hpp	/^			BIGGER_CLAYMORES,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BIGGER_FIRE_NADES	mods/skills.hpp	/^			BIGGER_FIRE_NADES,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
BINARY	act.wizard.cpp	2351;"	d	file:
BLIND	mods/affects.hpp	/^		BLIND = 0,$/;"	e	enum:mods::affects::affect_t
BLIND	mods/flags.hpp	/^		BLIND = 1, $/;"	e	enum:mods::flags::aff
BLIND	mods/weapon-types.hpp	/^		BLIND,$/;"	e	enum:mods::weapon::capabilities::cap_t
BLINDING_LIGHT	mods/aoe.hpp	/^		BLINDING_LIGHT,	\/** Typical blinding light from flash bangs *\/$/;"	e	enum:mods::aoe::types_t
BLOCK_SIZE	mail.h	29;"	d
BOARD_MAGIC	boards.h	17;"	d
BOARD_RNUM	boards.h	41;"	d
BOARD_VNUM	boards.h	36;"	d
BOOL_CASE	db.cpp	1724;"	d	file:
BOOL_CASE	db.cpp	1788;"	d	file:
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_ARMOR_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::armor
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_ATTACHMENT_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::attachment
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_CONSUMABLE_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::consumable
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_DRONE_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::drone
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_EXPLOSIVE_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::explosive
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_GADGET_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::gadget
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_RIFLE_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::rifle
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_ENUM_TYPES_IMPL,~,MENTOC_TRAP_TYPES_SEQUENCE)$/;"	e	enum:mods::weapon::type::trap
BOOST_PP_SEQ_FOR_EACH	mods/item-types.hpp	/^		BOOST_PP_SEQ_FOR_EACH(MENTOC_TYPE_LIST_IMPL,~,MENTOC_ITEM_TYPE_LIST_SEQUENCE)$/;"	e	enum:mods::weapon::type::type_list
BOOT_DB	globals.hpp	/^		enum boot_type_t { BOOT_DB,BOOT_HELL };$/;"	e	enum:mods::globals::boot_type_t
BOOT_HELL	globals.hpp	/^		enum boot_type_t { BOOT_DB,BOOT_HELL };$/;"	e	enum:mods::globals::boot_type_t
BOTH	act.wizard.cpp	2348;"	d	file:
BREACH	mods/item.hpp	/^		BREACH = (1 << 5),$/;"	e	enum:mods::item::capability_t
BREACHABLE_DOOR	mods/doors.hpp	/^	static constexpr int BREACHABLE_DOOR = exit_info_masks_t::EIM_ISDOOR + exit_info_masks_t::EIM_BREACHABLE;$/;"	m	namespace:mods::doors
BREACHED_EAST	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_EAST	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_NORTH	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_SOUTH	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_FROM_WEST	mods/ai_state.hpp	/^				BREACHED_FROM_NORTH,BREACHED_FROM_SOUTH,BREACHED_FROM_EAST,BREACHED_FROM_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_NORTH	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_SOUTH	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACHED_WEST	mods/ai_state.hpp	/^				BREACHED_NORTH,BREACHED_SOUTH,BREACHED_EAST,BREACHED_WEST,$/;"	e	enum:mods::ai_state::event_type_t
BREACH_DOORS	mods/weapon-types.hpp	/^		BREACH_DOORS,$/;"	e	enum:mods::weapon::capabilities::cap_t
BREACH_MASK	mods/object-utils.hpp	/^	constexpr static obj_data::location_data_t BREACH_MASK = 32;$/;"	m	namespace:mods::object_utils
BREACH_TICKS_DURATION	mods/object-utils.hpp	/^	constexpr static uint8_t BREACH_TICKS_DURATION = 15;$/;"	m	namespace:mods::object_utils
BREAK	telnet.h	54;"	d
BRF	utils.h	118;"	d
BUG_FILE	db.h	90;"	d
BUILDER	mods/flags.hpp	/^		BUILDER,$/;"	e	enum:mods::flags::chunk_type_t
BURN	mods/item.hpp	/^		BURN = (1 << 3),$/;"	e	enum:mods::item::capability_t
BURN	mods/weapon-types.hpp	/^		BURN,$/;"	e	enum:mods::weapon::capabilities::cap_t
BUY_TYPE	shop.h	24;"	d
BUY_WORD	shop.h	25;"	d
Board_clear_all	boards.cpp	/^void Board_clear_all(void) {$/;"	f
Board_clear_board	boards.cpp	/^void Board_clear_board(int board_type) {$/;"	f
Board_display_msg	boards.cpp	/^int Board_display_msg(int board_type, char_data *ch, char *arg, struct obj_data *board) {$/;"	f
Board_load_board	boards.cpp	/^void Board_load_board(int board_type) {$/;"	f
Board_remove_msg	boards.cpp	/^int Board_remove_msg(int board_type, char_data *ch, char *arg, struct obj_data *board) {$/;"	f
Board_reset_board	boards.cpp	/^void Board_reset_board(int board_type) {$/;"	f
Board_save_board	boards.cpp	/^void Board_save_board(int board_type) {$/;"	f
Board_show_board	boards.cpp	/^int Board_show_board(int board_type, char_data *ch, char *arg, struct obj_data *board) {$/;"	f
Board_write_message	boards.cpp	/^int Board_write_message(int board_type, char_data *ch, char *arg, struct obj_data *board) {$/;"	f
BorgType	mods/catch.hpp	/^		struct BorgType {$/;"	s	namespace:Catch::Detail
CAMERA_DESTRUCTION	mods/skills.hpp	/^			CAMERA_DESTRUCTION,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
CAMERA_PLACEMENT	mods/skills.hpp	/^			CAMERA_PLACEMENT = 0,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
CAN_CARRY_N	utils.h	366;"	d
CAN_CARRY_OBJ	utils.h	476;"	d
CAN_CARRY_W	utils.h	365;"	d
CAN_GET_OBJ	utils.h	480;"	d
CAN_GO	utils.h	495;"	d
CAN_SEE	utils.h	455;"	d
CAN_SEE_IN_DARK	utils.h	368;"	d
CAN_SEE_OBJ	utils.h	473;"	d
CAN_SEE_OBJ_CARRIER	utils.h	466;"	d
CAN_WEAR	utils.h	418;"	d
CAP	utils.cpp	/^char *CAP(char *txt) {$/;"	f
CAPABILITY_LIST_LENGTH	structs.h	/^		static constexpr std::size_t CAPABILITY_LIST_LENGTH = mods::weapon::capabilities::cap_t::__LAST;$/;"	m	struct:obj_data
CAP_ALL	mods/util.hpp	/^	static constexpr uint8_t CAP_ALL = 0;$/;"	m	namespace:mods::util
CAP_ANY	mods/util.hpp	/^	static constexpr uint8_t CAP_ANY = 0;$/;"	m	namespace:mods::util
CAP_SINGLE	mods/util.hpp	/^	static constexpr uint8_t CAP_SINGLE = 0;$/;"	m	namespace:mods::util
CARPET	structs.h	/^			CARPET,$/;"	m	struct:room_data	typeref:enum:room_data::
CASE	db.cpp	1721;"	d	file:
CASE	db.cpp	1787;"	d	file:
CASE_MOON	mods/date-time.cpp	172;"	d	file:
CAST_POTION	spells.h	18;"	d
CAST_SCROLL	spells.h	21;"	d
CAST_SPELL	spells.h	17;"	d
CAST_STAFF	spells.h	20;"	d
CAST_UNDEFINED	spells.h	16;"	d
CAST_WAND	spells.h	19;"	d
CATCH_AND_THEN	mods/catch.hpp	12145;"	d
CATCH_AND_WHEN	mods/catch.hpp	12143;"	d
CATCH_ANON_TEST_CASE	mods/catch.hpp	12126;"	d
CATCH_ARC_ENABLED	mods/catch.hpp	1548;"	d
CATCH_ARC_STRONG	mods/catch.hpp	1568;"	d
CATCH_ARC_STRONG	mods/catch.hpp	1587;"	d
CATCH_AUTO_PTR	mods/catch.hpp	361;"	d
CATCH_AUTO_PTR	mods/catch.hpp	363;"	d
CATCH_BREAK_INTO_DEBUGGER	mods/catch.hpp	2180;"	d
CATCH_CAPTURE	mods/catch.hpp	12106;"	d
CATCH_CHECK	mods/catch.hpp	12089;"	d
CATCH_CHECKED_ELSE	mods/catch.hpp	12092;"	d
CATCH_CHECKED_IF	mods/catch.hpp	12091;"	d
CATCH_CHECK_FALSE	mods/catch.hpp	12090;"	d
CATCH_CHECK_NOFAIL	mods/catch.hpp	12093;"	d
CATCH_CHECK_NOTHROW	mods/catch.hpp	12098;"	d
CATCH_CHECK_THAT	mods/catch.hpp	12100;"	d
CATCH_CHECK_THROWS	mods/catch.hpp	12095;"	d
CATCH_CHECK_THROWS_AS	mods/catch.hpp	12096;"	d
CATCH_CHECK_THROWS_WITH	mods/catch.hpp	12097;"	d
CATCH_CONFIG_COLOUR_WINDOWS	mods/catch.hpp	8229;"	d
CATCH_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4039;"	d
CATCH_CONFIG_COUNTER	mods/catch.hpp	315;"	d
CATCH_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	291;"	d
CATCH_CONFIG_CPP11_IS_ENUM	mods/catch.hpp	294;"	d
CATCH_CONFIG_CPP11_LONG_LONG	mods/catch.hpp	303;"	d
CATCH_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	288;"	d
CATCH_CONFIG_CPP11_NULLPTR	mods/catch.hpp	285;"	d
CATCH_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	306;"	d
CATCH_CONFIG_CPP11_SHUFFLE	mods/catch.hpp	318;"	d
CATCH_CONFIG_CPP11_TUPLE	mods/catch.hpp	297;"	d
CATCH_CONFIG_CPP11_TYPE_TRAITS	mods/catch.hpp	321;"	d
CATCH_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	309;"	d
CATCH_CONFIG_POSIX_SIGNALS	mods/catch.hpp	328;"	d
CATCH_CONFIG_VARIADIC_MACROS	mods/catch.hpp	300;"	d
CATCH_CONFIG_WINDOWS_SEH	mods/catch.hpp	324;"	d
CATCH_CPP11_OR_GREATER	mods/catch.hpp	107;"	d
CATCH_CPP14_OR_GREATER	mods/catch.hpp	111;"	d
CATCH_FAIL	mods/catch.hpp	12115;"	d
CATCH_GCC_HAS_NEW_PRAGMA	mods/catch.hpp	173;"	d
CATCH_GENERATE	mods/catch.hpp	12131;"	d
CATCH_GIVEN	mods/catch.hpp	12141;"	d
CATCH_IMPL	mods/catch.hpp	53;"	d
CATCH_INFO	mods/catch.hpp	12103;"	d
CATCH_INTERNAL_CONFIG_COUNTER	mods/catch.hpp	230;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	206;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	249;"	d
CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM	mods/catch.hpp	253;"	d
CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG	mods/catch.hpp	265;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	123;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	205;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	245;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	119;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	177;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	200;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	241;"	d
CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	269;"	d
CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE	mods/catch.hpp	207;"	d
CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE	mods/catch.hpp	275;"	d
CATCH_INTERNAL_CONFIG_CPP11_TUPLE	mods/catch.hpp	257;"	d
CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS	mods/catch.hpp	208;"	d
CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS	mods/catch.hpp	278;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	201;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	272;"	d
CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS	mods/catch.hpp	141;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	mods/catch.hpp	221;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	mods/catch.hpp	261;"	d
CATCH_INTERNAL_CONFIG_WINDOWS_SEH	mods/catch.hpp	197;"	d
CATCH_INTERNAL_ERROR	mods/catch.hpp	508;"	d
CATCH_INTERNAL_LINEINFO	mods/catch.hpp	507;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	127;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	181;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	332;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	130;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	184;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	mods/catch.hpp	333;"	d
CATCH_METHOD_AS_TEST_CASE	mods/catch.hpp	12112;"	d
CATCH_NOEXCEPT	mods/catch.hpp	/^			virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException
CATCH_NOEXCEPT	mods/catch.hpp	338;"	d
CATCH_NOEXCEPT	mods/catch.hpp	341;"	d
CATCH_NOEXCEPT_IS	mods/catch.hpp	339;"	d
CATCH_NOEXCEPT_IS	mods/catch.hpp	342;"	d
CATCH_NOT_IMPLEMENTED	mods/catch.hpp	529;"	d
CATCH_NULL	mods/catch.hpp	347;"	d
CATCH_NULL	mods/catch.hpp	349;"	d
CATCH_OVERRIDE	mods/catch.hpp	/^			virtual void reconstructExpression(std::string& dest) const CATCH_OVERRIDE;$/;"	m	class:Catch::ResultBuilder
CATCH_OVERRIDE	mods/catch.hpp	354;"	d
CATCH_OVERRIDE	mods/catch.hpp	356;"	d
CATCH_PLATFORM_MAC	mods/catch.hpp	2126;"	d
CATCH_REGISTER_LEGACY_REPORTER	mods/catch.hpp	12129;"	d
CATCH_REGISTER_REPORTER	mods/catch.hpp	12128;"	d
CATCH_REGISTER_TAG_ALIAS	mods/catch.hpp	3154;"	d
CATCH_REGISTER_TEST_CASE	mods/catch.hpp	12113;"	d
CATCH_REQUIRE	mods/catch.hpp	12081;"	d
CATCH_REQUIRE_FALSE	mods/catch.hpp	12082;"	d
CATCH_REQUIRE_NOTHROW	mods/catch.hpp	12087;"	d
CATCH_REQUIRE_THAT	mods/catch.hpp	12101;"	d
CATCH_REQUIRE_THROWS	mods/catch.hpp	12084;"	d
CATCH_REQUIRE_THROWS_AS	mods/catch.hpp	12085;"	d
CATCH_REQUIRE_THROWS_WITH	mods/catch.hpp	12086;"	d
CATCH_SCENARIO	mods/catch.hpp	12135;"	d
CATCH_SCENARIO_METHOD	mods/catch.hpp	12136;"	d
CATCH_SCOPED_CAPTURE	mods/catch.hpp	12107;"	d
CATCH_SCOPED_INFO	mods/catch.hpp	12105;"	d
CATCH_SECTION	mods/catch.hpp	12114;"	d
CATCH_SUCCEED	mods/catch.hpp	12116;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4224;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	5432;"	d
CATCH_TEST_CASE	mods/catch.hpp	12110;"	d
CATCH_TEST_CASE_METHOD	mods/catch.hpp	12111;"	d
CATCH_THEN	mods/catch.hpp	12144;"	d
CATCH_TRANSLATE_EXCEPTION	mods/catch.hpp	12204;"	d
CATCH_TRAP	mods/catch.hpp	2154;"	d
CATCH_UNSAFE_UNRETAINED	mods/catch.hpp	1567;"	d
CATCH_UNSAFE_UNRETAINED	mods/catch.hpp	1586;"	d
CATCH_WARN	mods/catch.hpp	12104;"	d
CATCH_WHEN	mods/catch.hpp	12142;"	d
CCBLU	screen.h	33;"	d
CCCYN	screen.h	35;"	d
CCGRN	screen.h	31;"	d
CCMAG	screen.h	34;"	d
CCNRM	screen.h	29;"	d
CCRED	screen.h	30;"	d
CCWHT	screen.h	36;"	d
CCYEL	screen.h	32;"	d
CEMENT	structs.h	/^			CEMENT,			\/** asphault, nearly indestructible *\/$/;"	m	struct:room_data	typeref:enum:room_data::
CGET	mods/values.hpp	25;"	d
CGET	mods/values.hpp	279;"	d
CGET_DEF	mods/values.cpp	297;"	d	file:
CGET_DEF	mods/values.cpp	521;"	d	file:
CHAINABLE_BREACHING	mods/skills.hpp	/^			CHAINABLE_BREACHING,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
CHAOTIC	mods/ai_state.hpp	/^				MANIC,CHAOTIC,RESERVED$/;"	e	enum:mods::ai_state::state
CHARM	mods/flags.hpp	/^		CHARM,$/;"	e	enum:mods::flags::aff
CHECK_NULL	comm.cpp	2318;"	d	file:
CHECK_PLAYER_SPECIAL	utils.h	214;"	d
CHECK_PLAYER_SPECIAL	utils.h	217;"	d
CHECK_WAIT	utils.h	378;"	d
CHEMISTRY	mods/skills.hpp	/^		CHEMISTRY,$/;"	e	enum:mods::skills::fields_of_study
CIRCLEMUD_VERSION	utils.h	427;"	d
CIRCLE_CRYPT	conf.h	35;"	d
CIRCLE_GNU_LIBC_MEMORY_TRACK	sysdep.h	118;"	d
CIRCLE_UNIX	conf.h	32;"	d
CIRCLE_UNSIGNED_INDEX	structs.h	124;"	d
CI_CRIT	mods/projectile.cpp	/^		constexpr static uint8_t CI_CRIT = 0;$/;"	m	namespace:mods::projectile	file:
CI_INJ	mods/projectile.cpp	/^		constexpr static uint8_t CI_INJ = 0;$/;"	m	namespace:mods::projectile	file:
CLARA_AUTO_PTR	mods/catch.hpp	4573;"	d
CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4225;"	d
CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	4227;"	d
CLARA_CONFIG_CONSOLE_WIDTH	mods/catch.hpp	5431;"	d
CLARA_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	4539;"	d
CLARA_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4536;"	d
CLARA_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4533;"	d
CLARA_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	4542;"	d
CLARA_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	4545;"	d
CLARA_CONFIG_MAIN	mods/catch.hpp	12073;"	d
CLARA_CONFIG_MAIN	mods/catch.hpp	59;"	d
CLARA_CONFIG_MAIN_NOT_DEFINED	mods/catch.hpp	58;"	d
CLARA_CPP11_OR_GREATER	mods/catch.hpp	4508;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	4497;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	mods/catch.hpp	4519;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4468;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4496;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	mods/catch.hpp	4515;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4464;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4478;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4491;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	mods/catch.hpp	4511;"	d
CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE	mods/catch.hpp	4523;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	4492;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	mods/catch.hpp	4526;"	d
CLARA_NOEXCEPT	mods/catch.hpp	4550;"	d
CLARA_NOEXCEPT_IS	mods/catch.hpp	4551;"	d
CLARA_NULL	mods/catch.hpp	4559;"	d
CLARA_OVERRIDE	mods/catch.hpp	4566;"	d
CLARA_PLATFORM_WINDOWS	mods/catch.hpp	4588;"	d
CLASS_ABBR	utils.h	500;"	d
CLASS_ANIMAL	structs.h	237;"	d
CLASS_CONTAGION	structs.h	/^	CLASS_CONTAGION = 4,$/;"	e	enum:player_class_t
CLASS_DRAGON	structs.h	238;"	d
CLASS_ENGINEER	structs.h	/^	CLASS_ENGINEER = 5,$/;"	e	enum:player_class_t
CLASS_GIANT	structs.h	239;"	d
CLASS_HUMANOID	structs.h	236;"	d
CLASS_MARINE	structs.h	/^	CLASS_MARINE = 2,$/;"	e	enum:player_class_t
CLASS_MARKSMAN	structs.h	/^	CLASS_MARKSMAN = 7,$/;"	e	enum:player_class_t
CLASS_MEDIC	structs.h	/^	CLASS_MEDIC = 6,$/;"	e	enum:player_class_t
CLASS_OTHER	structs.h	234;"	d
CLASS_PSYOP	structs.h	/^	CLASS_PSYOP = 8,$/;"	e	enum:player_class_t
CLASS_SENTINEL	structs.h	/^	CLASS_SENTINEL = 3,$/;"	e	enum:player_class_t
CLASS_SNIPER	structs.h	/^	CLASS_SNIPER = 1,$/;"	e	enum:player_class_t
CLASS_SUPPORT	structs.h	/^	CLASS_SUPPORT = 9$/;"	e	enum:player_class_t
CLASS_UNDEAD	structs.h	235;"	d
CLASS_UNDEFINED	structs.h	/^	CLASS_UNDEFINED = 0,$/;"	e	enum:player_class_t
CLAYMORE	mods/weapon.hpp	/^		FLAME = (1 << 10), CLAYMORE = (1 << 11), REMOTE_EXPLOSIVE = (1 << 12),$/;"	e	enum:mods::weapon::mask_type
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	mods/catch.hpp	5663;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	mods/catch.hpp	5848;"	d
CLOSE_DOOR	act.movement.cpp	342;"	d	file:
CLOSE_SOCKET	sysdep.h	392;"	d
CMD_IS	interpreter.h	19;"	d
CMD_NAME	interpreter.h	18;"	d
CMP	utils.h	120;"	d
COLOR_LEV	screen.h	38;"	d
COMMON	mods/randomized-items.hpp	/^	COMMON = 0,$/;"	e	enum:mods::rarity_enum_t
COMMON	mods/rarity.hpp	/^		constexpr static float COMMON = 0.2510437;$/;"	m	namespace:mods::rarity
COMMON_DROP_RATE	mods/randomized-items.hpp	/^		constexpr static float COMMON_DROP_RATE = 85.0;$/;"	m	class:mods::randomized_items
COMPENSATOR	mods/weapon.hpp	/^		COMPENSATOR, MUZZLE_BRAKE,EXTENDED,$/;"	e	enum:mods::weapon::barrel_t
COMPLETELY_ON_FIRE	structs.h	/^			COMPLETELY_ON_FIRE = 2,$/;"	e	enum:uint8_t
CONSTGET	mods/values.hpp	/^		static inline T CONSTGET(std::string m,T fallback){$/;"	f	namespace:mods::values
CONSTSET	mods/values.hpp	/^		static inline void CONSTSET(std::string m,T value){$/;"	f	namespace:mods::values
CONSUMABLE_NONE	mods/item-types.hpp	/^		CONSUMABLE_NONE = 0,$/;"	e	enum:mods::weapon::type::consumable
CONTAINER	mods/object.hpp	/^				CONTAINER,$/;"	e	enum:mods::object::object_type_enum_t
CONT_CLOSEABLE	structs.h	551;"	d
CONT_CLOSED	structs.h	553;"	d
CONT_LOCKED	structs.h	554;"	d
CONT_PICKPROOF	structs.h	552;"	d
CON_CHARGEN_FINALIZE	structs.h	379;"	d
CON_CHARGEN_PRIMARY_CHOICE	structs.h	378;"	d
CON_CHPWD_GETNEW	structs.h	372;"	d
CON_CHPWD_GETOLD	structs.h	371;"	d
CON_CHPWD_VRFY	structs.h	373;"	d
CON_CLOSE	structs.h	360;"	d
CON_CNFPASSWD	structs.h	365;"	d
CON_DELCNF1	structs.h	374;"	d
CON_DELCNF2	structs.h	375;"	d
CON_DISCONNECT	structs.h	376;"	d
CON_EXDESC	structs.h	370;"	d
CON_GET_NAME	structs.h	361;"	d
CON_IDLE	structs.h	377;"	d
CON_MENU	structs.h	369;"	d
CON_NAME_CNFRM	structs.h	362;"	d
CON_NEEDS_AUTHENTICATION	structs.h	358;"	d
CON_NEWPASSWD	structs.h	364;"	d
CON_PASSWORD	structs.h	363;"	d
CON_PLAYING	structs.h	359;"	d
CON_QCLASS	structs.h	367;"	d
CON_QSEX	structs.h	366;"	d
CON_RMOTD	structs.h	368;"	d
CORROSIVE	mods/aoe.hpp	/^		CORROSIVE,	\/** Corrodes devices, melting them into a useless state. Causes irreversible burns to exposed skin *\/$/;"	e	enum:mods::aoe::types_t
COULDNT_FIND_USER_ID	mods/meta_utils.cpp	/^		COULDNT_FIND_USER_ID = -1$/;"	e	enum:mods::meta_utils::return_codes	file:
COUNTDOWN_EXPLOSION	mods/weapon-types.hpp	/^		COUNTDOWN_EXPLOSION,$/;"	e	enum:mods::weapon::capabilities::cap_t
COUNTER_SHOCK	mods/skills.hpp	/^			COUNTER_SHOCK,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
CQC	mods/weapon-types.hpp	/^		CQC,$/;"	e	enum:mods::weapon::capabilities::cap_t
CRAFTY_C4	mods/skills.hpp	/^			CRAFTY_C4,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
CRASH	mods/flags.hpp	/^		CRASH,$/;"	e	enum:mods::flags::plr
CRASH_FILE	utils.h	123;"	d
CREATE	utils.h	167;"	d
CREATE_ARG	globals.hpp	55;"	d
CREATE_CHAR	globals.hpp	78;"	d
CREATE_EMP_WEAPONS	mods/skills.hpp	/^			CREATE_EMP_WEAPONS,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
CREATE_OBJECT	mods/events.hpp	/^		CREATE_OBJECT,$/;"	e	enum:mods::events::event_enum
CREATE_PLAYER	mods/events.hpp	/^		CREATE_PLAYER,$/;"	e	enum:mods::events::event_enum
CREDITS_FILE	db.h	75;"	d
CRYO	mods/flags.hpp	/^		CRYO,$/;"	e	enum:mods::flags::plr
CRYO_FACTOR	objsave.cpp	26;"	d	file:
CRYPT	utils.h	547;"	d
CRYPT	utils.h	549;"	d
CURSE	mods/flags.hpp	/^		CURSE,					\/\/ useless$/;"	e	enum:mods::flags::aff
CYCLONE_RECON	mods/object.hpp	/^				CYCLONE_RECON,$/;"	e	enum:mods::object::object_type_enum_t
C_CMP	screen.h	25;"	d
C_NRM	screen.h	24;"	d
C_OFF	screen.h	22;"	d
C_SPR	screen.h	23;"	d
CaseSensitive	mods/catch.hpp	/^	struct CaseSensitive {$/;"	s	namespace:Catch
CastleGuard	castle.cpp	/^SPECIAL(CastleGuard);$/;"	v
Catch	mods/catch.hpp	/^namespace Catch {$/;"	n
Choice	mods/catch.hpp	/^		enum Choice {$/;"	g	struct:Catch::CaseSensitive
ContinueOnFailure	mods/catch.hpp	/^			ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
CopyableStream	mods/catch.hpp	/^		CopyableStream() {}$/;"	f	struct:Catch::CopyableStream
CopyableStream	mods/catch.hpp	/^		CopyableStream(CopyableStream const& other) {$/;"	f	struct:Catch::CopyableStream
CopyableStream	mods/catch.hpp	/^	struct CopyableStream {$/;"	s	namespace:Catch
Crash_calculate_rent	objsave.cpp	/^void Crash_calculate_rent(struct obj_data *obj, int *cost) {$/;"	f
Crash_clean_file	objsave.cpp	/^int Crash_clean_file(char *name) {$/;"	f
Crash_crashsave	objsave.cpp	/^void Crash_crashsave(char_data *ch) {$/;"	f
Crash_cryosave	objsave.cpp	/^void Crash_cryosave(char_data *ch, int cost) {$/;"	f
Crash_delete_crashfile	objsave.cpp	/^int Crash_delete_crashfile(char_data *ch) {$/;"	f
Crash_delete_file	objsave.cpp	/^int Crash_delete_file(char *name) {$/;"	f
Crash_extract_expensive	objsave.cpp	/^void Crash_extract_expensive(struct obj_data *obj) {$/;"	f
Crash_extract_norent_eq	objsave.cpp	/^void Crash_extract_norent_eq(char_data *ch) {$/;"	f
Crash_extract_norents	objsave.cpp	/^void Crash_extract_norents(struct obj_data *obj) {$/;"	f
Crash_extract_objs	objsave.cpp	/^void Crash_extract_objs(struct obj_data *obj) {$/;"	f
Crash_idlesave	objsave.cpp	/^void Crash_idlesave(char_data *ch) {$/;"	f
Crash_is_unrentable	objsave.cpp	/^int Crash_is_unrentable(struct obj_data *obj) {$/;"	f
Crash_listrent	objsave.cpp	/^void Crash_listrent(char_data *ch, char *name) {$/;"	f
Crash_load	objsave.cpp	/^int Crash_load(char_data *ch) {$/;"	f
Crash_offer_rent	objsave.cpp	/^int Crash_offer_rent(char_data *ch, char_data *recep,$/;"	f
Crash_rent_deadline	objsave.cpp	/^void Crash_rent_deadline(char_data *ch, char_data *recep,$/;"	f
Crash_rentsave	objsave.cpp	/^void Crash_rentsave(char_data *ch, int cost) {$/;"	f
Crash_report_rent	objsave.cpp	/^void Crash_report_rent(char_data *ch, char_data *recep,$/;"	f
Crash_report_unrentables	objsave.cpp	/^int Crash_report_unrentables(char_data *ch, char_data *recep,$/;"	f
Crash_restore_weight	objsave.cpp	/^void Crash_restore_weight(struct obj_data *obj) {$/;"	f
Crash_save	objsave.cpp	/^int Crash_save(struct obj_data *obj, FILE *fp, int location) {$/;"	f
Crash_save_all	objsave.cpp	/^void Crash_save_all(void) {$/;"	f
Crash_write_rentcode	objsave.cpp	/^int Crash_write_rentcode(char_data *ch, FILE *fl, struct rent_info *rent) {$/;"	f
DAMP	structs.h	/^			DAMP,$/;"	m	struct:room_data	typeref:enum:room_data::
DATA_BLOCK_DATASIZE	mail.h	75;"	d
DBGET	globals.hpp	43;"	d
DBSET	globals.hpp	42;"	d
DB_BOOT_HLP	db.h	20;"	d
DB_BOOT_MOB	db.h	16;"	d
DB_BOOT_OBJ	db.h	17;"	d
DB_BOOT_SHP	db.h	19;"	d
DB_BOOT_WLD	db.h	15;"	d
DB_BOOT_ZON	db.h	18;"	d
DB_PREFIX	mods/skills.cpp	/^	constexpr static const char* DB_PREFIX = "skills";$/;"	m	namespace:mods::skills	file:
DD	mods/debug-pre-game.hpp	12;"	d
DD	mods/debug-pre-game.hpp	59;"	d
DECENT	mods/yaml.hpp	/^	DECENT,$/;"	e	enum:mods::yaml::durability_profile_type_t
DEFAULT	mods/rarity.hpp	/^		constexpr static float DEFAULT = mods::rarity::COMMON;$/;"	m	namespace:mods::rarity
DEFAULT_AMOUNT	mods/affects.hpp	/^	constexpr static amount_t DEFAULT_AMOUNT = 3;$/;"	m	namespace:mods::affects
DEFAULT_STAFF_LVL	spells.h	13;"	d
DEFAULT_WAND_LVL	spells.h	14;"	d
DELETED	mods/flags.hpp	/^		DELETED,$/;"	e	enum:mods::flags::plr
DELETED_BLOCK	mail.h	55;"	d
DEMOLITIONS	mods/skills.hpp	/^		DEMOLITIONS,$/;"	e	enum:mods::skills::fields_of_study
DEPLOYABLE_FIRE_TURRET	mods/skills.hpp	/^			DEPLOYABLE_FIRE_TURRET,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
DEPLOYABLE_SHIELD	mods/skills.hpp	/^			DEPLOYABLE_SHIELD,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
DEPLOYABLE_TURRET	mods/skills.hpp	/^			DEPLOYABLE_TURRET,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
DESCRIBE_TESTING_SUITE	mods/testing_index.hpp	4;"	d
DESERT	structs.h	/^			DESERT,$/;"	m	struct:room_data	typeref:enum:room_data::
DESTROY_OBJECT	mods/events.hpp	/^		DESTROY_OBJECT,$/;"	e	enum:mods::events::event_enum
DESTROY_PLAYER	mods/events.hpp	/^		DESTROY_PLAYER,$/;"	e	enum:mods::events::event_enum
DETECT_ALIGN	mods/flags.hpp	/^		DETECT_ALIGN, 	\/\/ useless$/;"	e	enum:mods::flags::aff
DETECT_CAMERAS	mods/skills.hpp	/^			DETECT_CAMERAS,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
DETECT_INVIS	mods/flags.hpp	/^		DETECT_INVIS, 	$/;"	e	enum:mods::flags::aff
DETECT_MAGIC	mods/flags.hpp	/^		DETECT_MAGIC,		\/\/ useless$/;"	e	enum:mods::flags::aff
DETONATE	mods/item.hpp	/^		DETONATE = (1 << 4),$/;"	e	enum:mods::item::capability_t
DFLT_DIR	config.cpp	/^const char *DFLT_DIR = "lib";$/;"	v
DFLT_IP	config.cpp	/^const char *DFLT_IP = NULL; \/* bind to all interfaces *\/$/;"	v
DFLT_PORT	config.cpp	/^ush_int DFLT_PORT = 4000;$/;"	v
DIAMONDBACK_COMBAT	mods/object.hpp	/^				DIAMONDBACK_COMBAT,$/;"	e	enum:mods::object::object_type_enum_t
DIRECTED_EXPLOSION	mods/aoe.hpp	/^		DIRECTED_EXPLOSION,	\/** Claymore explosions. Directed *\/$/;"	e	enum:mods::aoe::types_t
DIRT	structs.h	/^			DIRT,				\/** think about outside+cement but except no cement *\/$/;"	m	struct:room_data	typeref:enum:room_data::
DISORIENT	mods/affects.hpp	/^		DISORIENT = 1,$/;"	e	enum:mods::affects::affect_t
DISORIENT	mods/weapon-types.hpp	/^		DISORIENT,$/;"	e	enum:mods::weapon::capabilities::cap_t
DM	telnet.h	55;"	d
DO	telnet.h	44;"	d
DONT	telnet.h	43;"	d
DONTSET	mods/flags.hpp	/^		DONTSET,$/;"	e	enum:mods::flags::plr
DOOR_CAMERA	mods/skills.hpp	/^			DOOR_CAMERA,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
DOOR_IS_BREACHED	act.movement.cpp	477;"	d	file:
DOOR_IS_CLOSED	act.movement.cpp	481;"	d	file:
DOOR_IS_LOCKED	act.movement.cpp	482;"	d	file:
DOOR_IS_OPEN	act.movement.cpp	468;"	d	file:
DOOR_IS_OPENABLE	act.movement.cpp	464;"	d	file:
DOOR_IS_PICKPROOF	act.movement.cpp	474;"	d	file:
DOOR_IS_THERMITE	act.movement.cpp	479;"	d	file:
DOOR_IS_UNLOCKED	act.movement.cpp	471;"	d	file:
DOOR_KEY	act.movement.cpp	483;"	d	file:
DOUSE	mods/item.hpp	/^		DOUSE = (1 << 8),$/;"	e	enum:mods::item::capability_t
DOWN	structs.h	153;"	d
DO_HELP	globals.hpp	59;"	d
DO_NOTHING	mods/behaviour_tree_node.hpp	/^		enum node_type_t { DO_NOTHING, SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
DP_C_LDOUBLE	bsd-snprintf.cpp	151;"	d	file:
DP_C_LONG	bsd-snprintf.cpp	150;"	d	file:
DP_C_LONG_LONG	bsd-snprintf.cpp	152;"	d	file:
DP_C_SHORT	bsd-snprintf.cpp	149;"	d	file:
DP_F_MINUS	bsd-snprintf.cpp	140;"	d	file:
DP_F_NUM	bsd-snprintf.cpp	143;"	d	file:
DP_F_PLUS	bsd-snprintf.cpp	141;"	d	file:
DP_F_SPACE	bsd-snprintf.cpp	142;"	d	file:
DP_F_UNSIGNED	bsd-snprintf.cpp	146;"	d	file:
DP_F_UP	bsd-snprintf.cpp	145;"	d	file:
DP_F_ZERO	bsd-snprintf.cpp	144;"	d	file:
DP_S_CONV	bsd-snprintf.cpp	136;"	d	file:
DP_S_DEFAULT	bsd-snprintf.cpp	130;"	d	file:
DP_S_DONE	bsd-snprintf.cpp	137;"	d	file:
DP_S_DOT	bsd-snprintf.cpp	133;"	d	file:
DP_S_FLAGS	bsd-snprintf.cpp	131;"	d	file:
DP_S_MAX	bsd-snprintf.cpp	134;"	d	file:
DP_S_MIN	bsd-snprintf.cpp	132;"	d	file:
DP_S_MOD	bsd-snprintf.cpp	135;"	d	file:
DRONE	mods/player.hpp	/^			PLAYER, MOB, DRONE,$/;"	e	enum:mods::player::player_type_enum_t
DRONE_MUTED_DESCRIPTOR	mods/player.hpp	/^			DRONE_MUTED_DESCRIPTOR$/;"	e	enum:mods::player::player_type_enum_t
DRONE_NONE	mods/item-types.hpp	/^		DRONE_NONE = 0,$/;"	e	enum:mods::weapon::type::drone
DRONE_OWNER_KEY	mods/drone.cpp	12;"	d	file:
DRONE_WEAPON_SET_NUM	mods/drone.hpp	14;"	d
DRUNK	structs.h	580;"	d
DRY	structs.h	/^			DRY,$/;"	m	struct:room_data	typeref:enum:room_data::
DT_FORMAT	mods/js.hpp	19;"	d
DURABLE	mods/yaml.hpp	/^	DURABLE,$/;"	e	enum:mods::yaml::durability_profile_type_t
DUTCH_OVEN	mods/skills.hpp	/^			DUTCH_OVEN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
DYNAMIC_FORMAT_STRING	mods/prefs.hpp	16;"	d
DYN_DB_GET	mods/prefs.hpp	18;"	d
DYN_DB_SET	mods/prefs.hpp	17;"	d
DecomposedExpression	mods/catch.hpp	/^	struct DecomposedExpression {$/;"	s	namespace:Catch
Detail	mods/catch.hpp	/^	namespace Detail {$/;"	n	namespace:Catch
DicknDavid	castle.cpp	/^SPECIAL(DicknDavid);$/;"	v
DidntThrowException	mods/catch.hpp	/^			DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
EAST	structs.h	149;"	d
EC	telnet.h	50;"	d
EIM_BREACHABLE	mods/doors.hpp	/^		EIM_BREACHABLE = EX_BREACHABLE,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_BREACHED	mods/doors.hpp	/^		EIM_BREACHED = EX_BREACHED,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_CLOSED	mods/doors.hpp	/^		EIM_CLOSED = EX_CLOSED,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_ELECTRIFIED	mods/doors.hpp	/^		EIM_ELECTRIFIED = EX_ELECTRIFIED,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_HIDDEN	mods/doors.hpp	/^		EIM_HIDDEN = EX_HIDDEN,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_ISDOOR	mods/doors.hpp	/^		EIM_ISDOOR = EX_ISDOOR,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_LOCKED	mods/doors.hpp	/^		EIM_LOCKED = EX_LOCKED,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_PICKPROOF	mods/doors.hpp	/^		EIM_PICKPROOF = EX_PICKPROOF,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_QUEST_LOCKED	mods/doors.hpp	/^		EIM_QUEST_LOCKED = EX_QUEST_LOCKED,$/;"	e	enum:mods::doors::exit_info_masks_t
EIM_REINFORCED	mods/doors.hpp	/^		EIM_REINFORCED = EX_REINFORCED,$/;"	e	enum:mods::doors::exit_info_masks_t
EL	telnet.h	49;"	d
ELECTRIFIED_DAMAGE	mods/skills.hpp	/^			ELECTRIFIED_DAMAGE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ELECTRONICS	mods/skills.hpp	/^		ELECTRONICS = 1,$/;"	e	enum:mods::skills::fields_of_study
ELEVATOR	structs.h	/^			ELEVATOR,$/;"	m	struct:room_data	typeref:enum:room_data::
ELITE	mods/randomized-items.hpp	/^	ELITE,$/;"	e	enum:mods::rarity_enum_t
ELITE_ARMOR	mods/skills.hpp	/^			ELITE_ARMOR,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ELITE_DROP_RATE	mods/randomized-items.hpp	/^		constexpr static float ELITE_DROP_RATE = 0.033;$/;"	m	class:mods::randomized_items
EMIT_SUBSTANCE	mods/weapon-types.hpp	/^		EMIT_SUBSTANCE,$/;"	e	enum:mods::weapon::capabilities::cap_t
EMP	mods/aoe.hpp	/^		EMP,	\/** Electro magnetic pulse. Destroys\/hampers electronics *\/$/;"	e	enum:mods::aoe::types_t
EMP	structs.h	/^			EMP, \/** chaff or emp has been detonated *\/$/;"	m	struct:room_data	typeref:enum:room_data::
ENCRYPT_CNT	telnet.h	292;"	d
ENCRYPT_DEC_KEYID	telnet.h	291;"	d
ENCRYPT_ENC_KEYID	telnet.h	290;"	d
ENCRYPT_END	telnet.h	287;"	d
ENCRYPT_IS	telnet.h	283;"	d
ENCRYPT_NAME	telnet.h	315;"	d
ENCRYPT_NAME_OK	telnet.h	314;"	d
ENCRYPT_REPLY	telnet.h	285;"	d
ENCRYPT_REQEND	telnet.h	289;"	d
ENCRYPT_REQSTART	telnet.h	288;"	d
ENCRYPT_START	telnet.h	286;"	d
ENCRYPT_SUPPORT	telnet.h	284;"	d
ENCTYPE_ANY	telnet.h	294;"	d
ENCTYPE_CNT	telnet.h	297;"	d
ENCTYPE_DES_CFB64	telnet.h	295;"	d
ENCTYPE_DES_OFB64	telnet.h	296;"	d
ENCTYPE_NAME	telnet.h	318;"	d
ENCTYPE_NAME_OK	telnet.h	317;"	d
END_OF	shop.h	90;"	d
ENERGY	mods/weapon.hpp	/^		MACHINE_PISTOL = (1 << 7), ENERGY = (1 << 8), FUMES = (1 << 9),$/;"	e	enum:mods::weapon::mask_type
ENTRY_DENIAL	mods/skills.hpp	/^			ENTRY_DENIAL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
ENV_ESC	telnet.h	239;"	d
ENV_USERVAR	telnet.h	240;"	d
EOR	telnet.h	58;"	d
ETEXT_FILE	utils.h	124;"	d
EVENT_GET_ATTACKED	mods/deferred.hpp	/^			constexpr static uint32_t EVENT_GET_ATTACKED = 2;$/;"	m	class:mods::deferred
EVENT_OBJECT_DESTRUCT	mods/deferred.hpp	/^			constexpr static uint32_t EVENT_OBJECT_DESTRUCT = 0;$/;"	m	class:mods::deferred
EVENT_PLAYER_REVIVE_SUCCESSFUL	mods/deferred.hpp	/^			constexpr static uint32_t EVENT_PLAYER_REVIVE_SUCCESSFUL = 4;$/;"	m	class:mods::deferred
EVENT_PLAYER_UNBLOCK_BREACH	mods/deferred.hpp	/^			constexpr static uint32_t EVENT_PLAYER_UNBLOCK_BREACH = 3;$/;"	m	class:mods::deferred
EVENT_PLAYER_UNBLOCK_INSTALLATION	mods/deferred.hpp	/^			constexpr static uint32_t EVENT_PLAYER_UNBLOCK_INSTALLATION = 1;$/;"	m	class:mods::deferred
EV_BLINDING_LIGHT	mods/projectile.hpp	/^			EV_BLINDING_LIGHT,$/;"	e	enum:mods::projectile::projectile_event_t
EV_BURN	mods/projectile.hpp	/^			EV_BURN,$/;"	e	enum:mods::projectile::projectile_event_t
EV_CORRODE	mods/projectile.hpp	/^			EV_CORRODE,$/;"	e	enum:mods::projectile::projectile_event_t
EV_DEFORM	mods/projectile.hpp	/^			EV_DEFORM,$/;"	e	enum:mods::projectile::projectile_event_t
EV_EXPLODE	mods/projectile.hpp	/^			EV_EXPLODE,$/;"	e	enum:mods::projectile::projectile_event_t
EV_EXPOSED	mods/projectile.hpp	/^			EV_EXPOSED,$/;"	e	enum:mods::projectile::projectile_event_t
EV_IGNITE	mods/projectile.hpp	/^			EV_IGNITE,$/;"	e	enum:mods::projectile::projectile_event_t
EV_MELT	mods/projectile.hpp	/^			EV_MELT,$/;"	e	enum:mods::projectile::projectile_event_t
EV_PENETRATE	mods/projectile.hpp	/^			EV_PENETRATE,$/;"	e	enum:mods::projectile::projectile_event_t
EV_PROPAGATE_CHAFF	mods/projectile.hpp	/^			EV_PROPAGATE_CHAFF,$/;"	e	enum:mods::projectile::projectile_event_t
EV_PROPAGATE_EMP	mods/projectile.hpp	/^			EV_PROPAGATE_EMP,$/;"	e	enum:mods::projectile::projectile_event_t
EV_PROPAGATE_SMOKE	mods/projectile.hpp	/^			EV_PROPAGATE_SMOKE,$/;"	e	enum:mods::projectile::projectile_event_t
EV_SHRAPNEL	mods/projectile.hpp	/^			EV_SHRAPNEL,$/;"	e	enum:mods::projectile::projectile_event_t
EV_SHRED	mods/projectile.hpp	/^			EV_SHRED,$/;"	e	enum:mods::projectile::projectile_event_t
EV_STAIN	mods/projectile.hpp	/^			EV_STAIN,$/;"	e	enum:mods::projectile::projectile_event_t
EV_TRAVEL	mods/projectile.hpp	/^			EV_TRAVEL,$/;"	e	enum:mods::projectile::projectile_event_t
EXDSCR_LENGTH	structs.h	681;"	d
EXEC	mods/lmdb.hpp	/^		EXEC, UPDATE, INSERT $/;"	e	enum:mods::lmdb::transact_type_t
EXIT	utils.h	493;"	d
EXITN	act.movement.cpp	338;"	d	file:
EXIT_FLAGGED	utils.h	240;"	d
EXPERT_ASSAULT_RIFLE	mods/skills.hpp	/^			EXPERT_ASSAULT_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
EXPERT_PISTOL	mods/skills.hpp	/^			EXPERT_PISTOL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
EXPERT_SHOTGUN	mods/skills.hpp	/^			EXPERT_SHOTGUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
EXPERT_SNIPER_RIFLE	mods/skills.hpp	/^			EXPERT_SNIPER_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
EXPERT_SUB_MACHINE_GUN	mods/skills.hpp	/^			EXPERT_SUB_MACHINE_GUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
EXPLODE	mods/item.hpp	/^		EXPLODE = (1 << 6),$/;"	e	enum:mods::item::capability_t
EXPLODE	mods/weapon-types.hpp	/^		EXPLODE,$/;"	e	enum:mods::weapon::capabilities::cap_t
EXPLOSIVE	mods/aoe.hpp	/^		EXPLOSIVE,	\/** Typical explosive dmg from a frag grenade *\/$/;"	e	enum:mods::aoe::types_t
EXPLOSIVE_NONE	mods/item-types.hpp	/^		EXPLOSIVE_NONE = 0,$/;"	e	enum:mods::weapon::type::explosive
EXPLOSIVE_RESISTANCE	mods/skills.hpp	/^			EXPLOSIVE_RESISTANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
EXP_MAX	class.cpp	3941;"	d	file:
EXTENDED	mods/weapon.hpp	/^		COMPENSATOR, MUZZLE_BRAKE,EXTENDED,$/;"	e	enum:mods::weapon::barrel_t
EXTENDED_MAGAZINE	mods/weapon.hpp	/^		EXTENDED_MAGAZINE,$/;"	e	enum:mods::weapon::magazine_t
EXTENDS_CLIP	mods/weapon-types.hpp	/^		EXTENDS_CLIP,$/;"	e	enum:mods::weapon::capabilities::cap_t
EXTERN_ACT	types.hpp	9;"	d
EX_BREACHABLE	structs.h	184;"	d
EX_BREACHED	structs.h	183;"	d
EX_CLOSED	structs.h	179;"	d
EX_ELECTRIFIED	structs.h	187;"	d
EX_HIDDEN	structs.h	186;"	d
EX_ISDOOR	structs.h	178;"	d
EX_LOCKED	structs.h	180;"	d
EX_PICKPROOF	structs.h	181;"	d
EX_QUEST_LOCKED	structs.h	185;"	d
EX_REINFORCED	structs.h	182;"	d
EnumStringMaker	mods/catch.hpp	/^		struct EnumStringMaker {$/;"	s	namespace:Catch::Detail
EnumStringMaker	mods/catch.hpp	/^		struct EnumStringMaker<T,true> {$/;"	s	namespace:Catch::Detail
Evaluator	mods/catch.hpp	/^		class Evaluator {};$/;"	c	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	mods/catch.hpp	/^		struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Exception	mods/catch.hpp	/^			Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
ExplicitFailure	mods/catch.hpp	/^			ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
ExpressionFailed	mods/catch.hpp	/^			ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
FAILURE	mods/behaviour_tree_status.hpp	/^		FAILURE,$/;"	e	enum:mods::behaviour_tree_status
FALCON_ASSAULT	mods/object.hpp	/^				FALCON_ASSAULT,$/;"	e	enum:mods::object::object_type_enum_t
FALSE	utils.h	526;"	d
FASTBOOT_FILE	db.h	52;"	d
FASTBOOT_FILE	db.h	56;"	d
FASTBOOT_FILE	db.h	60;"	d
FASTER_BREACHES	mods/skills.hpp	/^			FASTER_BREACHES,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
FASTER_RELOADING	mods/skills.hpp	/^			FASTER_RELOADING,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
FASTER_THERMITES	mods/skills.hpp	/^			FASTER_THERMITES,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
FASTER_TRIGGER_FINGER	mods/skills.hpp	/^			FASTER_TRIGGER_FINGER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
FD_SETSIZE	sysdep.h	371;"	d
FIGHT	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
FIGHTING	utils.h	327;"	d
FILENAME	boards.h	40;"	d
FIND_ALL	handler.h	92;"	d
FIND_ALLDOT	handler.h	93;"	d
FIND_CHAR_ROOM	handler.h	101;"	d
FIND_CHAR_WORLD	handler.h	102;"	d
FIND_INDIV	handler.h	91;"	d
FIND_OBJ_EQUIP	handler.h	106;"	d
FIND_OBJ_EQUIP	mods/weapon.hpp	25;"	d
FIND_OBJ_INV	handler.h	103;"	d
FIND_OBJ_INV	mods/weapon.hpp	24;"	d
FIND_OBJ_ROOM	handler.h	104;"	d
FIND_OBJ_WORLD	handler.h	105;"	d
FIRE_NADE_DEALER	mods/skills.hpp	/^			FIRE_NADE_DEALER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
FIRST	mods/flags.hpp	/^		FIRST = LEGACY_AFF,$/;"	e	enum:mods::flags::chunk_type_t
FIRST	mods/object.hpp	/^				FIRST = OBJECT,$/;"	e	enum:mods::object::object_type_enum_t
FIRST	mods/randomized-items.hpp	/^	FIRST = COMMON,$/;"	e	enum:mods::rarity_enum_t
FIRST	structs.h	/^	FIRST,$/;"	e	enum:lense_type_t
FIRST_QUARTER	mods/date-time.hpp	/^		FIRST_QUARTER,$/;"	e	enum:mods::date_time::moon_phase
FLAME	mods/aoe.hpp	/^		FLAME,	\/** Ignites material within blast_radius *\/$/;"	e	enum:mods::aoe::types_t
FLAME	mods/weapon.hpp	/^		FLAME = (1 << 10), CLAYMORE = (1 << 11), REMOTE_EXPLOSIVE = (1 << 12),$/;"	e	enum:mods::weapon::mask_type
FLAMETHROWER	mods/object.hpp	/^				FLAMETHROWER,$/;"	e	enum:mods::object::object_type_enum_t
FLASHBANG_COOLDOWN_TICKS	mods/projectile.hpp	/^		constexpr static int FLASHBANG_COOLDOWN_TICKS = 4; \/** FIXME: a wild guess *\/$/;"	m	namespace:mods::projectile
FLASH_HIDER	mods/weapon.hpp	/^		FLASH_HIDER, SUPPRESSOR$/;"	e	enum:mods::weapon::barrel_t
FLIMSY	mods/yaml.hpp	/^	FLIMSY,$/;"	e	enum:mods::yaml::durability_profile_type_t
FOREACH_MOB	utils.h	558;"	d
FOREST	structs.h	/^			FOREST,$/;"	m	struct:room_data	typeref:enum:room_data::
FOR_ROOM	utils.h	557;"	d
FROZEN	mods/flags.hpp	/^		FROZEN,$/;"	e	enum:mods::flags::plr
FROZEN	structs.h	/^			FROZEN,$/;"	m	struct:room_data	typeref:enum:room_data::
FULL	structs.h	581;"	d
FULL_MOON	mods/date-time.hpp	/^		FULL_MOON,$/;"	e	enum:mods::date_time::moon_phase
FUMES	mods/weapon.hpp	/^		MACHINE_PISTOL = (1 << 7), ENERGY = (1 << 8), FUMES = (1 << 9),$/;"	e	enum:mods::weapon::mask_type
FURTHER_C4S	mods/skills.hpp	/^			FURTHER_C4S,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
FailureBit	mods/catch.hpp	/^			FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
FalseTest	mods/catch.hpp	/^			FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
FalseType	mods/catch.hpp	/^		struct FalseType {$/;"	s	namespace:Catch::Detail
FatalErrorCondition	mods/catch.hpp	/^			FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Flags	mods/catch.hpp	/^		enum Flags {$/;"	g	struct:Catch::ResultDisposition
Free_Invalid_List	ban.cpp	/^void Free_Invalid_List(void) {$/;"	f
GA	telnet.h	48;"	d
GADGET_NONE	mods/item-types.hpp	/^		GADGET_NONE = 0,$/;"	e	enum:mods::weapon::type::gadget
GARBAGE_SPACE	structs.h	667;"	d
GAUNTLETS	mods/object.hpp	/^				GAUNTLETS,$/;"	e	enum:mods::object::object_type_enum_t
GET_AC	utils.h	311;"	d
GET_ADD	utils.h	303;"	d
GET_AGE	utils.h	278;"	d
GET_ALIASES	utils.h	341;"	d
GET_ALIGNMENT	utils.h	330;"	d
GET_BAD_PWS	utils.h	337;"	d
GET_BANK_GOLD	utils.h	319;"	d
GET_CHA	utils.h	308;"	d
GET_CLASS	utils.h	296;"	d
GET_CON	utils.h	307;"	d
GET_COND	utils.h	332;"	d
GET_DAMROLL	utils.h	321;"	d
GET_DEFAULT_POS	utils.h	354;"	d
GET_DEX	utils.h	304;"	d
GET_EQ	utils.h	347;"	d
GET_EXP	utils.h	310;"	d
GET_FREEZE_LEV	utils.h	336;"	d
GET_GOLD	utils.h	318;"	d
GET_HEIGHT	utils.h	298;"	d
GET_HIT	utils.h	312;"	d
GET_HITROLL	utils.h	320;"	d
GET_HOME	utils.h	297;"	d
GET_IDNUM	utils.h	324;"	d
GET_INT	utils.h	305;"	d
GET_INVIS_LEV	utils.h	334;"	d
GET_LAST_OLC_MODE	utils.h	340;"	d
GET_LAST_OLC_TARG	utils.h	339;"	d
GET_LAST_TELL	utils.h	342;"	d
GET_LEVEL	utils.h	284;"	d
GET_LOADROOM	utils.h	333;"	d
GET_MANA	utils.h	316;"	d
GET_MAX_HIT	utils.h	313;"	d
GET_MAX_MANA	utils.h	317;"	d
GET_MAX_MOVE	utils.h	315;"	d
GET_MOB_RNUM	utils.h	350;"	d
GET_MOB_SPEC	utils.h	349;"	d
GET_MOB_VNUM	utils.h	351;"	d
GET_MOB_WAIT	utils.h	379;"	d
GET_MOVE	utils.h	314;"	d
GET_NAME	utils.h	281;"	d
GET_OBJ_AFFECT	utils.h	403;"	d
GET_OBJ_COST	utils.h	401;"	d
GET_OBJ_EXTRA	utils.h	404;"	d
GET_OBJ_RENT	utils.h	402;"	d
GET_OBJ_RNUM	utils.h	409;"	d
GET_OBJ_SPEC	utils.h	412;"	d
GET_OBJ_TIMER	utils.h	408;"	d
GET_OBJ_TYPE	utils.h	400;"	d
GET_OBJ_VAL	utils.h	406;"	d
GET_OBJ_VNUM	utils.h	410;"	d
GET_OBJ_WEAR	utils.h	405;"	d
GET_OBJ_WEIGHT	utils.h	407;"	d
GET_PASSWD	utils.h	285;"	d
GET_PC_NAME	utils.h	280;"	d
GET_PFILEPOS	utils.h	286;"	d
GET_POS	utils.h	323;"	d
GET_REAL_LEVEL	utils.h	292;"	d
GET_ROOM_SPEC	utils.h	266;"	d
GET_ROOM_VNUM	utils.h	264;"	d
GET_SAVE	utils.h	329;"	d
GET_SEX	utils.h	300;"	d
GET_SKILL	utils.h	344;"	d
GET_STR	utils.h	302;"	d
GET_TALK	utils.h	338;"	d
GET_TITLE	utils.h	283;"	d
GET_WAIT_STATE	utils.h	381;"	d
GET_WAS_IN	utils.cpp	/^room_rnum& GET_WAS_IN(char_data* ch){$/;"	f
GET_WAS_IN	utils.cpp	/^room_rnum& GET_WAS_IN(player_ptr_t& player){$/;"	f
GET_WEIGHT	utils.h	299;"	d
GET_WIMP_LEV	utils.h	335;"	d
GET_WIS	utils.h	306;"	d
GIVEN	mods/catch.hpp	12214;"	d
GLASS_WINDOWS	structs.h	/^			GLASS_WINDOWS,$/;"	m	struct:room_data	typeref:enum:room_data::
GODLIKE	mods/yaml.hpp	/^	GODLIKE,$/;"	e	enum:mods::yaml::durability_profile_type_t
GOD_TIER	mods/rarity.hpp	/^		constexpr static float GOD_TIER = 0.001311304;$/;"	m	namespace:mods::rarity
GOLIATH_ASSAULT	mods/object.hpp	/^				GOLIATH_ASSAULT,$/;"	e	enum:mods::object::object_type_enum_t
GRAPPLE	mods/weapon-types.hpp	/^		GRAPPLE,$/;"	e	enum:mods::weapon::capabilities::cap_t
GRASS	structs.h	/^			GRASS,			\/** typically grass that isn't flammable (i.e. not dried out) *\/$/;"	m	struct:room_data	typeref:enum:room_data::
GREETINGS	db.cpp	/^std::string GREETINGS = "";		\/* opening credits screen	*\/$/;"	v
GREETINGS_FILE	db.h	79;"	d
GRENADE	mods/weapon.hpp	/^		GRENADE = (1 << 4), ASSAULT_RIFLE = (1 << 5), PISTOL = (1 << 6),$/;"	e	enum:mods::weapon::mask_type
GRENADE_EXPLOSION	mods/ai_state.hpp	/^				GRENADE_FLIES_BY,GRENADE_EXPLOSION,$/;"	e	enum:mods::ai_state::event_type_t
GRENADE_FLIES_BY	mods/ai_state.hpp	/^				GRENADE_FLIES_BY,GRENADE_EXPLOSION,$/;"	e	enum:mods::ai_state::event_type_t
GRIP	mods/weapon.hpp	/^		GRIP,$/;"	e	enum:mods::weapon::attachment_t
GROUP	mods/flags.hpp	/^		GROUP,$/;"	e	enum:mods::flags::aff
HANDBOOK_FILE	db.h	86;"	d
HARDENED	mods/yaml.hpp	/^	HARDENED,$/;"	e	enum:mods::yaml::durability_profile_type_t
HAS_CLIP	mods/weapon-types.hpp	/^		HAS_CLIP,$/;"	e	enum:mods::weapon::capabilities::cap_t
HAS_RLIMIT	sysdep.h	407;"	d
HAS_SANDBOX	mods/builder.hpp	/^	constexpr static uint64_t HAS_SANDBOX = (1 << 0);$/;"	m	namespace:mods::builder
HAS_SPELL_ROUTINE	utils.h	245;"	d
HAVE_ARPA_INET_H	conf.h	92;"	d
HAVE_ARPA_TELNET_H	conf.h	95;"	d
HAVE_ASSERT_H	conf.h	98;"	d
HAVE_CRYPT_H	conf.h	101;"	d
HAVE_ERRNO_H	conf.h	104;"	d
HAVE_FCNTL_H	conf.h	107;"	d
HAVE_GETTIMEOFDAY	conf.h	50;"	d
HAVE_INET_ADDR	conf.h	53;"	d
HAVE_INET_ATON	conf.h	56;"	d
HAVE_LIMITS_H	conf.h	110;"	d
HAVE_MCHECK_H	conf.h	113;"	d
HAVE_MEMORY_H	conf.h	116;"	d
HAVE_NETDB_H	conf.h	122;"	d
HAVE_NETINET_IN_H	conf.h	125;"	d
HAVE_SELECT	conf.h	59;"	d
HAVE_SIGNAL_H	conf.h	128;"	d
HAVE_SNPRINTF	bsd-snprintf.cpp	101;"	d	file:
HAVE_SNPRINTF	conf.h	62;"	d
HAVE_STRCASECMP	conf.h	65;"	d
HAVE_STRDUP	conf.h	68;"	d
HAVE_STRERROR	conf.h	71;"	d
HAVE_STRINGS_H	conf.h	134;"	d
HAVE_STRING_H	conf.h	131;"	d
HAVE_STRNCASECMP	conf.h	80;"	d
HAVE_STRSTR	conf.h	86;"	d
HAVE_STRUCT_IN_ADDR	conf.h	41;"	d
HAVE_SYS_FCNTL_H	conf.h	137;"	d
HAVE_SYS_RESOURCE_H	conf.h	140;"	d
HAVE_SYS_SELECT_H	conf.h	143;"	d
HAVE_SYS_SOCKET_H	conf.h	146;"	d
HAVE_SYS_STAT_H	conf.h	149;"	d
HAVE_SYS_TIME_H	conf.h	152;"	d
HAVE_SYS_TYPES_H	conf.h	155;"	d
HAVE_SYS_UIO_H	conf.h	158;"	d
HAVE_SYS_WAIT_H	conf.h	11;"	d
HAVE_UNISTD_H	conf.h	161;"	d
HAVE_VPRINTF	conf.h	14;"	d
HAVE_VSNPRINTF	bsd-snprintf.cpp	102;"	d	file:
HAVE_VSNPRINTF	conf.h	89;"	d
HAZARDOUS_SMOKE	structs.h	/^			HAZARDOUS_SMOKE, \/** think: gas attacks *\/$/;"	m	struct:room_data	typeref:enum:room_data::
HCONTROL_FILE	db.h	98;"	d
HCONTROL_FORMAT	house.cpp	/^const char *HCONTROL_FORMAT =$/;"	v
HEADER_BLOCK	mail.h	53;"	d
HEADER_BLOCK_DATASIZE	mail.h	71;"	d
HEADGEAR_INTROSPECTION	mods/skills.hpp	/^			HEADGEAR_INTROSPECTION,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
HEADSHOT_CHANCE	mods/skills.hpp	/^			HEADSHOT_CHANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
HELMET	mods/object.hpp	/^				HELMET,$/;"	e	enum:mods::object::object_type_enum_t
HELP_PAGE_FILE	db.h	80;"	d
HFO_INDEX	mods/player.cpp	/^		HFO_INDEX =1,HFO_START=2,HFO_STOP=3,HFO_LOG=4$/;"	e	enum:mods::histfile_opcode_t	file:
HFO_LOG	mods/player.cpp	/^		HFO_INDEX =1,HFO_START=2,HFO_STOP=3,HFO_LOG=4$/;"	e	enum:mods::histfile_opcode_t	file:
HFO_START	mods/player.cpp	/^		HFO_INDEX =1,HFO_START=2,HFO_STOP=3,HFO_LOG=4$/;"	e	enum:mods::histfile_opcode_t	file:
HFO_STOP	mods/player.cpp	/^		HFO_INDEX =1,HFO_START=2,HFO_STOP=3,HFO_LOG=4$/;"	e	enum:mods::histfile_opcode_t	file:
HGH_DEALER	mods/skills.hpp	/^			HGH_DEALER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
HGH_MORE_POWERFUL	mods/skills.hpp	/^			HGH_MORE_POWERFUL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
HIDE	mods/flags.hpp	/^		HIDE,$/;"	e	enum:mods::flags::aff
HIP_FIRE	mods/weapon-types.hpp	/^		HIP_FIRE,$/;"	e	enum:mods::weapon::capabilities::cap_t
HISTFILE_DUAL	mods/player.cpp	/^	HISTFILE_FILE = 1, HISTFILE_LMDB = 2, HISTFILE_DUAL = 3$/;"	e	enum:histfile_type_t	file:
HISTFILE_FILE	mods/player.cpp	/^	HISTFILE_FILE = 1, HISTFILE_LMDB = 2, HISTFILE_DUAL = 3$/;"	e	enum:histfile_type_t	file:
HISTFILE_LMDB	mods/player.cpp	/^	HISTFILE_FILE = 1, HISTFILE_LMDB = 2, HISTFILE_DUAL = 3$/;"	e	enum:histfile_type_t	file:
HISTFILE_STRATEGY	mods/player.cpp	/^static constexpr histfile_type_t HISTFILE_STRATEGY = histfile_type_t::HISTFILE_FILE;$/;"	v	file:
HISTORY_SIZE	structs.h	672;"	d
HLP_PREFIX	db.h	73;"	d
HMHR	utils.h	432;"	d
HOLD_ANYTHING	mods/player.hpp	/^			HOLD_ANYTHING = 1,$/;"	e	enum:mods::player::misc_pref_enum_t
HOLOGRAPHIC	mods/weapon.hpp	/^		ACOG, LASER_DOT, HOLOGRAPHIC,$/;"	e	enum:mods::weapon::scope_t
HOST_LENGTH	structs.h	680;"	d
HOUSE_PRIVATE	house.h	4;"	d
HSHR	utils.h	430;"	d
HSSH	utils.h	431;"	d
HUH	interpreter.h	23;"	d
HUNTING	utils.h	328;"	d
HURRICANE_ASSAULT	mods/object.hpp	/^				HURRICANE_ASSAULT,$/;"	e	enum:mods::object::object_type_enum_t
House_boot	house.cpp	/^void House_boot(void) {$/;"	f
House_boot	mods/hell.hpp	/^	constexpr inline bool House_boot = false;$/;"	m	namespace:mods::hell
House_can_enter	house.cpp	/^int House_can_enter(char_data *ch, room_vnum house) {$/;"	f
House_crashsave	house.cpp	/^void House_crashsave(room_vnum vnum) {$/;"	f
House_delete_file	house.cpp	/^void House_delete_file(room_vnum vnum) {$/;"	f
House_get_filename	house.cpp	/^int House_get_filename(room_vnum vnum, char *filename, size_t maxlen) {$/;"	f
House_list_guests	house.cpp	/^void House_list_guests(char_data *ch, int i, int quiet) {$/;"	f
House_listrent	house.cpp	/^void House_listrent(char_data *ch, room_vnum vnum) {$/;"	f
House_load	house.cpp	/^int House_load(room_vnum vnum) {$/;"	f
House_restore_weight	house.cpp	/^void House_restore_weight(struct obj_data *obj) {$/;"	f
House_save	house.cpp	/^int House_save(struct obj_data *obj, FILE *fp) {$/;"	f
House_save_all	house.cpp	/^void House_save_all(void) {$/;"	f
House_save_control	house.cpp	/^void House_save_control(void) {$/;"	f
IAC	telnet.h	42;"	d
ICMP	globals.hpp	233;"	d
IContext	mods/catch.hpp	/^	struct IContext {$/;"	s	namespace:Catch
IDEA_FILE	db.h	88;"	d
IDXTYPE	structs.h	129;"	d
IGeneratorInfo	mods/catch.hpp	/^	struct IGeneratorInfo {$/;"	s	namespace:Catch
IGeneratorsForTest	mods/catch.hpp	/^	struct IGeneratorsForTest {$/;"	s	namespace:Catch
IHBD	interpreter.h	22;"	d
IMMLIST_FILE	db.h	83;"	d
IMM_CAN_SEE	utils.h	449;"	d
IMOTD_FILE	db.h	78;"	d
IMutableContext	mods/catch.hpp	/^	struct IMutableContext : IContext {$/;"	s	namespace:Catch
INCENDIARY_AMMUNITION	mods/weapon.hpp	/^		INCENDIARY_AMMUNITION$/;"	e	enum:mods::weapon::magazine_t
INCREASED_AWARENESS	mods/skills.hpp	/^			INCREASED_AWARENESS,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INCREASED_INJURE_CHANCE	mods/skills.hpp	/^			INCREASED_INJURE_CHANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INDESTRUCTIBLE	mods/yaml.hpp	/^	INDESTRUCTIBLE$/;"	e	enum:mods::yaml::durability_profile_type_t
INDEX_FILE	db.h	66;"	d
INDEX_SIZE	boards.h	15;"	d
INDOOR_ATTIC	mods/rooms.hpp	/^		INDOOR_ATTIC,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_BASEMENT	mods/rooms.hpp	/^		INDOOR_BASEMENT,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_CARPET_WOODEN_WALLS	mods/rooms.hpp	/^		INDOOR_CARPET_WOODEN_WALLS,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_CEMENT	mods/rooms.hpp	/^		INDOOR_CEMENT,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_CEMENT_WOODEN_WALLS	mods/rooms.hpp	/^		INDOOR_CEMENT_WOODEN_WALLS,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_MARKET_PLACE	mods/rooms.hpp	/^		INDOOR_MARKET_PLACE,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_METAL_HATCH	mods/rooms.hpp	/^		INDOOR_METAL_HATCH,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_METAL_WALLS	mods/rooms.hpp	/^		INDOOR_METAL_WALLS,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_ROOF	mods/rooms.hpp	/^		INDOOR_ROOF,	\/** attached to the roof like spiderman *\/$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_SERVER_ROOM	mods/rooms.hpp	/^		INDOOR_SERVER_ROOM,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_SEWER	mods/rooms.hpp	/^		INDOOR_SEWER,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_SHALLOW_WATER	mods/rooms.hpp	/^		INDOOR_SHALLOW_WATER$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_TUNNEL	mods/rooms.hpp	/^		INDOOR_TUNNEL,$/;"	e	enum:mods::rooms::sector_type_t
INDOOR_WOODEN_WALLS	mods/rooms.hpp	/^		INDOOR_WOODEN_WALLS,$/;"	e	enum:mods::rooms::sector_type_t
INDUSTRIAL_STRENGTH	mods/yaml.hpp	/^	INDUSTRIAL_STRENGTH,$/;"	e	enum:mods::yaml::durability_profile_type_t
INFO_FILE	db.h	81;"	d
INFRAVISION	mods/flags.hpp	/^		INFRAVISION,$/;"	e	enum:mods::flags::aff
INJURE_RESISTANCE	mods/skills.hpp	/^			INJURE_RESISTANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INK	mods/aoe.hpp	/^		INK,	\/** Marks surroundings and enemies with paint for the purpose of tracking *\/ $/;"	e	enum:mods::aoe::types_t
INSERT	mods/lmdb.hpp	/^		EXEC, UPDATE, INSERT $/;"	e	enum:mods::lmdb::transact_type_t
INSIDE	structs.h	/^			INSIDE,			\/** Example: inside a home *\/$/;"	m	struct:room_data	typeref:enum:room_data::
INSTALL	mods/item.hpp	/^		INSTALL = (1 << 0),$/;"	e	enum:mods::item::capability_t
INSTALL	mods/weapon-types.hpp	/^		INSTALL = 0,$/;"	e	enum:mods::weapon::capabilities::cap_t
INSTALL_MASK	mods/object-utils.hpp	/^	constexpr static obj_data::location_data_t INSTALL_MASK = 16;$/;"	m	namespace:mods::object_utils
INSTALL_TICKS_DURATION	mods/object-utils.hpp	/^	constexpr static uint8_t INSTALL_TICKS_DURATION = 30;$/;"	m	namespace:mods::object_utils
INTERMEDIATE_ASSAULT_RIFLE	mods/skills.hpp	/^			INTERMEDIATE_ASSAULT_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INTERMEDIATE_PISTOL	mods/skills.hpp	/^			INTERMEDIATE_PISTOL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INTERMEDIATE_SHOTGUN	mods/skills.hpp	/^			INTERMEDIATE_SHOTGUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INTERMEDIATE_SNIPER_RIFLE	mods/skills.hpp	/^			INTERMEDIATE_SNIPER_RIFLE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INTERMEDIATE_SUB_MACHINE_GUN	mods/skills.hpp	/^			INTERMEDIATE_SUB_MACHINE_GUN,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
INTERNAL_CATCH_ELSE	mods/catch.hpp	2276;"	d
INTERNAL_CATCH_GENERATE	mods/catch.hpp	2706;"	d
INTERNAL_CATCH_IF	mods/catch.hpp	2271;"	d
INTERNAL_CATCH_INFO	mods/catch.hpp	2351;"	d
INTERNAL_CATCH_LINESTR	mods/catch.hpp	2704;"	d
INTERNAL_CATCH_LINESTR2	mods/catch.hpp	2703;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	mods/catch.hpp	806;"	d
INTERNAL_CATCH_MSG	mods/catch.hpp	2333;"	d
INTERNAL_CATCH_NO_THROW	mods/catch.hpp	2281;"	d
INTERNAL_CATCH_REACT	mods/catch.hpp	2241;"	d
INTERNAL_CATCH_REGISTER_LEGACY_REPORTER	mods/catch.hpp	10386;"	d
INTERNAL_CATCH_REGISTER_LISTENER	mods/catch.hpp	10392;"	d
INTERNAL_CATCH_REGISTER_REPORTER	mods/catch.hpp	10389;"	d
INTERNAL_CATCH_REGISTER_TESTCASE	mods/catch.hpp	822;"	d
INTERNAL_CATCH_SECTION	mods/catch.hpp	2521;"	d
INTERNAL_CATCH_STRINGIFY	mods/catch.hpp	375;"	d
INTERNAL_CATCH_STRINGIFY2	mods/catch.hpp	374;"	d
INTERNAL_CATCH_TEST	mods/catch.hpp	2255;"	d
INTERNAL_CATCH_TESTCASE	mods/catch.hpp	802;"	d
INTERNAL_CATCH_TESTCASE2	mods/catch.hpp	798;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	mods/catch.hpp	818;"	d
INTERNAL_CATCH_TEST_CASE_METHOD2	mods/catch.hpp	810;"	d
INTERNAL_CATCH_THROWS	mods/catch.hpp	2295;"	d
INTERNAL_CATCH_THROWS_AS	mods/catch.hpp	2312;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION	mods/catch.hpp	2809;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION2	mods/catch.hpp	2804;"	d
INTERNAL_CATCH_UNIQUE_NAME	mods/catch.hpp	369;"	d
INTERNAL_CATCH_UNIQUE_NAME	mods/catch.hpp	371;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE	mods/catch.hpp	367;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE2	mods/catch.hpp	366;"	d
INTERNAL_CHECK_THAT	mods/catch.hpp	2355;"	d
INTIMIDATED	mods/affects.hpp	/^		INTIMIDATED = 3,$/;"	e	enum:mods::affects::affect_t
INVALID_SOCKET	comm.cpp	81;"	d	file:
INVISIBLE	mods/flags.hpp	/^		INVISIBLE, $/;"	e	enum:mods::flags::aff
INVIS_OK	utils.h	443;"	d
INVIS_OK_OBJ	utils.h	462;"	d
INVSTART	mods/flags.hpp	/^		INVSTART,$/;"	e	enum:mods::flags::plr
IN_ROOM	utils.h	273;"	d
IP	telnet.h	53;"	d
ISNEWL	utils.h	158;"	d
IS_AFFECTED	utils.h	248;"	d
IS_CARRYING_N	utils.h	326;"	d
IS_CARRYING_W	utils.h	325;"	d
IS_CLERIC	utils.h	504;"	d
IS_CLOSED	graph.cpp	57;"	d	file:
IS_CORPSE	utils.h	415;"	d
IS_DARK	utils.h	260;"	d
IS_DIRECTION	globals.hpp	39;"	d
IS_EVIL	utils.h	372;"	d
IS_GOD	shop.h	89;"	d
IS_GOOD	utils.h	371;"	d
IS_LIGHT	utils.h	261;"	d
IS_MAGIC_USER	utils.h	502;"	d
IS_MARINE	utils.h	508;"	d
IS_MARKED	graph.cpp	55;"	d	file:
IS_MOB	utils.h	232;"	d
IS_MOVE	interpreter.h	20;"	d
IS_NEUTRAL	utils.h	373;"	d
IS_NPC	utils.h	231;"	d
IS_SET	utils.h	200;"	d
IS_SUPPORT	utils.h	511;"	d
IS_THIEF	utils.h	506;"	d
IS_TOPIC	act.informative.cpp	1377;"	d	file:
IS_WARRIOR	utils.h	510;"	d
IS_WEAPON	fight.cpp	125;"	d	file:
IS_WEAPON_LOADED	mods/weapon.hpp	15;"	d
IShared	mods/catch.hpp	/^	struct IShared : NonCopyable {$/;"	s	namespace:Catch
ITEM_ANTI_CLERIC	structs.h	496;"	d
ITEM_ANTI_EVIL	structs.h	493;"	d
ITEM_ANTI_GOOD	structs.h	492;"	d
ITEM_ANTI_MAGIC_USER	structs.h	495;"	d
ITEM_ANTI_NEUTRAL	structs.h	494;"	d
ITEM_ANTI_THIEF	structs.h	497;"	d
ITEM_ANTI_WARRIOR	structs.h	498;"	d
ITEM_ARMOR	mods/item-types.hpp	519;"	d
ITEM_ARMOR	structs.h	450;"	d
ITEM_ATTACHMENT	mods/item-types.hpp	518;"	d
ITEM_ATTACHMENT	structs.h	449;"	d
ITEM_BLESS	structs.h	491;"	d
ITEM_BOAT	structs.h	438;"	d
ITEM_CONSUMABLE	mods/item-types.hpp	520;"	d
ITEM_CONSUMABLE	structs.h	451;"	d
ITEM_CONTAINER	structs.h	431;"	d
ITEM_DRINKCON	structs.h	433;"	d
ITEM_DRONE	mods/item-types.hpp	515;"	d
ITEM_DRONE	structs.h	446;"	d
ITEM_EXPLOSIVE	mods/item-types.hpp	513;"	d
ITEM_EXPLOSIVE	structs.h	444;"	d
ITEM_FIREWEAPON	structs.h	424;"	d
ITEM_FOOD	structs.h	435;"	d
ITEM_FOUNTAIN	structs.h	439;"	d
ITEM_GADGET	mods/item-types.hpp	514;"	d
ITEM_GADGET	structs.h	445;"	d
ITEM_GLOW	structs.h	483;"	d
ITEM_HUM	structs.h	484;"	d
ITEM_INVISIBLE	structs.h	488;"	d
ITEM_KEY	structs.h	434;"	d
ITEM_LIGHT	structs.h	420;"	d
ITEM_MAGIC	structs.h	489;"	d
ITEM_MISSILE	structs.h	425;"	d
ITEM_MONEY	structs.h	436;"	d
ITEM_NODONATE	structs.h	486;"	d
ITEM_NODROP	structs.h	490;"	d
ITEM_NOINVIS	structs.h	487;"	d
ITEM_NORENT	structs.h	485;"	d
ITEM_NOSELL	structs.h	499;"	d
ITEM_NOTE	structs.h	432;"	d
ITEM_OTHER	structs.h	429;"	d
ITEM_PEN	structs.h	437;"	d
ITEM_POTION	structs.h	427;"	d
ITEM_RIFLE	mods/item-types.hpp	512;"	d
ITEM_RIFLE	structs.h	443;"	d
ITEM_SCROLL	structs.h	421;"	d
ITEM_STAFF	structs.h	423;"	d
ITEM_TRAP	mods/item-types.hpp	521;"	d
ITEM_TRAP	structs.h	452;"	d
ITEM_TRASH	structs.h	430;"	d
ITEM_TREASURE	structs.h	426;"	d
ITEM_WAND	structs.h	422;"	d
ITEM_WEAPON	mods/item-types.hpp	516;"	d
ITEM_WEAPON	structs.h	447;"	d
ITEM_WEAPON_ATTACHMENT	mods/item-types.hpp	517;"	d
ITEM_WEAPON_ATTACHMENT	structs.h	448;"	d
ITEM_WEAR_ABOUT	structs.h	467;"	d
ITEM_WEAR_ARMS	structs.h	465;"	d
ITEM_WEAR_BACKPACK	structs.h	477;"	d
ITEM_WEAR_BODY	structs.h	460;"	d
ITEM_WEAR_ELBOW	structs.h	476;"	d
ITEM_WEAR_FEET	structs.h	463;"	d
ITEM_WEAR_FINGER	structs.h	458;"	d
ITEM_WEAR_GOGGLES	structs.h	478;"	d
ITEM_WEAR_HANDS	structs.h	464;"	d
ITEM_WEAR_HEAD	structs.h	461;"	d
ITEM_WEAR_HOLD	structs.h	472;"	d
ITEM_WEAR_LEGS	structs.h	462;"	d
ITEM_WEAR_NECK	structs.h	459;"	d
ITEM_WEAR_PRIMARY	structs.h	471;"	d
ITEM_WEAR_SECONDARY	structs.h	473;"	d
ITEM_WEAR_SHIELD	structs.h	466;"	d
ITEM_WEAR_SHOULDERS	structs.h	474;"	d
ITEM_WEAR_TAKE	structs.h	457;"	d
ITEM_WEAR_VEST_PACK	structs.h	475;"	d
ITEM_WEAR_WAIST	structs.h	468;"	d
ITEM_WEAR_WEAPON_ATTACHMENT	structs.h	479;"	d
ITEM_WEAR_WIELD	structs.h	470;"	d
ITEM_WEAR_WRIST	structs.h	469;"	d
ITEM_WORN	structs.h	428;"	d
ITestCase	mods/catch.hpp	/^	struct ITestCase : IShared {$/;"	s	namespace:Catch
ITestCaseRegistry	mods/catch.hpp	/^	struct ITestCaseRegistry {$/;"	s	namespace:Catch
Impl	mods/catch.hpp	/^		namespace Impl {$/;"	n	namespace:Catch::Matchers
Info	mods/catch.hpp	/^			Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Internal	mods/catch.hpp	/^	namespace Internal {$/;"	n	namespace:Catch
IsEqualTo	mods/catch.hpp	/^			IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThan	mods/catch.hpp	/^			IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThanOrEqualTo	mods/catch.hpp	/^			IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
IsLessThan	mods/catch.hpp	/^			IsLessThan,$/;"	e	enum:Catch::Internal::Operator
IsLessThanOrEqualTo	mods/catch.hpp	/^			IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsNotEqualTo	mods/catch.hpp	/^			IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsStreamInsertable	mods/catch.hpp	/^		struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
JS_PATH	mods/js-path.hpp	/^		constexpr static const char * JS_PATH = "..\/lib\/js\/";$/;"	m	namespace:mods::js::path
JS_READ_CHUNK_SIZE	mods/js.hpp	18;"	d
JS_TEST_PATH	mods/js-path.hpp	/^		constexpr static const char * JS_TEST_PATH = "..\/lib\/js\/tests\/";$/;"	m	namespace:mods::js::path
James	castle.cpp	/^SPECIAL(James);$/;"	v
KBLU	screen.h	15;"	d
KCYN	screen.h	17;"	d
KEY_FETCHED_OKAY	mods/lmdb.hpp	/^		constexpr static int KEY_FETCHED_OKAY = 1;$/;"	m	struct:mods::lmdb::_db_handle
KEY_NOT_FOUND	mods/lmdb.hpp	/^		constexpr static int KEY_NOT_FOUND = 0;$/;"	m	struct:mods::lmdb::_db_handle
KGRN	screen.h	13;"	d
KILLER	mods/flags.hpp	/^		KILLER = 1,$/;"	e	enum:mods::flags::plr
KILLSCRIPT_FILE	db.h	53;"	d
KILLSCRIPT_FILE	db.h	57;"	d
KILLSCRIPT_FILE	db.h	61;"	d
KINDLING	structs.h	/^			KINDLING = 1,$/;"	e	enum:uint8_t
KMAG	screen.h	16;"	d
KNIFE	mods/object.hpp	/^				KNIFE,$/;"	e	enum:mods::object::object_type_enum_t
KNRM	screen.h	11;"	d
KNUL	screen.h	19;"	d
KRED	screen.h	12;"	d
KWHT	screen.h	18;"	d
KYEL	screen.h	14;"	d
LADDER	structs.h	/^			LADDER, \/** a ladder leading up or down *\/$/;"	m	struct:room_data	typeref:enum:room_data::
LARGE_BUFSIZE	structs.h	670;"	d
LASER_DOT	mods/weapon.hpp	/^		ACOG, LASER_DOT, HOLOGRAPHIC,$/;"	e	enum:mods::weapon::scope_t
LASER_SIGHT	mods/weapon.hpp	/^		LASER_SIGHT$/;"	e	enum:mods::weapon::siderail_t
LAST	mods/flags.hpp	/^		LAST = BUILDER$/;"	e	enum:mods::flags::chunk_type_t
LAST	mods/object.hpp	/^				LAST = __ARMOR_BRANDS_END__$/;"	e	enum:mods::object::object_type_enum_t
LAST	mods/randomized-items.hpp	/^	LAST = ELITE$/;"	e	enum:mods::rarity_enum_t
LAST	structs.h	/^	LAST$/;"	e	enum:lense_type_t
LAST_BLOCK	mail.h	54;"	d
LEAF	mods/behaviour_tree_node.hpp	/^		enum node_type_t { DO_NOTHING, SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
LEARNED	spec_procs.cpp	132;"	d	file:
LEARNED_LEVEL	spec_procs.cpp	124;"	d	file:
LEGACY_AFF	mods/flags.hpp	/^		LEGACY_AFF = 0,$/;"	e	enum:mods::flags::chunk_type_t
LEGACY_AFF_BLIND	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_BLIND = (1 << 0);$/;"	m	namespace:mods::flags
LEGACY_AFF_CHARM	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_CHARM = (1 << 21);$/;"	m	namespace:mods::flags
LEGACY_AFF_CURSE	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_CURSE = (1 << 9);$/;"	m	namespace:mods::flags
LEGACY_AFF_DETECT_ALIGN	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_DETECT_ALIGN = (1 << 2);$/;"	m	namespace:mods::flags
LEGACY_AFF_DETECT_INVIS	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_DETECT_INVIS = (1 << 3);$/;"	m	namespace:mods::flags
LEGACY_AFF_DETECT_MAGIC	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_DETECT_MAGIC = (1 << 4);$/;"	m	namespace:mods::flags
LEGACY_AFF_GROUP	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_GROUP = (1 << 8);$/;"	m	namespace:mods::flags
LEGACY_AFF_HIDE	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_HIDE = (1 << 19);$/;"	m	namespace:mods::flags
LEGACY_AFF_INFRAVISION	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_INFRAVISION = (1 << 10);$/;"	m	namespace:mods::flags
LEGACY_AFF_INVISIBLE	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_INVISIBLE = (1 << 1);$/;"	m	namespace:mods::flags
LEGACY_AFF_NOTRACK	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_NOTRACK = (1 << 15);$/;"	m	namespace:mods::flags
LEGACY_AFF_POISON	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_POISON = (1 << 11);$/;"	m	namespace:mods::flags
LEGACY_AFF_PROTECT_EVIL	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_PROTECT_EVIL = (1 << 12);$/;"	m	namespace:mods::flags
LEGACY_AFF_PROTECT_GOOD	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_PROTECT_GOOD = (1 << 13);$/;"	m	namespace:mods::flags
LEGACY_AFF_SANCTUARY	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_SANCTUARY = (1 << 7);$/;"	m	namespace:mods::flags
LEGACY_AFF_SENSE_LIFE	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_SENSE_LIFE = (1 << 5);$/;"	m	namespace:mods::flags
LEGACY_AFF_SLEEP	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_SLEEP = (1 << 14);$/;"	m	namespace:mods::flags
LEGACY_AFF_SNEAK	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_SNEAK = (1 << 18);$/;"	m	namespace:mods::flags
LEGACY_AFF_UNUSED16	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_UNUSED16 = (1 << 16);$/;"	m	namespace:mods::flags
LEGACY_AFF_UNUSED17	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_UNUSED17 = (1 << 17);$/;"	m	namespace:mods::flags
LEGACY_AFF_UNUSED20	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_UNUSED20 = (1 << 20);$/;"	m	namespace:mods::flags
LEGACY_AFF_WATERWALK	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_AFF_WATERWALK = (1 << 6);$/;"	m	namespace:mods::flags
LEGACY_PLR	mods/flags.hpp	/^		LEGACY_PLR,$/;"	e	enum:mods::flags::chunk_type_t
LEGACY_PLR_CRASH	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_CRASH = (1 << 6);$/;"	m	namespace:mods::flags
LEGACY_PLR_CRYO	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_CRYO = (1 << 15);$/;"	m	namespace:mods::flags
LEGACY_PLR_DELETED	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_DELETED = (1 << 10);$/;"	m	namespace:mods::flags
LEGACY_PLR_DONTSET	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_DONTSET = (1 << 3);$/;"	m	namespace:mods::flags
LEGACY_PLR_FROZEN	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_FROZEN = (1 << 2);$/;"	m	namespace:mods::flags
LEGACY_PLR_INVSTART	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_INVSTART = (1 << 14);$/;"	m	namespace:mods::flags
LEGACY_PLR_KILLER	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_KILLER = (1 << 0);$/;"	m	namespace:mods::flags
LEGACY_PLR_LOADROOM	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_LOADROOM = (1 << 11);$/;"	m	namespace:mods::flags
LEGACY_PLR_MAILING	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_MAILING = (1 << 5);$/;"	m	namespace:mods::flags
LEGACY_PLR_NODELETE	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_NODELETE = (1 << 13);$/;"	m	namespace:mods::flags
LEGACY_PLR_NOSHOUT	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_NOSHOUT = (1 << 8);$/;"	m	namespace:mods::flags
LEGACY_PLR_NOTDEADYET	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_NOTDEADYET = (1 << 16);$/;"	m	namespace:mods::flags
LEGACY_PLR_NOTITLE	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_NOTITLE = (1 << 9);$/;"	m	namespace:mods::flags
LEGACY_PLR_NOWIZLIST	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_NOWIZLIST = (1 << 12);$/;"	m	namespace:mods::flags
LEGACY_PLR_SITEOK	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_SITEOK = (1 << 7);$/;"	m	namespace:mods::flags
LEGACY_PLR_THIEF	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_THIEF = (1 << 1);$/;"	m	namespace:mods::flags
LEGACY_PLR_WRITING	mods/flags.hpp	/^	constexpr static uint64_t LEGACY_PLR_WRITING = (1 << 4);$/;"	m	namespace:mods::flags
LEGENDARY	mods/randomized-items.hpp	/^	LEGENDARY,$/;"	e	enum:mods::rarity_enum_t
LEGENDARY	mods/rarity.hpp	/^		constexpr static float LEGENDARY = 0.0100341;$/;"	m	namespace:mods::rarity
LEGENDARY_DROP_RATE	mods/randomized-items.hpp	/^		constexpr static float LEGENDARY_DROP_RATE = 3.0;$/;"	m	class:mods::randomized_items
LEGS	mods/object.hpp	/^				LEGS,$/;"	e	enum:mods::object::object_type_enum_t
LFLOW_OFF	telnet.h	153;"	d
LFLOW_ON	telnet.h	154;"	d
LFLOW_RESTART_ANY	telnet.h	155;"	d
LFLOW_RESTART_XON	telnet.h	156;"	d
LIB_ETC	db.h	26;"	d
LIB_ETC	db.h	37;"	d
LIB_HOUSE	db.h	30;"	d
LIB_HOUSE	db.h	41;"	d
LIB_MISC	db.h	25;"	d
LIB_MISC	db.h	36;"	d
LIB_PLRALIAS	db.h	29;"	d
LIB_PLRALIAS	db.h	40;"	d
LIB_PLROBJS	db.h	28;"	d
LIB_PLROBJS	db.h	39;"	d
LIB_PLRTEXT	db.h	27;"	d
LIB_PLRTEXT	db.h	38;"	d
LIB_TEXT	db.h	23;"	d
LIB_TEXT	db.h	34;"	d
LIB_TEXT_HELP	db.h	24;"	d
LIB_TEXT_HELP	db.h	35;"	d
LIB_WORLD	db.h	22;"	d
LIB_WORLD	db.h	33;"	d
LIGHT_MACHINE_GUN	mods/object.hpp	/^				LIGHT_MACHINE_GUN,$/;"	e	enum:mods::object::object_type_enum_t
LIGHT_OK	utils.h	440;"	d
LIMB_CHANCE	mods/skills.hpp	/^			LIMB_CHANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
LIQ_ALE	structs.h	561;"	d
LIQ_BEER	structs.h	559;"	d
LIQ_BLOOD	structs.h	571;"	d
LIQ_CLEARWATER	structs.h	573;"	d
LIQ_COFFE	structs.h	570;"	d
LIQ_DARKALE	structs.h	562;"	d
LIQ_FIREBRT	structs.h	565;"	d
LIQ_LEMONADE	structs.h	564;"	d
LIQ_LOCALSPC	structs.h	566;"	d
LIQ_MILK	structs.h	568;"	d
LIQ_SALTWATER	structs.h	572;"	d
LIQ_SLIME	structs.h	567;"	d
LIQ_TEA	structs.h	569;"	d
LIQ_WATER	structs.h	558;"	d
LIQ_WHISKY	structs.h	563;"	d
LIQ_WINE	structs.h	560;"	d
LIST_PRODUCE	shop.h	101;"	d
LIST_ROOM	shop.h	103;"	d
LIST_TRADE	shop.h	102;"	d
LMDBCOMMIT	globals.hpp	53;"	d
LMDBDEL	globals.hpp	51;"	d
LMDBGET	globals.hpp	52;"	d
LMDBNDEL	globals.hpp	50;"	d
LMDBNGET	globals.hpp	48;"	d
LMDBNSET	globals.hpp	45;"	d
LMDBRENEW	globals.hpp	54;"	d
LMDBSET	globals.hpp	47;"	d
LMDBVGET	globals.hpp	49;"	d
LM_FORWARDMASK	telnet.h	163;"	d
LM_MODE	telnet.h	162;"	d
LM_SLC	telnet.h	164;"	d
LOADED	mods/weapon.hpp	14;"	d
LOADROOM	mods/flags.hpp	/^		LOADROOM,$/;"	e	enum:mods::flags::plr
LOCK_DOOR	act.movement.cpp	345;"	d	file:
LOC_INVENTORY	objsave.cpp	28;"	d	file:
LOGNAME	config.cpp	/^const char *LOGNAME = NULL;$/;"	v
LONG_RANGE	mods/object.hpp	/^				LONG_RANGE,$/;"	e	enum:mods::object::object_type_enum_t
LONG_STRING	bsd-snprintf.cpp	815;"	d	file:
LOS_SCAN_DIRECTION_DEBUG	mods/scan.cpp	4;"	d	file:
LOS_SCAN_DIRECTION_DEBUG	mods/scan.cpp	6;"	d	file:
LOWER	utils.h	155;"	d
LOW_ATMOSPHERE	structs.h	/^			LOW_ATMOSPHERE,	\/** atmosphere too thin for helicopter to fly *\/$/;"	m	struct:room_data	typeref:enum:room_data::
LVL_BUILDER	structs.h	/^	LVL_BUILDER = 34,$/;"	e	enum:player_level
LVL_BUILDER	structs.h	630;"	d
LVL_FREEZE	structs.h	637;"	d
LVL_GOD	structs.h	/^	LVL_GOD = 32,$/;"	e	enum:player_level
LVL_GOD	structs.h	632;"	d
LVL_GRGOD	structs.h	/^	LVL_GRGOD = 33,$/;"	e	enum:player_level
LVL_GRGOD	structs.h	631;"	d
LVL_IMMORT	structs.h	/^	LVL_IMMORT = 31,$/;"	e	enum:player_level
LVL_IMMORT	structs.h	633;"	d
LVL_IMPL	structs.h	/^	LVL_IMPL = 35$/;"	e	enum:player_level
LVL_IMPL	structs.h	629;"	d
LVL_MORTAL	structs.h	/^	LVL_MORTAL = 0,$/;"	e	enum:player_level
LVL_MORTAL	structs.h	634;"	d
MACHETE	mods/object.hpp	/^				MACHETE,$/;"	e	enum:mods::object::object_type_enum_t
MACHINE_PISTOL	mods/weapon.hpp	/^		MACHINE_PISTOL = (1 << 7), ENERGY = (1 << 8), FUMES = (1 << 9),$/;"	e	enum:mods::weapon::mask_type
MAGAZINE	mods/weapon.hpp	/^		MAGAZINE,$/;"	e	enum:mods::weapon::attachment_t
MAGIC_NUMBER	structs.h	640;"	d
MAGNIFICATION_SIX	mods/weapon.hpp	/^		MAGNIFICATION_SIX,$/;"	e	enum:mods::weapon::scope_t
MAGNIFICATION_TWELVE	mods/weapon.hpp	/^		MAGNIFICATION_TWELVE,$/;"	e	enum:mods::weapon::scope_t
MAG_AFFECTS	spells.h	24;"	d
MAG_ALTER_OBJS	spells.h	27;"	d
MAG_AREAS	spells.h	30;"	d
MAG_CREATIONS	spells.h	32;"	d
MAG_DAMAGE	spells.h	23;"	d
MAG_GROUPS	spells.h	28;"	d
MAG_MANUAL	spells.h	33;"	d
MAG_MASSES	spells.h	29;"	d
MAG_POINTS	spells.h	26;"	d
MAG_SUMMONS	spells.h	31;"	d
MAG_UNAFFECTS	spells.h	25;"	d
MAILING	mods/flags.hpp	/^		MAILING,$/;"	e	enum:mods::flags::plr
MAIL_FILE	db.h	96;"	d
MAIN_PLAYER_INDEX	mods/player-scaffolding.hpp	/^		constexpr static std::size_t MAIN_PLAYER_INDEX = 0;$/;"	m	struct:mods::player_scaffolding
MANIC	mods/ai_state.hpp	/^				MANIC,CHAOTIC,RESERVED$/;"	e	enum:mods::ai_state::state
MANUAL_SPELL	spells.h	259;"	d
MARK	graph.cpp	53;"	d	file:
MARKSMANSHIP	mods/skills.hpp	/^		MARKSMANSHIP,$/;"	e	enum:mods::skills::fields_of_study
MAX	bsd-snprintf.cpp	97;"	d	file:
MAX	utils.cpp	/^int MAX(int a, int b) {$/;"	f
MAX	utils.h	75;"	d
MAXGAIN	spec_procs.cpp	134;"	d	file:
MAX_AFFECT	structs.h	684;"	d
MAX_AOE_TRIGGERS	mods/yaml.hpp	/^	constexpr static std::size_t MAX_AOE_TRIGGERS = 6;$/;"	m	namespace:mods::yaml
MAX_BAG_ROWS	objsave.cpp	29;"	d	file:
MAX_BOARD_MESSAGES	boards.h	12;"	d
MAX_DEPTH	mods/scan.cpp	/^	constexpr static std::size_t MAX_DEPTH = 6;$/;"	m	namespace:mods::scan	file:
MAX_EXPLOSION_FADE_OUT	structs.h	/^constexpr static std::size_t MAX_EXPLOSION_FADE_OUT = 5;$/;"	v
MAX_GUESTS	house.h	2;"	d
MAX_HOUSES	house.h	1;"	d
MAX_INPUT_LENGTH	structs.h	674;"	d
MAX_INVALID_NAMES	ban.cpp	245;"	d	file:
MAX_MAIL_SIZE	mail.h	26;"	d
MAX_MESSAGES	structs.h	676;"	d
MAX_MESSAGE_LENGTH	boards.h	13;"	d
MAX_MOB_DESC	olc.h	18;"	d
MAX_MOB_NAME	olc.h	15;"	d
MAX_NAME_LENGTH	structs.h	677;"	d
MAX_NOTE_LENGTH	structs.h	686;"	d
MAX_OBJ_AFFECT	structs.h	685;"	d
MAX_OBJ_DESC	olc.h	19;"	d
MAX_OBJ_NAME	olc.h	16;"	d
MAX_OPER	shop.h	131;"	d
MAX_OUTSIDE_BANK	shop.h	171;"	d
MAX_PER_PRAC	spec_procs.cpp	125;"	d	file:
MAX_PROD	shop.h	83;"	d
MAX_PROMPT_LENGTH	structs.h	666;"	d
MAX_PWD_LENGTH	structs.h	678;"	d
MAX_RANGE	mods/weapon.hpp	/^	static constexpr uint8_t MAX_RANGE = 4;$/;"	m	namespace:mods::weapon
MAX_RAW_INPUT_LENGTH	structs.h	675;"	d
MAX_ROOM_DESC	olc.h	17;"	d
MAX_ROOM_DISTANCE	mods/weapon.hpp	/^		constexpr static uint8_t MAX_ROOM_DISTANCE = 10;$/;"	m	namespace:mods::weapon::yaml
MAX_ROOM_DISTANCE	mods/yaml.hpp	/^	constexpr static uint8_t MAX_ROOM_DISTANCE = 4;$/;"	m	namespace:mods::yaml
MAX_ROOM_NAME	olc.h	14;"	d
MAX_SHOP_OBJ	shop.h	85;"	d
MAX_SKILLS	structs.h	683;"	d
MAX_SOCK_BUF	structs.h	665;"	d
MAX_SPELLS	spells.h	93;"	d
MAX_SPELL_AFFECTS	magic.cpp	318;"	d	file:
MAX_STRING_LENGTH	structs.h	673;"	d
MAX_TITLE_LENGTH	structs.h	679;"	d
MAX_TONGUE	structs.h	682;"	d
MAX_TRADE	shop.h	82;"	d
MEMORY	utils.h	355;"	d
MENTOC_ABIL_SET	db.cpp	1069;"	d	file:
MENTOC_ARMOR_MEMBERS_TUPLE	mods/item-types.hpp	239;"	d
MENTOC_ARMOR_TYPES_SEQUENCE	mods/item-types.hpp	223;"	d
MENTOC_ATTACHMENT_MEMBERS_TUPLE	mods/item-types.hpp	207;"	d
MENTOC_ATTACHMENT_TYPES_SEQUENCE	mods/item-types.hpp	194;"	d
MENTOC_BASE_MEMBERS	mods/yaml.hpp	50;"	d
MENTOC_BASE_MEMBERS_SET	mods/yaml.hpp	63;"	d
MENTOC_BITVECTOR	mods/builder.cpp	3407;"	d	file:
MENTOC_CONSUMABLE_MEMBERS_TUPLE	mods/item-types.hpp	261;"	d
MENTOC_CONSUMABLE_TYPES_SEQUENCE	mods/item-types.hpp	252;"	d
MENTOC_DATA_CLASS	mods/weapon-types.hpp	135;"	d
MENTOC_DATA_CLASS	mods/weapon-types.hpp	83;"	d
MENTOC_DATA_OBJ	structs.h	927;"	d
MENTOC_DATA_OBJ	structs.h	964;"	d
MENTOC_DECLARE_DATA_STRUCTS	mods/item-types.hpp	357;"	d
MENTOC_DECLARE_DATA_STRUCTS_IMPL	mods/item-types.hpp	349;"	d
MENTOC_DEFER	globals.hpp	38;"	d
MENTOC_DEPRECATED	globals.hpp	56;"	d
MENTOC_DP	mods/yaml.hpp	102;"	d
MENTOC_DP	mods/yaml.hpp	106;"	d
MENTOC_DP	mods/yaml.hpp	115;"	d
MENTOC_DP	mods/yaml.hpp	90;"	d
MENTOC_DRONE_MEMBERS_TUPLE	mods/item-types.hpp	158;"	d
MENTOC_DRONE_TYPES_SEQUENCE	mods/item-types.hpp	154;"	d
MENTOC_ENUM_TYPES_IMPL	mods/item-types.hpp	380;"	d
MENTOC_EXAMPLE_ARMORS	mods/item-types.hpp	482;"	d
MENTOC_EXAMPLE_ATTACHMENTS	mods/item-types.hpp	450;"	d
MENTOC_EXAMPLE_CONSUMABLE	mods/item-types.hpp	492;"	d
MENTOC_EXAMPLE_DRONES	mods/item-types.hpp	440;"	d
MENTOC_EXAMPLE_EXPLOSIVES	mods/item-types.hpp	472;"	d
MENTOC_EXAMPLE_GADGETS	mods/item-types.hpp	429;"	d
MENTOC_EXAMPLE_IMPL	mods/item-types.hpp	391;"	d
MENTOC_EXAMPLE_RIFLES	mods/item-types.hpp	461;"	d
MENTOC_EXAMPLE_TRAP	mods/item-types.hpp	502;"	d
MENTOC_EXPLOSIVE_MEMBERS_TUPLE	mods/item-types.hpp	142;"	d
MENTOC_EXPLOSIVE_TYPES_SEQUENCE	mods/item-types.hpp	128;"	d
MENTOC_FEED_ARMOR	mods/item-types.hpp	478;"	d
MENTOC_FEED_ATTACHMENT	mods/item-types.hpp	446;"	d
MENTOC_FEED_BASE_MEMBERS	mods/yaml.cpp	23;"	d	file:
MENTOC_FEED_CONSUMABLE	mods/item-types.hpp	488;"	d
MENTOC_FEED_DRONE	mods/item-types.hpp	436;"	d
MENTOC_FEED_EXPLOSIVE	mods/item-types.hpp	468;"	d
MENTOC_FEED_GADGET	mods/item-types.hpp	425;"	d
MENTOC_FEED_PARSE_ACTUAL_IMPL	mods/item-types.hpp	412;"	d
MENTOC_FEED_PARSE_ALL_IMPL	mods/item-types.hpp	417;"	d
MENTOC_FEED_RIFLE	mods/item-types.hpp	457;"	d
MENTOC_FEED_TRAP	mods/item-types.hpp	498;"	d
MENTOC_FEED_TYPE_IMPL	mods/item-types.hpp	386;"	d
MENTOC_FILE_EXISTS_PREAMBLE	mods/yaml.cpp	16;"	d	file:
MENTOC_F_EXA	act.builder.cpp	662;"	d	file:
MENTOC_F_EXA	act.builder.cpp	676;"	d	file:
MENTOC_F_IMPORT	mods/object-utils.hpp	291;"	d
MENTOC_F_IMPORT	mods/object-utils.hpp	306;"	d
MENTOC_GADGET_MEMBERS_TUPLE	mods/item-types.hpp	183;"	d
MENTOC_GADGET_TYPES_SEQUENCE	mods/item-types.hpp	173;"	d
MENTOC_GENERIC_WEARS_IMPL	mods/item-types.hpp	337;"	d
MENTOC_ITEM_PARSE	mods/util.cpp	496;"	d	file:
MENTOC_ITEM_PARSE_IMPL	mods/util.cpp	492;"	d	file:
MENTOC_ITEM_TYPES_BY_CAPS_SEQ	mods/item-types.hpp	32;"	d
MENTOC_ITEM_TYPES_CAPS_SEQ	mods/item-types.hpp	22;"	d
MENTOC_ITEM_TYPES_SEQ	mods/item-types.hpp	12;"	d
MENTOC_ITEM_TYPES_SEQ_CAPS	mods/item-types.hpp	78;"	d
MENTOC_ITEM_TYPE_LIST_SEQUENCE	mods/item-types.hpp	316;"	d
MENTOC_LAZY	mods/rooms.hpp	110;"	d
MENTOC_LAZY	mods/rooms.hpp	92;"	d
MENTOC_LAZY_COMP	mods/doors.hpp	241;"	d
MENTOC_LAZY_COMP	mods/doors.hpp	252;"	d
MENTOC_LAZY_INT	mods/builder.cpp	1588;"	d	file:
MENTOC_LAZY_INT	mods/builder.cpp	1607;"	d	file:
MENTOC_LAZY_ME	mods/builder.cpp	2827;"	d	file:
MENTOC_LAZY_ME	mods/builder.cpp	2836;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	414;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	423;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	430;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	439;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	440;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	449;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	456;"	d	file:
MENTOC_LAZY_ME	mods/util.cpp	465;"	d	file:
MENTOC_LAZY_POS	act.debug.cpp	224;"	d	file:
MENTOC_LAZY_POS	act.debug.cpp	238;"	d	file:
MENTOC_LAZY_POS	act.debug.cpp	248;"	d	file:
MENTOC_LAZY_POS	act.debug.cpp	262;"	d	file:
MENTOC_LAZY_SHOP	mods/builder.cpp	1672;"	d	file:
MENTOC_LAZY_SHOP	mods/builder.cpp	1697;"	d	file:
MENTOC_LAZY_STR	mods/builder.cpp	1572;"	d	file:
MENTOC_LAZY_STR	mods/builder.cpp	1587;"	d	file:
MENTOC_MEMBER_VARS_EXAMPLE_FOR	mods/item-types.hpp	403;"	d
MENTOC_MEMBER_VARS_EXAMPLE_IMPL	mods/item-types.hpp	394;"	d
MENTOC_MEMBER_VARS_FOR	mods/item-types.hpp	406;"	d
MENTOC_MEMBER_VARS_IMPL	mods/item-types.hpp	409;"	d
MENTOC_MOB_WEARS	mods/item-types.hpp	339;"	d
MENTOC_MS_COMP	mods/doors.hpp	224;"	d
MENTOC_MS_COMP	mods/doors.hpp	238;"	d
MENTOC_OBI	mods/builder.cpp	26;"	d	file:
MENTOC_OBI2	mods/builder.cpp	27;"	d	file:
MENTOC_OBJ_DATA_FEED_DUAL	structs.cpp	63;"	d	file:
MENTOC_OBJ_DATA_FEED_SWITCH	mods/item-types.hpp	374;"	d
MENTOC_OBJ_DATA_FEED_SWITCH_IMPL	mods/item-types.hpp	368;"	d
MENTOC_OBJ_DATA_STAT_GEN	structs.cpp	73;"	d	file:
MENTOC_OBJ_INITIALIZE_CONSTRUCTOR	structs.cpp	46;"	d	file:
MENTOC_OBS	mods/builder.cpp	28;"	d	file:
MENTOC_OBS2	mods/builder.cpp	29;"	d	file:
MENTOC_PLAYER_NULL_CHECK	mods/builder.cpp	974;"	d	file:
MENTOC_PREAMBLE	globals.hpp	36;"	d
MENTOC_RIFLE_MEMBERS_TUPLE	mods/item-types.hpp	106;"	d
MENTOC_RIFLE_TYPES_SEQUENCE	mods/item-types.hpp	97;"	d
MENTOC_SHOW_FLAG	mods/builder.cpp	3443;"	d	file:
MENTOC_SHOW_OBJ	mods/builder.cpp	2234;"	d	file:
MENTOC_SHOW_OBJ_BITVECTOR	mods/builder.cpp	2226;"	d	file:
MENTOC_SHOW_OBJ_FLAGS	mods/builder.cpp	2218;"	d	file:
MENTOC_T	mods/aoe.hpp	32;"	d
MENTOC_T	mods/aoe.hpp	55;"	d
MENTOC_T	mods/lmdb.hpp	68;"	d
MENTOC_T	mods/lmdb.hpp	83;"	d
MENTOC_TFIND	mods/overhead_map.cpp	52;"	d	file:
MENTOC_TO_STR	mods/weapon.hpp	199;"	d
MENTOC_TO_STR	mods/weapon.hpp	204;"	d
MENTOC_TO_STR	mods/weapon.hpp	209;"	d
MENTOC_TO_STR	mods/weapon.hpp	226;"	d
MENTOC_TO_STR	mods/weapon.hpp	231;"	d
MENTOC_TO_STR	mods/weapon.hpp	241;"	d
MENTOC_TO_STR	mods/weapon.hpp	246;"	d
MENTOC_TO_STR	mods/weapon.hpp	252;"	d
MENTOC_TO_STR	mods/weapon.hpp	256;"	d
MENTOC_TO_STR	mods/weapon.hpp	267;"	d
MENTOC_TO_STR	mods/weapon.hpp	271;"	d
MENTOC_TO_STR	mods/weapon.hpp	286;"	d
MENTOC_TO_STR	mods/weapon.hpp	290;"	d
MENTOC_TO_STR	mods/weapon.hpp	301;"	d
MENTOC_TO_STR	mods/weapon.hpp	305;"	d
MENTOC_TO_STR	mods/weapon.hpp	311;"	d
MENTOC_TRAP_MEMBERS_TUPLE	mods/item-types.hpp	303;"	d
MENTOC_TRAP_TYPES_SEQUENCE	mods/item-types.hpp	300;"	d
MENTOC_TYPE	mods/builder.cpp	3381;"	d	file:
MENTOC_TYPE_LIST_IMPL	mods/item-types.hpp	562;"	d
MENTOC_UPTR	structs.h	1017;"	d
MENTOC_UPTR	structs.h	1019;"	d
MENTOC_USING_CT	mods/item-types.hpp	333;"	d
MENTOC_USING_CT_IMPL	mods/item-types.hpp	330;"	d
MENTOC_WEAPON	mods/builder.cpp	129;"	d	file:
MENTOC_WEAPON	mods/builder.cpp	145;"	d	file:
MENTOC_WEAR	mods/builder.cpp	3364;"	d	file:
MENTOC_WEAR_PLACES_SEQ	mods/item-types.hpp	42;"	d
MENTOC_YAML_DESC	mods/item-types.hpp	346;"	d
MENTOC_YAML_DESC_IMPL	mods/item-types.hpp	345;"	d
MENU	config.cpp	/^const char *MENU =$/;"	v
MESS_FILE	db.h	91;"	d
METAL_HATCH	structs.h	/^			METAL_HATCH,$/;"	m	struct:room_data	typeref:enum:room_data::
METAL_WALL	structs.h	/^			METAL_WALL,$/;"	m	struct:room_data	typeref:enum:room_data::
MIN	utils.cpp	/^int MIN(int a, int b) {$/;"	f
MIN	utils.h	79;"	d
MINDEX_FILE	db.h	67;"	d
MINGAIN	spec_procs.cpp	133;"	d	file:
MIN_MAIL_LEVEL	mail.h	20;"	d
MIN_OUTSIDE_BANK	shop.h	170;"	d
MIN_PER_PRAC	spec_procs.cpp	126;"	d	file:
MISC	act.wizard.cpp	2350;"	d	file:
MISDIRECTION	mods/skills.hpp	/^			MISDIRECTION,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
MOB	mods/player.hpp	/^			PLAYER, MOB, DRONE,$/;"	e	enum:mods::player::player_type_enum_t
MOBILITY_RESTRICTING_FOAM	mods/aoe.hpp	/^		MOBILITY_RESTRICTING_FOAM,	\/** A foam that restricts enemy movement once dried. Dries fast *\/$/;"	e	enum:mods::aoe::types_t
MOBTOSTR	globals.hpp	57;"	d
MOB_AERIALSERVANT	magic.cpp	788;"	d	file:
MOB_AGGRESSIVE	structs.h	286;"	d
MOB_AGGR_EVIL	structs.h	289;"	d
MOB_AGGR_GOOD	structs.h	290;"	d
MOB_AGGR_NEUTRAL	structs.h	291;"	d
MOB_AGGR_TO_ALIGN	mobact.cpp	40;"	d	file:
MOB_AWARE	structs.h	285;"	d
MOB_CLONE	magic.cpp	786;"	d	file:
MOB_DOESNT_EXIST	mods/behaviour_tree_impl.hpp	/^			MOB_DOESNT_EXIST$/;"	e	enum:mods::behaviour_tree_impl::dispatch_status_t
MOB_DOESNT_EXIST	mods/behaviour_tree_status.hpp	/^		MOB_DOESNT_EXIST$/;"	e	enum:mods::behaviour_tree_status
MOB_ELEMENTAL_BASE	magic.cpp	785;"	d	file:
MOB_FLAGGED	utils.h	235;"	d
MOB_FLAGS	utils.h	220;"	d
MOB_GATE_I	magic.cpp	780;"	d	file:
MOB_GATE_II	magic.cpp	781;"	d	file:
MOB_GATE_III	magic.cpp	782;"	d	file:
MOB_HELPER	structs.h	293;"	d
MOB_ISNPC	structs.h	284;"	d
MOB_MEMORY	structs.h	292;"	d
MOB_MONSUM_I	magic.cpp	777;"	d	file:
MOB_MONSUM_II	magic.cpp	778;"	d	file:
MOB_MONSUM_III	magic.cpp	779;"	d	file:
MOB_MUTED_DESCRIPTOR	mods/player.hpp	/^			MOB_MUTED_DESCRIPTOR,$/;"	e	enum:mods::player::player_type_enum_t
MOB_NOBASH	structs.h	297;"	d
MOB_NOBLIND	structs.h	298;"	d
MOB_NOCHARM	structs.h	294;"	d
MOB_NOSLEEP	structs.h	296;"	d
MOB_NOSUMMON	structs.h	295;"	d
MOB_NOTDEADYET	structs.h	299;"	d
MOB_PREFIX	db.h	69;"	d
MOB_SCAVENGER	structs.h	283;"	d
MOB_SENTINEL	structs.h	282;"	d
MOB_SPEC	structs.h	281;"	d
MOB_STAY_ZONE	structs.h	287;"	d
MOB_WIMPY	structs.h	288;"	d
MOB_ZOMBIE	magic.cpp	787;"	d	file:
MODE_ACK	telnet.h	168;"	d
MODE_ECHO	telnet.h	176;"	d
MODE_EDIT	telnet.h	166;"	d
MODE_FLOW	telnet.h	175;"	d
MODE_FORCE	telnet.h	179;"	d
MODE_INBIN	telnet.h	177;"	d
MODE_LIT_ECHO	telnet.h	170;"	d
MODE_MASK	telnet.h	172;"	d
MODE_OUTBIN	telnet.h	178;"	d
MODE_SOFT_TAB	telnet.h	169;"	d
MODE_TRAPSIG	telnet.h	167;"	d
MODS_BREACH_DISORIENT	globals.cpp	29;"	d	file:
MODS_GRENADE_BASE_DAMAGE	globals.cpp	30;"	d	file:
MOD_AGGRESSION_CHANCE	mods/ai_state.cpp	17;"	d	file:
MOD_AGGRESSION_MODIFIER	mods/ai_state.cpp	16;"	d	file:
MOD_LENIENT_MAX	mods/ai_state.hpp	17;"	d
MOD_SNIPE_AGGRESSION	mods/ai_state.cpp	14;"	d	file:
MOD_SNIPE_DISTANCE_THACO	fight.cpp	30;"	d	file:
MOD_SNIPE_SAME_ROOM_THACO	fight.cpp	29;"	d	file:
MOD_SNIPE_THRESHOLD	mods/ai_state.cpp	15;"	d	file:
MOD_SUSPICIOUS_MAX	mods/ai_state.hpp	18;"	d
MOD_WANDER_SAY_DIVISOR	mods/ai_state.cpp	18;"	d	file:
MOD_WANDER_SAY_TOP	mods/ai_state.cpp	19;"	d	file:
MOLD	mods/skills.hpp	/^			MOLD,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
MORT_CAN_SEE	utils.h	447;"	d
MORT_CAN_SEE_OBJ	utils.h	470;"	d
MOTD_FILE	db.h	77;"	d
MP5	mods/weapon.hpp	/^			MP5 = 1,$/;"	e	enum:mods::weapon::sentinel::primary_choice_t
MR	mods/player.cpp	1263;"	d	file:
MR	mods/player.cpp	1274;"	d	file:
MRC	mods/player.cpp	1264;"	d	file:
MRC	mods/player.cpp	1275;"	d	file:
MSG_CANT_KILL_KEEPER	shop.h	181;"	d
MSG_CLOSED_FOR_DAY	shop.h	175;"	d
MSG_HEADING	boards.h	44;"	d
MSG_LEVEL	boards.h	46;"	d
MSG_NOT_OPEN_YET	shop.h	173;"	d
MSG_NOT_REOPEN_YET	shop.h	174;"	d
MSG_NO_SEE_CHAR	shop.h	177;"	d
MSG_NO_SELL_ALIGN	shop.h	178;"	d
MSG_NO_SELL_CLASS	shop.h	179;"	d
MSG_NO_STEAL_HERE	shop.h	176;"	d
MSG_NO_USED_WANDSTAFF	shop.h	180;"	d
MSG_SLOTNUM	boards.h	45;"	d
MUNITIONS_REFLECTOR	mods/skills.hpp	/^			MUNITIONS_REFLECTOR,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
MUZZLE_BRAKE	mods/weapon.hpp	/^		COMPENSATOR, MUZZLE_BRAKE,EXTENDED,$/;"	e	enum:mods::weapon::barrel_t
M_MATCH	mods/help.cpp	15;"	d	file:
M_MATCH	mods/help.cpp	5;"	d	file:
MatchAllOf	mods/catch.hpp	/^			struct MatchAllOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatchAnyOf	mods/catch.hpp	/^			struct MatchAnyOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatchNotOf	mods/catch.hpp	/^				MatchNotOf(MatcherBase<ArgT> const& underlyingMatcher) : m_underlyingMatcher(underlyingMatcher) {}$/;"	f	struct:Catch::Matchers::Impl::MatchNotOf
MatchNotOf	mods/catch.hpp	/^			struct MatchNotOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatcherBase	mods/catch.hpp	/^			struct MatcherBase : MatcherUntypedBase {$/;"	s	namespace:Catch::Matchers::Impl
MatcherUntypedBase	mods/catch.hpp	/^			class MatcherUntypedBase {$/;"	c	namespace:Catch::Matchers::Impl
Matchers	mods/catch.hpp	/^	namespace Matchers {$/;"	n	namespace:Catch
MethodTestCase	mods/catch.hpp	/^			MethodTestCase(void (C::*method)()) : m_method(method) {}$/;"	f	class:Catch::MethodTestCase
MethodTestCase	mods/catch.hpp	/^	class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch
NEED_CLOSED	act.movement.cpp	317;"	d	file:
NEED_LOCKED	act.movement.cpp	319;"	d	file:
NEED_OPEN	act.movement.cpp	316;"	d	file:
NEED_STRICMP_PROTO	conf.h	308;"	d
NEED_STRLCPY_PROTO	conf.h	311;"	d
NEED_STRNICMP_PROTO	conf.h	317;"	d
NEED_UNLOCKED	act.movement.cpp	318;"	d	file:
NEWEST_AT_TOP	boards.cpp	60;"	d	file:
NEWS_FILE	db.h	76;"	d
NEW_ENV_VALUE	telnet.h	238;"	d
NEW_ENV_VAR	telnet.h	237;"	d
NEW_MOON	mods/date-time.hpp	/^		NEW_MOON = 0,$/;"	e	enum:mods::date_time::moon_phase
NEW_MSG_INDEX	boards.h	43;"	d
NIGHT_VISION	mods/flags.hpp	/^		NIGHT_VISION,$/;"	e	enum:mods::flags::aff
NIGHT_VISION	mods/weapon-types.hpp	/^		NIGHT_VISION,$/;"	e	enum:mods::weapon::capabilities::cap_t
NIGHT_VISION_GOGGLES	structs.h	/^	NIGHT_VISION_GOGGLES,$/;"	e	enum:lense_type_t
NO	config.cpp	21;"	d	file:
NOBODY	structs.h	132;"	d
NODELETE	mods/flags.hpp	/^		NODELETE,$/;"	e	enum:mods::flags::plr
NOEFFECT	config.cpp	/^const char *NOEFFECT = "Nothing seems to happen.\\r\\n";$/;"	v
NOMINMAX	mods/catch.hpp	6779;"	d
NOMINMAX	mods/catch.hpp	6792;"	d
NONE	mods/affects.hpp	/^		NONE = -1,$/;"	e	enum:mods::affects::affect_t
NONE	mods/behaviour_tree.hpp	/^		static constexpr int NONE = 0;$/;"	m	struct:mods::behaviour_tree
NONE	mods/behaviour_tree_impl.hpp	/^			NONE = 0,$/;"	e	enum:mods::behaviour_tree_impl::type
NONE	mods/events.hpp	/^		NONE = 0,$/;"	e	enum:mods::events::event_enum
NONE	mods/rooms.hpp	/^		NONE = 0,$/;"	e	enum:mods::rooms::sector_type_t
NONE	mods/skills.hpp	/^		NONE = 0,$/;"	e	enum:mods::skills::fields_of_study
NONE	mods/weapon.hpp	/^			NONE = 0,$/;"	e	enum:mods::weapon::sentinel::primary_choice_t
NONE	structs.h	/^			NONE = 0,$/;"	e	enum:uint8_t
NONSTOP_PENETRATION_SHOT	mods/skills.hpp	/^			NONSTOP_PENETRATION_SHOT,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
NON_HAZARDOUS_SMOKE	structs.h	/^			NON_HAZARDOUS_SMOKE, \/** think: burning car *\/$/;"	m	struct:room_data	typeref:enum:room_data::
NOP	telnet.h	56;"	d
NOPERSON	config.cpp	/^const char *NOPERSON = "No-one by that name here.\\r\\n";$/;"	v
NORMAL_SIGHT	mods/flags.hpp	/^		NORMAL_SIGHT,$/;"	e	enum:mods::flags::aff
NORMAL_SIGHT	structs.h	/^	NORMAL_SIGHT,$/;"	e	enum:lense_type_t
NORTH	structs.h	148;"	d
NOSHOUT	mods/flags.hpp	/^		NOSHOUT,$/;"	e	enum:mods::flags::plr
NOTDEADYET	mods/flags.hpp	/^		NOTDEADYET,$/;"	e	enum:mods::flags::plr
NOTHING	structs.h	131;"	d
NOTIFY_OWNER	mods/weapon-types.hpp	/^		NOTIFY_OWNER,$/;"	e	enum:mods::weapon::capabilities::cap_t
NOTITLE	mods/flags.hpp	/^		NOTITLE,$/;"	e	enum:mods::flags::plr
NOTRACK	mods/flags.hpp	/^		NOTRACK,$/;"	e	enum:mods::flags::aff
NOTRADE_CLERIC	shop.h	157;"	d
NOTRADE_EVIL	shop.h	154;"	d
NOTRADE_GOOD	shop.h	153;"	d
NOTRADE_MAGIC_USER	shop.h	156;"	d
NOTRADE_NEUTRAL	shop.h	155;"	d
NOTRADE_THIEF	shop.h	158;"	d
NOTRADE_WARRIOR	shop.h	159;"	d
NOT_IMPL	mods/flags.hpp	/^	constexpr static uint64_t NOT_IMPL = (1 << 22);$/;"	m	namespace:mods::flags
NOWHERE	structs.h	130;"	d
NOWIZLIST	mods/flags.hpp	/^		NOWIZLIST,$/;"	e	enum:mods::flags::plr
NOXIOUS_NADE_CRAFTER	mods/skills.hpp	/^			NOXIOUS_NADE_CRAFTER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
NO_ATTACK_TYPE	mods/ai_state.cpp	20;"	d	file:
NO_FACTOR_ADVANCED	mods/skills.hpp	/^			NO_FACTOR_ADVANCED,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
NO_FACTOR_BASIC	mods/skills.hpp	/^			NO_FACTOR_BASIC,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
NO_FACTOR_ELITE	mods/skills.hpp	/^			NO_FACTOR_ELITE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
NO_LOGIC	mods/behaviour_tree_status.hpp	/^		NO_LOGIC,$/;"	e	enum:mods::behaviour_tree_status
NPC	act.wizard.cpp	2347;"	d	file:
NRM	utils.h	119;"	d
NSLC	telnet.h	200;"	d
NTELOPTS	telnet.h	125;"	d
NULL	utils.h	522;"	d
NUMBER	act.wizard.cpp	2352;"	d	file:
NUM_CLASSES	structs.h	231;"	d
NUM_OF_BOARDS	boards.h	11;"	d
NUM_OF_DIRS	structs.h	639;"	d
NUM_RESERVED_DESCS	comm.h	11;"	d
NUM_TOKENS	interpreter.cpp	1219;"	d	file:
NUM_WEARS	structs.h	414;"	d
NameAndDesc	mods/catch.hpp	/^		NameAndDesc(const char* _name = "", const char* _description= "")$/;"	f	struct:Catch::NameAndDesc
NameAndDesc	mods/catch.hpp	/^	struct NameAndDesc {$/;"	s	namespace:Catch
No	mods/catch.hpp	/^			No$/;"	e	enum:Catch::CaseSensitive::Choice
NonCopyable	mods/catch.hpp	/^			NonCopyable() {}$/;"	f	class:Catch::NonCopyable
NonCopyable	mods/catch.hpp	/^	class NonCopyable {$/;"	c	namespace:Catch
Normal	mods/catch.hpp	/^			Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Not	mods/catch.hpp	/^		inline Impl::MatchNotOf<T> Not(Impl::MatcherBase<T> const& underlyingMatcher) {$/;"	f	namespace:Catch::Matchers
NotImplementedException	mods/catch.hpp	/^			NotImplementedException(NotImplementedException const&) {}$/;"	f	class:Catch::NotImplementedException
NotImplementedException	mods/catch.hpp	/^	class NotImplementedException : public std::exception {$/;"	c	namespace:Catch
OBJAFF_FLAGGED	utils.h	241;"	d
OBJECT	mods/object.hpp	/^				OBJECT = 0,$/;"	e	enum:mods::object::object_type_enum_t
OBJECT_DEAD	shop.h	94;"	d
OBJECT_FROM_ROOM	mods/events.hpp	/^		OBJECT_FROM_ROOM,$/;"	e	enum:mods::events::event_enum
OBJECT_NOTOK	shop.h	95;"	d
OBJECT_NOVAL	shop.h	97;"	d
OBJECT_OK	shop.h	96;"	d
OBJECT_TO_ROOM	mods/events.hpp	/^		OBJECT_TO_ROOM$/;"	e	enum:mods::events::event_enum
OBJN	utils.h	489;"	d
OBJS	utils.h	486;"	d
OBJVAL_FLAGGED	utils.h	242;"	d
OBJWEAR_FLAGGED	utils.h	243;"	d
OBJ_FLAGGED	utils.h	244;"	d
OBJ_PREFIX	db.h	70;"	d
OC_TEST_CASE	mods/catch.hpp	3532;"	d
OFF	utils.h	117;"	d
OK	config.cpp	/^const char *OK = "Okay.\\r\\n";$/;"	v
OLC_ALIASES	olc.h	11;"	d
OLC_COPY	olc.h	8;"	d
OLC_DESC	olc.h	10;"	d
OLC_MOB	olc.h	5;"	d
OLC_NAME	olc.h	9;"	d
OLC_OBJ	olc.h	6;"	d
OLC_REPEAT	olc.h	3;"	d
OLC_ROOM	olc.h	4;"	d
OLC_SET	olc.h	1;"	d
OLC_SHOW	olc.h	2;"	d
OLC_USAGE	olc.cpp	34;"	d	file:
OLD_ENV_VALUE	telnet.h	236;"	d
OLD_ENV_VAR	telnet.h	235;"	d
ONOFF	utils.h	153;"	d
ON_FIRE	structs.h	/^			ON_FIRE,		\/** actively burning *\/$/;"	m	struct:room_data	typeref:enum:room_data::
OPEN_DOOR	act.movement.cpp	339;"	d	file:
OPER_AND	shop.h	129;"	d
OPER_CLOSE_PAREN	shop.h	127;"	d
OPER_NOT	shop.h	130;"	d
OPER_OPEN_PAREN	shop.h	126;"	d
OPER_OR	shop.h	128;"	d
OPPOSITE_DIR	globals.hpp	41;"	d
OPT_USEC	structs.h	650;"	d
OTHER_PLAYER_INDEX_START	mods/player-scaffolding.hpp	/^		constexpr static std::size_t OTHER_PLAYER_INDEX_START = 2;$/;"	m	struct:mods::player_scaffolding
OUT	structs.h	/^			OUT = 5$/;"	e	enum:uint8_t
OUTSIDE	structs.h	/^			OUTSIDE,		\/** Outside where anyone can see you *\/$/;"	m	struct:room_data	typeref:enum:room_data::
OUTSIDE	utils.h	514;"	d
OUTSIDE_AIR	mods/rooms.hpp	/^		OUTSIDE_AIR,	\/** on a rope hanging from a helicopter *\/$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_CEMENT	mods/rooms.hpp	/^		OUTSIDE_CEMENT,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_DESERT	mods/rooms.hpp	/^		OUTSIDE_DESERT,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_DIRT	mods/rooms.hpp	/^		OUTSIDE_DIRT,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_FOREST	mods/rooms.hpp	/^		OUTSIDE_FOREST,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_FROZEN	mods/rooms.hpp	/^		OUTSIDE_FROZEN,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_GRASSY	mods/rooms.hpp	/^		OUTSIDE_GRASSY,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_HILLS	mods/rooms.hpp	/^		OUTSIDE_HILLS,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_MARKET_PLACE	mods/rooms.hpp	/^		OUTSIDE_MARKET_PLACE,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_METAL_HATCH	mods/rooms.hpp	/^		OUTSIDE_METAL_HATCH,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_METAL_WALL	mods/rooms.hpp	/^		OUTSIDE_METAL_WALL,	\/** rappelling *\/$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_ROOFTOP	mods/rooms.hpp	/^		OUTSIDE_ROOFTOP,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_SHALLOW_WATER	mods/rooms.hpp	/^		OUTSIDE_SHALLOW_WATER,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_TREE	mods/rooms.hpp	/^		OUTSIDE_TREE,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_UNDERWATER	mods/rooms.hpp	/^		OUTSIDE_UNDERWATER,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_WATER	mods/rooms.hpp	/^		OUTSIDE_WATER,$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_WOODEN_WALL	mods/rooms.hpp	/^		OUTSIDE_WOODEN_WALL,	\/** rappelling *\/$/;"	e	enum:mods::rooms::sector_type_t
OUTSIDE_WOODEN_WALLS	mods/rooms.hpp	/^		OUTSIDE_WOODEN_WALLS,$/;"	e	enum:mods::rooms::sector_type_t
O_NONBLOCK	comm.cpp	2035;"	d	file:
Obj_from_store	objsave.cpp	/^struct obj_data *Obj_from_store(struct obj_file_elem object, int *location) {$/;"	f
Obj_to_store	objsave.cpp	/^int Obj_to_store(struct obj_data *obj, FILE *fl, int location) {$/;"	f
OfType	mods/catch.hpp	/^		enum OfType {$/;"	g	struct:Catch::ResultWas
Ok	mods/catch.hpp	/^			Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
Operator	mods/catch.hpp	/^		enum Operator {$/;"	g	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsEqualTo>             {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsGreaterThan>         {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsLessThan>            {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsLessThanOrEqualTo>   {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<> struct OperatorTraits<IsNotEqualTo>          {$/;"	s	namespace:Catch::Internal
OperatorTraits	mods/catch.hpp	/^		template<Operator Op> struct OperatorTraits             {$/;"	s	namespace:Catch::Internal
PAGE_LENGTH	comm.h	80;"	d
PAGE_SIZE	mods/player.hpp	/^		static constexpr int PAGE_SIZE = 40;$/;"	m	struct:mods::player
PAGE_WIDTH	comm.h	81;"	d
PARASITIC_HP_RECOVERY	mods/skills.hpp	/^			PARASITIC_HP_RECOVERY,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
PARSE_ARGS	globals.hpp	232;"	d
PASSES_PER_SEC	structs.h	651;"	d
PATH_MAX	sysdep.h	352;"	d
PAUSE_FILE	db.h	54;"	d
PAUSE_FILE	db.h	58;"	d
PAUSE_FILE	db.h	62;"	d
PC	act.wizard.cpp	2346;"	d	file:
PERS	utils.h	484;"	d
PET_PRICE	spec_procs.cpp	702;"	d	file:
PISTOL	mods/weapon.hpp	/^		GRENADE = (1 << 4), ASSAULT_RIFLE = (1 << 5), PISTOL = (1 << 6),$/;"	e	enum:mods::weapon::mask_type
PLACE_HOLDER_VALUE	mods/schema.hpp	/^	constexpr static const char* PLACE_HOLDER_VALUE = "\\x01";$/;"	m	namespace:mods::schema
PLAYER	mods/player.hpp	/^			PLAYER, MOB, DRONE,$/;"	e	enum:mods::player::player_type_enum_t
PLAYER_FILE	db.h	95;"	d
PLAYER_GET	mods/prefs.hpp	20;"	d
PLAYER_GETI	mods/prefs.hpp	22;"	d
PLAYER_MUTED_DESCRIPTOR	mods/player.hpp	/^			PLAYER_MUTED_DESCRIPTOR,$/;"	e	enum:mods::player::player_type_enum_t
PLAYER_SET	mods/prefs.hpp	19;"	d
PLAYER_SETI	mods/prefs.hpp	21;"	d
PLR	mods/flags.hpp	/^		AFF,PLR$/;"	e	enum:mods::flags::flag_group
PLR_CRASH	structs.h	267;"	d
PLR_CRYO	structs.h	276;"	d
PLR_DELETED	structs.h	271;"	d
PLR_DONTSET	structs.h	264;"	d
PLR_FLAGGED	utils.h	236;"	d
PLR_FLAGS	utils.h	221;"	d
PLR_FLAG_COUNT	mods/flags.hpp	/^	constexpr static uint64_t PLR_FLAG_COUNT = plr::__PLR_LAST + 1;$/;"	m	namespace:mods::flags
PLR_FROZEN	structs.h	263;"	d
PLR_INVSTART	structs.h	275;"	d
PLR_KILLER	structs.h	261;"	d
PLR_LOADROOM	structs.h	272;"	d
PLR_MAILING	structs.h	266;"	d
PLR_NODELETE	structs.h	274;"	d
PLR_NOSHOUT	structs.h	269;"	d
PLR_NOTDEADYET	structs.h	277;"	d
PLR_NOTITLE	structs.h	270;"	d
PLR_NOWIZLIST	structs.h	273;"	d
PLR_SITEOK	structs.h	268;"	d
PLR_THIEF	structs.h	262;"	d
PLR_TOG_CHK	utils.h	250;"	d
PLR_WRITING	structs.h	265;"	d
POISON	mods/affects.hpp	/^		POISON = 2,$/;"	e	enum:mods::affects::affect_t
POISON	mods/flags.hpp	/^		POISON,$/;"	e	enum:mods::flags::aff
POISONOUS	mods/aoe.hpp	/^		POISONOUS,	\/** Venomous poisons that need urgent attn *\/$/;"	e	enum:mods::aoe::types_t
POLICIES_FILE	db.h	85;"	d
POSIX	sysdep.h	181;"	d
POSIX	sysdep.h	188;"	d
POSIX	sysdep.h	193;"	d
POSIX_NONBLOCK_BROKEN	sysdep.h	197;"	d
POS_DEAD	structs.h	249;"	d
POS_FIGHTING	structs.h	256;"	d
POS_INCAP	structs.h	251;"	d
POS_MORTALLYW	structs.h	250;"	d
POS_RESTING	structs.h	254;"	d
POS_SITTING	structs.h	255;"	d
POS_SLEEPING	structs.h	253;"	d
POS_STANDING	structs.h	257;"	d
POS_STUNNED	structs.h	252;"	d
PQXX_TR1_HEADERS	mods/string.hpp	8;"	d
PRAC_TYPE	spec_procs.cpp	127;"	d	file:
PREFS_FORMAT_STRING	mods/prefs.hpp	15;"	d
PREFS_SEPARATOR	mods/prefs.hpp	14;"	d
PREVENT_RUN	mods/weapon-types.hpp	/^		PREVENT_RUN,$/;"	e	enum:mods::weapon::capabilities::cap_t
PRF_AUTOEXIT	structs.h	310;"	d
PRF_BRIEF	structs.h	303;"	d
PRF_COLOR_1	structs.h	316;"	d
PRF_COLOR_2	structs.h	317;"	d
PRF_COMPACT	structs.h	304;"	d
PRF_DEAF	structs.h	305;"	d
PRF_DISPAUTO	structs.h	325;"	d
PRF_DISPHP	structs.h	307;"	d
PRF_DISPMANA	structs.h	308;"	d
PRF_DISPMOVE	structs.h	309;"	d
PRF_FLAGGED	utils.h	238;"	d
PRF_FLAGS	utils.h	222;"	d
PRF_HOLYLIGHT	structs.h	315;"	d
PRF_LOG1	structs.h	319;"	d
PRF_LOG2	structs.h	320;"	d
PRF_NOAUCT	structs.h	321;"	d
PRF_NOGOSS	structs.h	322;"	d
PRF_NOGRATZ	structs.h	323;"	d
PRF_NOHASSLE	structs.h	311;"	d
PRF_NOREPEAT	structs.h	314;"	d
PRF_NOTELL	structs.h	306;"	d
PRF_NOWIZ	structs.h	318;"	d
PRF_OVERHEAD_MAP	structs.h	326;"	d
PRF_QUEST	structs.h	312;"	d
PRF_ROOMFLAGS	structs.h	324;"	d
PRF_SUMMONABLE	structs.h	313;"	d
PRF_TOG_CHK	act.other.cpp	917;"	d	file:
PRF_TOG_CHK	utils.h	251;"	d
PROTECT	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
PROTECT_EVIL	mods/flags.hpp	/^		PROTECT_EVIL,		\/\/ useless$/;"	e	enum:mods::flags::aff
PROTECT_FROM_EMP	mods/skills.hpp	/^			PROTECT_FROM_EMP,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
PROTECT_GOOD	mods/flags.hpp	/^		PROTECT_GOOD,		\/\/ useless$/;"	e	enum:mods::flags::aff
PROXIMITY_ALARM	mods/skills.hpp	/^			PROXIMITY_ALARM,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
PRO_WEAPON_HANDLER	mods/skills.hpp	/^			PRO_WEAPON_HANDLER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
PULSE_AUTOSAVE	structs.h	658;"	d
PULSE_BTREE	structs.h	654;"	d
PULSE_IDLEPWD	structs.h	659;"	d
PULSE_MOBILE	structs.h	656;"	d
PULSE_SANITY	structs.h	660;"	d
PULSE_TIMESAVE	structs.h	662;"	d
PULSE_USAGE	structs.h	661;"	d
PULSE_VIOLENCE	structs.h	657;"	d
PULSE_ZONE	structs.h	655;"	d
Ptr	mods/catch.hpp	/^			Ptr() : m_p(CATCH_NULL) {}$/;"	f	class:Catch::Ptr
Ptr	mods/catch.hpp	/^			Ptr(Ptr const& other) : m_p(other.m_p) {$/;"	f	class:Catch::Ptr
Ptr	mods/catch.hpp	/^			Ptr(T* p) : m_p(p) {$/;"	f	class:Catch::Ptr
Ptr	mods/catch.hpp	/^	class Ptr {$/;"	c	namespace:Catch
QBLU	screen.h	44;"	d
QCYN	screen.h	46;"	d
QGRN	screen.h	42;"	d
QMAG	screen.h	45;"	d
QNRM	screen.h	40;"	d
QRED	screen.h	41;"	d
QUEUE_TEXTURE_REMOVAL	mods/projectile.cpp	61;"	d	file:
QUIETER_SNIPER_SHOTS	mods/skills.hpp	/^			QUIETER_SNIPER_SHOTS,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
QWHT	screen.h	47;"	d
QYEL	screen.h	43;"	d
Q_COMPLETE_KEY	mods/quests.cpp	12;"	d	file:
Q_CURRENT_KEY	mods/quests.cpp	6;"	d	file:
Q_CURRENT_VALUE	mods/quests.cpp	7;"	d	file:
Q_FORMAT	mods/quests.cpp	5;"	d	file:
Q_TRIGGER_CODE_KEY	mods/quests.cpp	13;"	d	file:
Q_TRIGGER_KEY	mods/quests.cpp	8;"	d	file:
RADIATION	mods/aoe.hpp	/^		RADIATION, \/** Radioactive fallout *\/$/;"	e	enum:mods::aoe::types_t
RADIOACTIVE	structs.h	/^			RADIOACTIVE, \/** actively emitting radioactivity *\/$/;"	m	struct:room_data	typeref:enum:room_data::
RANGE	act.wizard.cpp	2358;"	d	file:
RANGE	db.cpp	1727;"	d	file:
RANGE	db.cpp	1789;"	d	file:
RANGED_ATTACK	mods/weapon-types.hpp	/^		RANGED_ATTACK,$/;"	e	enum:mods::weapon::capabilities::cap_t
RARE	mods/randomized-items.hpp	/^	RARE,$/;"	e	enum:mods::rarity_enum_t
RARE	mods/rarity.hpp	/^		constexpr static float RARE = 0.05034415;$/;"	m	namespace:mods::rarity
RARE_DROP_RATE	mods/randomized-items.hpp	/^		constexpr static float RARE_DROP_RATE = 6.0;$/;"	m	class:mods::randomized_items
RAVEN_RECON	mods/object.hpp	/^				RAVEN_RECON,$/;"	e	enum:mods::object::object_type_enum_t
RC_DRONE	structs.h	/^	RC_DRONE,$/;"	e	enum:lense_type_t
RC_DRONE_NIGHT_VISION	structs.h	/^	RC_DRONE_NIGHT_VISION,$/;"	e	enum:lense_type_t
RC_DRONE_THERMAL	structs.h	/^	RC_DRONE_THERMAL,$/;"	e	enum:lense_type_t
READ_LVL	boards.h	37;"	d
READ_SIZE	utils.h	27;"	d
REAL	db.h	/^	REAL=0,\\$/;"	e	enum:__anon1
RECON	interpreter.cpp	1626;"	d	file:
RECREATE	utils.h	173;"	d
REDUCED_DETECTION_CHANCE	mods/skills.hpp	/^			REDUCED_DETECTION_CHANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
RELOAD	mods/weapon-types.hpp	/^		RELOAD,$/;"	e	enum:mods::weapon::capabilities::cap_t
REMOTE	mods/item.hpp	/^		REMOTE = (1 << 7),$/;"	e	enum:mods::item::capability_t
REMOTELY_DETONATE	mods/weapon-types.hpp	/^		REMOTELY_DETONATE,$/;"	e	enum:mods::weapon::capabilities::cap_t
REMOTELY_VIEW	mods/weapon-types.hpp	/^		REMOTELY_VIEW,$/;"	e	enum:mods::weapon::capabilities::cap_t
REMOTE_EXPLOSIVE	mods/weapon.hpp	/^		FLAME = (1 << 10), CLAYMORE = (1 << 11), REMOTE_EXPLOSIVE = (1 << 12),$/;"	e	enum:mods::weapon::mask_type
REMOVE_BIT	utils.h	202;"	d
REMOVE_FROM_LIST	utils.h	186;"	d
REMOVE_LVL	boards.h	39;"	d
RENT_CRASH	structs.h	601;"	d
RENT_CRYO	structs.h	603;"	d
RENT_FACTOR	objsave.cpp	25;"	d	file:
RENT_FORCED	structs.h	604;"	d
RENT_RENTED	structs.h	602;"	d
RENT_TIMEDOUT	structs.h	605;"	d
RENT_UNDEF	structs.h	600;"	d
RESERVED	mods/ai_state.hpp	/^				MANIC,CHAOTIC,RESERVED$/;"	e	enum:mods::ai_state::state
RETROFIT_FIRE_GRENADE_LAUNCHER	mods/skills.hpp	/^			RETROFIT_FIRE_GRENADE_LAUNCHER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
RETROFIT_GRENADE_LAUNCHER	mods/skills.hpp	/^			RETROFIT_GRENADE_LAUNCHER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
RETROFIT_SENSOR_GRENADE_LAUNCHER	mods/skills.hpp	/^			RETROFIT_SENSOR_GRENADE_LAUNCHER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
RETROFIT_SMOKE_GRENADE_LAUNCHER	mods/skills.hpp	/^			RETROFIT_SMOKE_GRENADE_LAUNCHER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
RETROFIT_STUN_GRENADE_LAUNCHER	mods/skills.hpp	/^			RETROFIT_STUN_GRENADE_LAUNCHER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
RETSIGTYPE	conf.h	20;"	d
RETURN_FALSE_IMMEDIATELY	mods/behaviour_tree_impl.hpp	/^			RETURN_FALSE_IMMEDIATELY,$/;"	e	enum:mods::behaviour_tree_impl::dispatch_status_t
RETURN_IMMEDIATELY	mods/behaviour_tree_impl.hpp	/^			RETURN_IMMEDIATELY,$/;"	e	enum:mods::behaviour_tree_impl::dispatch_status_t
RIFLE_NONE	mods/item-types.hpp	/^		RIFLE_NONE = 0,$/;"	e	enum:mods::weapon::type::rifle
RLIMIT_NOFILE	sysdep.h	409;"	d
RL_SEC	structs.h	652;"	d
RNUMLIST_MAX_PER_CALL	mods/builder.hpp	/^	constexpr static unsigned int RNUMLIST_MAX_PER_CALL = 10000;$/;"	m	namespace:mods::builder
ROOFTOP	structs.h	/^			ROOFTOP,$/;"	m	struct:room_data	typeref:enum:room_data::
ROOM_ATRIUM	structs.h	172;"	d
ROOM_BFS_MARK	structs.h	174;"	d
ROOM_DARK	structs.h	158;"	d
ROOM_DEATH	structs.h	159;"	d
ROOM_DESC_EMPTY	mods/builder.hpp	/^	constexpr static int ROOM_DESC_EMPTY = -3;$/;"	m	namespace:mods::builder
ROOM_DMZ	structs.h	163;"	d
ROOM_EMP	mods/ai_state.hpp	/^				ROOM_EMP,ROOM_NORMAL$/;"	e	enum:mods::ai_state::event_type_t
ROOM_FLAGGED	utils.h	239;"	d
ROOM_FLAGS	utils.h	224;"	d
ROOM_GODROOM	structs.h	169;"	d
ROOM_HOUSE	structs.h	170;"	d
ROOM_HOUSE_CRASH	structs.h	171;"	d
ROOM_INDOORS	structs.h	161;"	d
ROOM_NAME_EMPTY	mods/builder.hpp	/^	constexpr static int ROOM_NAME_EMPTY = -2;$/;"	m	namespace:mods::builder
ROOM_NOMAGIC	structs.h	166;"	d
ROOM_NOMOB	structs.h	160;"	d
ROOM_NORMAL	mods/ai_state.hpp	/^				ROOM_EMP,ROOM_NORMAL$/;"	e	enum:mods::ai_state::event_type_t
ROOM_NOTRACK	structs.h	165;"	d
ROOM_NUMBER_OUT_OF_RANGE	mods/builder.hpp	/^	constexpr static int ROOM_NUMBER_OUT_OF_RANGE = -1;$/;"	m	namespace:mods::builder
ROOM_OLC	structs.h	173;"	d
ROOM_PEACEFUL	structs.h	162;"	d
ROOM_PRIVATE	structs.h	168;"	d
ROOM_SOUNDPROOF	structs.h	164;"	d
ROOM_TUNNEL	structs.h	167;"	d
RUBBLE	structs.h	/^			RUBBLE,			\/** decimation of buildings resulting in lots of ruble *\/$/;"	m	struct:room_data	typeref:enum:room_data::
RUNNING	mods/behaviour_tree_status.hpp	/^		RUNNING,$/;"	e	enum:mods::behaviour_tree_status
Read_Invalid_List	ban.cpp	/^void Read_Invalid_List(void) {$/;"	f
Read_Invalid_List	mods/hell.hpp	/^	constexpr inline bool Read_Invalid_List = false;$/;"	m	namespace:mods::hell
ResultBuilder	mods/catch.hpp	/^	class ResultBuilder : public DecomposedExpression {$/;"	c	namespace:Catch
ResultDisposition	mods/catch.hpp	/^	struct ResultDisposition {$/;"	s	namespace:Catch
ResultWas	mods/catch.hpp	/^	struct ResultWas {$/;"	s	namespace:Catch
SANA	utils.h	435;"	d
SANCTUARY	mods/flags.hpp	/^		SANCTUARY,$/;"	e	enum:mods::flags::aff
SASG12	mods/weapon.hpp	/^			SASG12 = 2$/;"	e	enum:mods::weapon::sentinel::primary_choice_t
SAVING_BREATH	spells.h	195;"	d
SAVING_PARA	spells.h	192;"	d
SAVING_PETRI	spells.h	194;"	d
SAVING_ROD	spells.h	193;"	d
SAVING_SPELL	spells.h	196;"	d
SB	telnet.h	47;"	d
SCAN	mods/weapon-types.hpp	/^		SCAN,$/;"	e	enum:mods::weapon::capabilities::cap_t
SCANNED	mods/affects.hpp	/^		SCANNED = 4,$/;"	e	enum:mods::affects::affect_t
SCANNED	structs.h	/^			SCANNED,$/;"	m	struct:room_data	typeref:enum:room_data::
SCANNED_AFFECT_DURATION	mods/sensor-grenade.cpp	/^	static constexpr uint64_t SCANNED_AFFECT_DURATION = 400; \/** in ticks *\/$/;"	m	namespace:mods::sensor_grenade	file:
SCENARIO	mods/catch.hpp	12208;"	d
SCENARIO_METHOD	mods/catch.hpp	12209;"	d
SCMD_ASK	interpreter.h	135;"	d
SCMD_AUCTION	interpreter.h	141;"	d
SCMD_AUTOEXIT	interpreter.h	120;"	d
SCMD_AUTOMAP	interpreter.h	122;"	d
SCMD_BRIEF	interpreter.h	107;"	d
SCMD_BUG	interpreter.h	167;"	d
SCMD_CLEAR	interpreter.h	101;"	d
SCMD_CLOSE	interpreter.h	208;"	d
SCMD_COMMANDS	interpreter.h	157;"	d
SCMD_COMPACT	interpreter.h	108;"	d
SCMD_CREDITS	interpreter.h	93;"	d
SCMD_DATE	interpreter.h	153;"	d
SCMD_DEAF	interpreter.h	111;"	d
SCMD_DONATE	interpreter.h	164;"	d
SCMD_DOWN	interpreter.h	88;"	d
SCMD_DRINK	interpreter.h	194;"	d
SCMD_DROP	interpreter.h	162;"	d
SCMD_EAST	interpreter.h	84;"	d
SCMD_EAT	interpreter.h	192;"	d
SCMD_ECHO	interpreter.h	203;"	d
SCMD_EMOTE	interpreter.h	204;"	d
SCMD_FILL	interpreter.h	181;"	d
SCMD_FREEZE	interpreter.h	129;"	d
SCMD_GOSSIP	interpreter.h	140;"	d
SCMD_GRATZ	interpreter.h	142;"	d
SCMD_HANDBOOK	interpreter.h	92;"	d
SCMD_HIT	interpreter.h	188;"	d
SCMD_HOLLER	interpreter.h	138;"	d
SCMD_HOLYLIGHT	interpreter.h	118;"	d
SCMD_IDEA	interpreter.h	169;"	d
SCMD_IMMLIST	interpreter.h	98;"	d
SCMD_IMOTD	interpreter.h	100;"	d
SCMD_INFO	interpreter.h	91;"	d
SCMD_JUNK	interpreter.h	163;"	d
SCMD_LOCK	interpreter.h	210;"	d
SCMD_LOOK	interpreter.h	172;"	d
SCMD_MOTD	interpreter.h	99;"	d
SCMD_MURDER	interpreter.h	189;"	d
SCMD_NEWS	interpreter.h	94;"	d
SCMD_NOAUCTION	interpreter.h	110;"	d
SCMD_NOGOSSIP	interpreter.h	112;"	d
SCMD_NOGRATZ	interpreter.h	113;"	d
SCMD_NOHASSLE	interpreter.h	106;"	d
SCMD_NOREPEAT	interpreter.h	117;"	d
SCMD_NORTH	interpreter.h	83;"	d
SCMD_NOSUMMON	interpreter.h	105;"	d
SCMD_NOTELL	interpreter.h	109;"	d
SCMD_NOTITLE	interpreter.h	127;"	d
SCMD_NOWIZ	interpreter.h	114;"	d
SCMD_OPEN	interpreter.h	207;"	d
SCMD_PARDON	interpreter.h	126;"	d
SCMD_PICK	interpreter.h	211;"	d
SCMD_POLICIES	interpreter.h	96;"	d
SCMD_POOFIN	interpreter.h	184;"	d
SCMD_POOFOUT	interpreter.h	185;"	d
SCMD_POUR	interpreter.h	180;"	d
SCMD_QECHO	interpreter.h	177;"	d
SCMD_QSAY	interpreter.h	176;"	d
SCMD_QUAFF	interpreter.h	199;"	d
SCMD_QUEST	interpreter.h	115;"	d
SCMD_QUI	interpreter.h	149;"	d
SCMD_QUIT	interpreter.h	150;"	d
SCMD_READ	interpreter.h	173;"	d
SCMD_RECITE	interpreter.h	200;"	d
SCMD_REROLL	interpreter.h	125;"	d
SCMD_ROOMFLAGS	interpreter.h	116;"	d
SCMD_SHOUT	interpreter.h	139;"	d
SCMD_SHUTDOW	interpreter.h	145;"	d
SCMD_SHUTDOWN	interpreter.h	146;"	d
SCMD_SIP	interpreter.h	195;"	d
SCMD_SLOWNS	interpreter.h	119;"	d
SCMD_SOCIALS	interpreter.h	158;"	d
SCMD_SOUTH	interpreter.h	85;"	d
SCMD_SQUELCH	interpreter.h	128;"	d
SCMD_TASTE	interpreter.h	193;"	d
SCMD_THAW	interpreter.h	130;"	d
SCMD_TRACK	interpreter.h	121;"	d
SCMD_TYPO	interpreter.h	168;"	d
SCMD_UNAFFECT	interpreter.h	131;"	d
SCMD_UNLOCK	interpreter.h	209;"	d
SCMD_UP	interpreter.h	87;"	d
SCMD_UPTIME	interpreter.h	154;"	d
SCMD_USE	interpreter.h	198;"	d
SCMD_VERSION	interpreter.h	97;"	d
SCMD_WEST	interpreter.h	86;"	d
SCMD_WHISPER	interpreter.h	134;"	d
SCMD_WHOAMI	interpreter.h	102;"	d
SCMD_WIZHELP	interpreter.h	159;"	d
SCMD_WIZLIST	interpreter.h	95;"	d
SCOPE	mods/weapon.hpp	/^		SCOPE,$/;"	e	enum:mods::weapon::attachment_t
SE	telnet.h	57;"	d
SECS_PER_MUD_DAY	utils.h	138;"	d
SECS_PER_MUD_HOUR	utils.h	137;"	d
SECS_PER_MUD_MONTH	utils.h	139;"	d
SECS_PER_MUD_YEAR	utils.h	140;"	d
SECS_PER_REAL_DAY	utils.h	145;"	d
SECS_PER_REAL_HOUR	utils.h	144;"	d
SECS_PER_REAL_MIN	utils.h	143;"	d
SECS_PER_REAL_YEAR	utils.h	146;"	d
SECT	utils.h	257;"	d
SECT_CITY	structs.h	191;"	d
SECT_FIELD	structs.h	192;"	d
SECT_FLYING	structs.h	198;"	d
SECT_FOREST	structs.h	193;"	d
SECT_HILLS	structs.h	194;"	d
SECT_INSIDE	structs.h	190;"	d
SECT_MOUNTAIN	structs.h	195;"	d
SECT_UNDERWATER	structs.h	199;"	d
SECT_WATER_NOSWIM	structs.h	197;"	d
SECT_WATER_SWIM	structs.h	196;"	d
SEEK_CUR	utils.h	536;"	d
SEEK_END	utils.h	537;"	d
SEEK_SET	utils.h	535;"	d
SELECTOR	mods/behaviour_tree_node.hpp	/^		enum node_type_t { DO_NOTHING, SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
SELF	utils.h	452;"	d
SENDOK	comm.cpp	2464;"	d	file:
SENSE_LIFE	mods/flags.hpp	/^		SENSE_LIFE,$/;"	e	enum:mods::flags::aff
SENSE_MOTION	mods/weapon-types.hpp	/^		SENSE_MOTION,$/;"	e	enum:mods::weapon::capabilities::cap_t
SENSOR	mods/aoe.hpp	/^		SENSOR, \/** senses objects or enemies within blast_radius *\/$/;"	e	enum:mods::aoe::types_t
SENTINEL	mods/object.hpp	/^				SENTINEL,$/;"	e	enum:mods::object::object_type_enum_t
SENTINEL_DISCIPLINE	mods/skills.hpp	/^			SENTINEL_DISCIPLINE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
SENTINEL_NONE	mods/weapon.hpp	/^			SENTINEL_NONE = 0,$/;"	e	enum:mods::weapon::sentinel::primary_choice_t
SENTINEL_PRIMARY_MP5	mods/weapon.hpp	/^			SENTINEL_PRIMARY_MP5 = 1,$/;"	e	enum:mods::weapon::sentinel::primary_choice_t
SENTINEL_PRIMARY_SASG12	mods/weapon.hpp	/^			SENTINEL_PRIMARY_SASG12 = 2,$/;"	e	enum:mods::weapon::sentinel::primary_choice_t
SEN_STR	mods/weapon.hpp	340;"	d
SEQUENCE	mods/behaviour_tree_node.hpp	/^		enum node_type_t { DO_NOTHING, SELECTOR, SEQUENCE, LEAF };$/;"	e	enum:mods::behaviour_tree_node::node_type_t
SERVER_ROOM	structs.h	/^			SERVER_ROOM,$/;"	m	struct:room_data	typeref:enum:room_data::
SET_BIT	utils.h	201;"	d
SET_OR_REMOVE	act.wizard.cpp	2354;"	d	file:
SET_SKILL	utils.h	345;"	d
SEWER	structs.h	/^			SEWER,			\/** Underground sewer tunnel *\/$/;"	m	struct:room_data	typeref:enum:room_data::
SEX_FEMALE	structs.h	245;"	d
SEX_MALE	structs.h	244;"	d
SEX_NEUTRAL	structs.h	243;"	d
SHATTERED_GLASS	structs.h	/^			SHATTERED_GLASS, \/** results of breaking glass objects *\/$/;"	m	struct:room_data	typeref:enum:room_data::
SHOCK	mods/object.hpp	/^				SHOCK,$/;"	e	enum:mods::object::object_type_enum_t
SHOOT	mods/weapon-types.hpp	/^		SHOOT,$/;"	e	enum:mods::weapon::capabilities::cap_t
SHOP_BANK	shop.h	144;"	d
SHOP_BITVECTOR	shop.h	146;"	d
SHOP_BROKE_TEMPER	shop.h	145;"	d
SHOP_BUYPROFIT	shop.h	149;"	d
SHOP_BUYTYPE	shop.h	141;"	d
SHOP_BUYWORD	shop.h	142;"	d
SHOP_CLOSE1	shop.h	137;"	d
SHOP_CLOSE2	shop.h	139;"	d
SHOP_FUNC	shop.h	151;"	d
SHOP_KEEPER	shop.h	135;"	d
SHOP_KILL_CHARS	shop.h	166;"	d
SHOP_NUM	shop.h	134;"	d
SHOP_OPEN1	shop.h	136;"	d
SHOP_OPEN2	shop.h	138;"	d
SHOP_PRODUCT	shop.h	143;"	d
SHOP_ROOM	shop.h	140;"	d
SHOP_SELLPROFIT	shop.h	150;"	d
SHOP_SORT	shop.h	148;"	d
SHOP_TRADE_WITH	shop.h	147;"	d
SHOP_USES_BANK	shop.h	167;"	d
SHORT_RANGE	mods/object.hpp	/^				SHORT_RANGE,$/;"	e	enum:mods::object::object_type_enum_t
SHOTGUN	mods/object.hpp	/^				SHOTGUN,$/;"	e	enum:mods::object::object_type_enum_t
SHOTGUN	mods/weapon.hpp	/^	enum mask_type { SMG = 1, SNIPE = (1 << 2), SHOTGUN = (1 << 3), $/;"	e	enum:mods::weapon::mask_type
SHOULDER	mods/object.hpp	/^				SHOULDER,$/;"	e	enum:mods::object::object_type_enum_t
SHOW_OBJ_ACTION	act.informative.cpp	112;"	d	file:
SHOW_OBJ_LONG	act.informative.cpp	110;"	d	file:
SHOW_OBJ_SHORT	act.informative.cpp	111;"	d	file:
SHP_PREFIX	db.h	72;"	d
SHRAPNEL	mods/aoe.hpp	/^		SHRAPNEL,	\/** metal fragments flown in random directions *\/$/;"	e	enum:mods::aoe::types_t
SIDERAIL	mods/weapon.hpp	/^		SIDERAIL$/;"	e	enum:mods::weapon::attachment_t
SIGALRM	comm.cpp	34;"	d	file:
SIGPIPE	comm.cpp	33;"	d	file:
SINFO	spell_parser.cpp	25;"	d	file:
SITEOK	mods/flags.hpp	/^		SITEOK,$/;"	e	enum:mods::flags::plr
SIZE	mods/player.hpp	/^			SIZE = HOLD_ANYTHING$/;"	e	enum:mods::player::misc_pref_enum_t
SKILL	class.cpp	371;"	d	file:
SKILL_BACKSTAB	spells.h	96;"	d
SKILL_BASH	spells.h	97;"	d
SKILL_HIDE	spells.h	98;"	d
SKILL_KICK	spells.h	99;"	d
SKILL_PICK_LOCK	spells.h	100;"	d
SKILL_RESCUE	spells.h	102;"	d
SKILL_SNEAK	spells.h	103;"	d
SKILL_STEAL	spells.h	104;"	d
SKILL_TRACK	spells.h	105;"	d
SKY_CLOUDLESS	structs.h	593;"	d
SKY_CLOUDY	structs.h	594;"	d
SKY_LIGHTNING	structs.h	596;"	d
SKY_RAINING	structs.h	595;"	d
SLASH	db.h	31;"	d
SLASH	db.h	42;"	d
SLC_ABORT	telnet.h	187;"	d
SLC_ACK	telnet.h	231;"	d
SLC_AO	telnet.h	184;"	d
SLC_AYT	telnet.h	185;"	d
SLC_BRK	telnet.h	182;"	d
SLC_CANTCHANGE	telnet.h	222;"	d
SLC_DEFAULT	telnet.h	224;"	d
SLC_EC	telnet.h	190;"	d
SLC_EL	telnet.h	191;"	d
SLC_EOF	telnet.h	188;"	d
SLC_EOR	telnet.h	186;"	d
SLC_EW	telnet.h	192;"	d
SLC_FLAGS	telnet.h	228;"	d
SLC_FLUSHIN	telnet.h	232;"	d
SLC_FLUSHOUT	telnet.h	233;"	d
SLC_FORW1	telnet.h	197;"	d
SLC_FORW2	telnet.h	198;"	d
SLC_FUNC	telnet.h	227;"	d
SLC_IP	telnet.h	183;"	d
SLC_LEVELBITS	telnet.h	225;"	d
SLC_LNEXT	telnet.h	194;"	d
SLC_NAME	telnet.h	219;"	d
SLC_NAMELIST	telnet.h	206;"	d
SLC_NAMES	telnet.h	215;"	d
SLC_NAME_OK	telnet.h	218;"	d
SLC_NOSUPPORT	telnet.h	221;"	d
SLC_RP	telnet.h	193;"	d
SLC_SUSP	telnet.h	189;"	d
SLC_SYNCH	telnet.h	181;"	d
SLC_VALUE	telnet.h	229;"	d
SLC_VARIABLE	telnet.h	223;"	d
SLC_XOFF	telnet.h	196;"	d
SLC_XON	telnet.h	195;"	d
SLEDGEHAMMER	mods/object.hpp	/^				SLEDGEHAMMER,$/;"	e	enum:mods::object::object_type_enum_t
SLEEP	mods/flags.hpp	/^		SLEEP,$/;"	e	enum:mods::flags::aff
SMALL_BUFSIZE	structs.h	668;"	d
SMG	mods/weapon.hpp	/^	enum mask_type { SMG = 1, SNIPE = (1 << 2), SHOTGUN = (1 << 3), $/;"	e	enum:mods::weapon::mask_type
SMOKE_SCREEN	mods/aoe.hpp	/^		SMOKE_SCREEN,	\/** Typical grey smoke screen. Hampers vision *\/$/;"	e	enum:mods::aoe::types_t
SMOKING	structs.h	/^			SMOKING = 4,$/;"	e	enum:uint8_t
SMOLDERING	structs.h	/^			SMOLDERING = 3,$/;"	e	enum:uint8_t
SNEAK	mods/flags.hpp	/^		SNEAK,$/;"	e	enum:mods::flags::aff
SNIPE	mods/weapon-types.hpp	/^		SNIPE,$/;"	e	enum:mods::weapon::capabilities::cap_t
SNIPE	mods/weapon.hpp	/^	enum mask_type { SMG = 1, SNIPE = (1 << 2), SHOTGUN = (1 << 3), $/;"	e	enum:mods::weapon::mask_type
SNIPER_RIFLE	mods/object.hpp	/^				SNIPER_RIFLE,$/;"	e	enum:mods::object::object_type_enum_t
SNIPER_SUPPORT	mods/skills.hpp	/^			SNIPER_SUPPORT,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
SNIPING	mods/skills.hpp	/^		SNIPING,$/;"	e	enum:mods::skills::fields_of_study
SOCMESS_FILE	db.h	92;"	d
SONIC_WAVE	mods/aoe.hpp	/^		SONIC_WAVE,	\/** The same type of explosion caused by breaking the sound barrier *\/$/;"	e	enum:mods::aoe::types_t
SOUTH	structs.h	150;"	d
SPECIAL	boards.cpp	/^SPECIAL(gen_board) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(CastleGuard) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(DicknDavid) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(James) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(cleaning) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(jerry) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(king_welmar) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(peter) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(tim) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(tom) {$/;"	f
SPECIAL	castle.cpp	/^SPECIAL(training_master) {$/;"	f
SPECIAL	mail.cpp	/^SPECIAL(postmaster) {$/;"	f
SPECIAL	objsave.cpp	/^SPECIAL(cryogenicist) {$/;"	f
SPECIAL	objsave.cpp	/^SPECIAL(receptionist) {$/;"	f
SPECIAL	shop.cpp	/^SPECIAL(shop_keeper) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(bank) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(cityguard) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(dump) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(fido) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(guild) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(guild_guard) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(janitor) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(magic_user) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(mayor) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(pet_shops) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(puff) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(snake) {$/;"	f
SPECIAL	spec_procs.cpp	/^SPECIAL(thief) {$/;"	f
SPECIAL	structs.h	140;"	d
SPELL	class.cpp	370;"	d	file:
SPELL_ACID_BREATH	spells.h	121;"	d
SPELL_ANIMATE_DEAD	spells.h	85;"	d
SPELL_ARMOR	spells.h	41;"	d
SPELL_BLESS	spells.h	43;"	d
SPELL_BLINDNESS	spells.h	44;"	d
SPELL_BURNING_HANDS	spells.h	45;"	d
SPELL_CALL_LIGHTNING	spells.h	46;"	d
SPELL_CHARM	spells.h	47;"	d
SPELL_CHILL_TOUCH	spells.h	48;"	d
SPELL_CLONE	spells.h	49;"	d
SPELL_COLOR_SPRAY	spells.h	50;"	d
SPELL_CONTROL_WEATHER	spells.h	51;"	d
SPELL_CREATE_FOOD	spells.h	52;"	d
SPELL_CREATE_WATER	spells.h	53;"	d
SPELL_CURE_BLIND	spells.h	54;"	d
SPELL_CURE_CRITIC	spells.h	55;"	d
SPELL_CURE_LIGHT	spells.h	56;"	d
SPELL_CURSE	spells.h	57;"	d
SPELL_DETECT_ALIGN	spells.h	58;"	d
SPELL_DETECT_INVIS	spells.h	59;"	d
SPELL_DETECT_MAGIC	spells.h	60;"	d
SPELL_DETECT_POISON	spells.h	61;"	d
SPELL_DISPEL_EVIL	spells.h	62;"	d
SPELL_DISPEL_GOOD	spells.h	86;"	d
SPELL_EARTHQUAKE	spells.h	63;"	d
SPELL_ENCHANT_WEAPON	spells.h	64;"	d
SPELL_ENERGY_DRAIN	spells.h	65;"	d
SPELL_FIREBALL	spells.h	66;"	d
SPELL_FIRE_BREATH	spells.h	118;"	d
SPELL_FROST_BREATH	spells.h	120;"	d
SPELL_GAS_BREATH	spells.h	119;"	d
SPELL_GROUP_ARMOR	spells.h	87;"	d
SPELL_GROUP_HEAL	spells.h	88;"	d
SPELL_GROUP_RECALL	spells.h	89;"	d
SPELL_HARM	spells.h	67;"	d
SPELL_HEAL	spells.h	68;"	d
SPELL_IDENTIFY	spells.h	117;"	d
SPELL_INFRAVISION	spells.h	90;"	d
SPELL_INTIMIDATED	spells.h	91;"	d
SPELL_INVISIBLE	spells.h	69;"	d
SPELL_LIGHTNING_BOLT	spells.h	70;"	d
SPELL_LIGHTNING_BREATH	spells.h	122;"	d
SPELL_LOCATE_OBJECT	spells.h	71;"	d
SPELL_MAGIC_MISSILE	spells.h	72;"	d
SPELL_POISON	spells.h	73;"	d
SPELL_PROT_FROM_EVIL	spells.h	74;"	d
SPELL_REMOVE_CURSE	spells.h	75;"	d
SPELL_REMOVE_POISON	spells.h	83;"	d
SPELL_RESERVED_DBC	spells.h	37;"	d
SPELL_ROUTINES	utils.h	225;"	d
SPELL_SANCTUARY	spells.h	76;"	d
SPELL_SENSE_LIFE	spells.h	84;"	d
SPELL_SHOCKING_GRASP	spells.h	77;"	d
SPELL_SLEEP	spells.h	78;"	d
SPELL_STRENGTH	spells.h	79;"	d
SPELL_SUMMON	spells.h	80;"	d
SPELL_TELEPORT	spells.h	42;"	d
SPELL_TYPE_POTION	spells.h	241;"	d
SPELL_TYPE_SCROLL	spells.h	244;"	d
SPELL_TYPE_SPELL	spells.h	240;"	d
SPELL_TYPE_STAFF	spells.h	243;"	d
SPELL_TYPE_WAND	spells.h	242;"	d
SPELL_VENTRILOQUATE	spells.h	81;"	d
SPELL_WORD_OF_RECALL	spells.h	82;"	d
SPLSKL	spec_procs.cpp	135;"	d	file:
SPRAY_BULLETS	mods/weapon-types.hpp	/^		SPRAY_BULLETS,$/;"	e	enum:mods::weapon::capabilities::cap_t
SPRAY_CHANCE	mods/skills.hpp	/^			SPRAY_CHANCE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
STAMP_PRICE	mail.h	23;"	d
START_MESSG	config.cpp	/^const char *START_MESSG =$/;"	v
START_ROOM_TABLE	mods/world-configuration.hpp	/^	constexpr const char* START_ROOM_TABLE = "world_configuration_start_rooms";$/;"	m	namespace:mods::world_conf
STATE	utils.cpp	/^int& STATE(mods::descriptor_data &d){	$/;"	f
STATE	utils.cpp	/^int& STATE(std::deque<mods::descriptor_data>::iterator d){ $/;"	f
STATE	utils.cpp	/^int& STATE(std::shared_ptr<mods::descriptor_data> d){	$/;"	f
STATUS_BREACHING	mods/object-utils.hpp	/^	constexpr static bitvector_t STATUS_BREACHING = (1 << 1);$/;"	m	namespace:mods::object_utils
STATUS_INSTALLING	mods/object-utils.hpp	/^	constexpr static bitvector_t STATUS_INSTALLING = (1 << 0);$/;"	m	namespace:mods::object_utils
STATUS_INSTALLING	mods/player-utils.hpp	/^	constexpr static bitvector_t STATUS_INSTALLING = (1 << 0);$/;"	m	namespace:mods::player_utils
STDC_HEADERS	conf.h	26;"	d
STDERR_FILENO	sysdep.h	416;"	d
STDOUT_FILENO	sysdep.h	421;"	d
STEROID_DEALER	mods/skills.hpp	/^			STEROID_DEALER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
STITCH_CLARA_CLOSE_NAMESPACE	mods/catch.hpp	4241;"	d
STITCH_CLARA_CLOSE_NAMESPACE	mods/catch.hpp	5424;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	4230;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	4240;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	5423;"	d
STITCH_CLARA_OPEN_NAMESPACE	mods/catch.hpp	5427;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	mods/catch.hpp	4246;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	mods/catch.hpp	4434;"	d
STRATEGY	mods/skills.hpp	/^		STRATEGY$/;"	e	enum:mods::skills::fields_of_study
STRENGTH_APPLY_INDEX	utils.h	357;"	d
STRONGER_FRAG_ARM	mods/skills.hpp	/^			STRONGER_FRAG_ARM,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
SUB_MACHINE_GUN	mods/object.hpp	/^				SUB_MACHINE_GUN,$/;"	e	enum:mods::object::object_type_enum_t
SUCCESS	mods/behaviour_tree_status.hpp	/^		SUCCESS,$/;"	e	enum:mods::behaviour_tree_status
SUF_ALIAS	db.h	49;"	d
SUF_OBJS	db.h	47;"	d
SUF_TEXT	db.h	48;"	d
SUMMON_FAIL	spells.cpp	107;"	d	file:
SUN_DARK	structs.h	586;"	d
SUN_LIGHT	structs.h	588;"	d
SUN_RISE	structs.h	587;"	d
SUN_SET	structs.h	589;"	d
SUPPRESSOR	mods/weapon.hpp	/^		FLASH_HIDER, SUPPRESSOR$/;"	e	enum:mods::weapon::barrel_t
SUSP	telnet.h	60;"	d
SUSPICIOUS	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
SUSPICIOUS2	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
SUTURE	mods/skills.hpp	/^			SUTURE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
SYNCH	telnet.h	63;"	d
S_DATA	shop.h	121;"	d
S_LEN	shop.h	122;"	d
SafeBool	mods/catch.hpp	/^	class SafeBool {$/;"	c	namespace:Catch
SharedImpl	mods/catch.hpp	/^		SharedImpl() : m_rc(0) {}$/;"	f	struct:Catch::SharedImpl
SharedImpl	mods/catch.hpp	/^	struct SharedImpl : T {$/;"	s	namespace:Catch
SourceLineInfo	mods/catch.hpp	/^	struct SourceLineInfo {$/;"	s	namespace:Catch
StreamEndStop	mods/catch.hpp	/^	struct StreamEndStop {$/;"	s	namespace:Catch
StringMaker	mods/catch.hpp	/^	struct StringMaker :$/;"	s	namespace:Catch
StringMaker	mods/catch.hpp	/^	struct StringMaker<R C::*> {$/;"	s	namespace:Catch
StringMaker	mods/catch.hpp	/^	struct StringMaker<T*> {$/;"	s	namespace:Catch
StringMakerBase	mods/catch.hpp	/^		struct StringMakerBase {$/;"	s	namespace:Catch::Detail
StringMakerBase	mods/catch.hpp	/^		struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
SuppressFail	mods/catch.hpp	/^			SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
TARGET_LIMB	mods/skills.hpp	/^			TARGET_LIMB,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
TARGET_PLAYER_INDEX	mods/player-scaffolding.hpp	/^		constexpr static std::size_t TARGET_PLAYER_INDEX = 1;$/;"	m	struct:mods::player_scaffolding
TAR_CHAR_ROOM	spells.h	200;"	d
TAR_CHAR_WORLD	spells.h	201;"	d
TAR_FIGHT_SELF	spells.h	202;"	d
TAR_FIGHT_VICT	spells.h	203;"	d
TAR_IGNORE	spells.h	199;"	d
TAR_NOT_SELF	spells.h	205;"	d
TAR_OBJ_EQUIP	spells.h	209;"	d
TAR_OBJ_INV	spells.h	206;"	d
TAR_OBJ_ROOM	spells.h	207;"	d
TAR_OBJ_WORLD	spells.h	208;"	d
TAR_SELF_ONLY	spells.h	204;"	d
TBC_TEXT_FORMAT_CONSOLE_WIDTH	mods/catch.hpp	5661;"	d
TBC_TEXT_FORMAT_H_INCLUDED	mods/catch.hpp	4253;"	d
TELCMD	telnet.h	79;"	d
TELCMD_FIRST	telnet.h	75;"	d
TELCMD_LAST	telnet.h	76;"	d
TELCMD_OK	telnet.h	77;"	d
TELOPT	telnet.h	143;"	d
TELOPT_3270REGIME	telnet.h	111;"	d
TELOPT_AUTHENTICATION	telnet.h	119;"	d
TELOPT_BINARY	telnet.h	82;"	d
TELOPT_BM	telnet.h	101;"	d
TELOPT_DET	telnet.h	102;"	d
TELOPT_ECHO	telnet.h	83;"	d
TELOPT_ENCRYPT	telnet.h	120;"	d
TELOPT_EOR	telnet.h	107;"	d
TELOPT_EXOPL	telnet.h	122;"	d
TELOPT_FIRST	telnet.h	140;"	d
TELOPT_LAST	telnet.h	141;"	d
TELOPT_LFLOW	telnet.h	115;"	d
TELOPT_LINEMODE	telnet.h	116;"	d
TELOPT_LOGOUT	telnet.h	100;"	d
TELOPT_NAMS	telnet.h	86;"	d
TELOPT_NAOCRD	telnet.h	92;"	d
TELOPT_NAOFFD	telnet.h	95;"	d
TELOPT_NAOHTD	telnet.h	94;"	d
TELOPT_NAOHTS	telnet.h	93;"	d
TELOPT_NAOL	telnet.h	90;"	d
TELOPT_NAOLFD	telnet.h	98;"	d
TELOPT_NAOP	telnet.h	91;"	d
TELOPT_NAOVTD	telnet.h	97;"	d
TELOPT_NAOVTS	telnet.h	96;"	d
TELOPT_NAWS	telnet.h	113;"	d
TELOPT_NEW_ENVIRON	telnet.h	121;"	d
TELOPT_OK	telnet.h	142;"	d
TELOPT_OLD_ENVIRON	telnet.h	118;"	d
TELOPT_OUTMRK	telnet.h	109;"	d
TELOPT_RCP	telnet.h	84;"	d
TELOPT_RCTE	telnet.h	89;"	d
TELOPT_SGA	telnet.h	85;"	d
TELOPT_SNDLOC	telnet.h	105;"	d
TELOPT_STATUS	telnet.h	87;"	d
TELOPT_SUPDUP	telnet.h	103;"	d
TELOPT_SUPDUPOUTPUT	telnet.h	104;"	d
TELOPT_TM	telnet.h	88;"	d
TELOPT_TSPEED	telnet.h	114;"	d
TELOPT_TTYLOC	telnet.h	110;"	d
TELOPT_TTYPE	telnet.h	106;"	d
TELOPT_TUID	telnet.h	108;"	d
TELOPT_X3PAD	telnet.h	112;"	d
TELOPT_XASCII	telnet.h	99;"	d
TELOPT_XDISPLOC	telnet.h	117;"	d
TELQUAL_INFO	telnet.h	149;"	d
TELQUAL_IS	telnet.h	147;"	d
TELQUAL_NAME	telnet.h	151;"	d
TELQUAL_REPLY	telnet.h	150;"	d
TELQUAL_SEND	telnet.h	148;"	d
THEN	mods/catch.hpp	12217;"	d
THERMAL	mods/weapon.hpp	/^		THERMAL$/;"	e	enum:mods::weapon::scope_t
THERMAL_AGITATOR	mods/aoe.hpp	/^		THERMAL_AGITATOR,	\/** Causes visual noise to thermal devices rendering them of no use *\/$/;"	e	enum:mods::aoe::types_t
THERMAL_GOGGLES	structs.h	/^	THERMAL_GOGGLES,$/;"	e	enum:lense_type_t
THERMAL_VISION	mods/flags.hpp	/^		THERMAL_VISION,$/;"	e	enum:mods::flags::aff
THERMAL_VISION	mods/weapon-types.hpp	/^		THERMAL_VISION,$/;"	e	enum:mods::weapon::capabilities::cap_t
THERMITE_BREACH_TICKS_DURATION	mods/object-utils.hpp	/^	constexpr static uint8_t THERMITE_BREACH_TICKS_DURATION = 35;$/;"	m	namespace:mods::object_utils
THIEF	mods/flags.hpp	/^		THIEF,$/;"	e	enum:mods::flags::plr
THIEF	mods/skills.hpp	/^			THIEF,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
THIRD_QUARTER	mods/date-time.hpp	/^		THIRD_QUARTER,$/;"	e	enum:mods::date_time::moon_phase
THIRST	structs.h	582;"	d
THROW	mods/item.hpp	/^		THROW = (1 << 2),$/;"	e	enum:mods::item::capability_t
THROW	mods/weapon-types.hpp	/^		THROW,$/;"	e	enum:mods::weapon::capabilities::cap_t
TICK_RESOLUTION	mods/deferred.hpp	/^			constexpr static uint64_t TICK_RESOLUTION = 3;$/;"	m	class:mods::deferred
TIME_FILE	db.h	99;"	d
TIME_LOG_FILE_NAME	mods/date-time.cpp	/^	constexpr const char* TIME_LOG_FILE_NAME = "\/tmp\/cm++-time.log";$/;"	m	namespace:mods::date_time	file:
TIME_WITH_SYS_TIME	conf.h	29;"	d
TITAN_COMBAT	mods/object.hpp	/^				TITAN_COMBAT,$/;"	e	enum:mods::object::object_type_enum_t
TOGGLE_BIT	utils.h	203;"	d
TOGGLE_LOCK	act.movement.cpp	351;"	d	file:
TOGGLE_NIGHT_VISION	mods/skills.hpp	/^			TOGGLE_NIGHT_VISION,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
TOGGLE_THERMAL	mods/skills.hpp	/^			TOGGLE_THERMAL,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
TOG_OFF	act.other.cpp	914;"	d	file:
TOG_ON	act.other.cpp	915;"	d	file:
TOP_SPELL_DEFINE	spells.h	124;"	d
TOROOM	graph.cpp	56;"	d	file:
TOROOM	house.h	30;"	d
TOSTR	utils.cpp	/^std::string TOSTR(int a){$/;"	f
TOSTR	utils.cpp	/^std::string TOSTR(nullptr_t a){ return ""; }$/;"	f
TOSTR	utils.cpp	/^std::string TOSTR(std::string a){$/;"	f
TO_CHAR	comm.h	67;"	d
TO_NOTVICT	comm.h	66;"	d
TO_OBJ_PTR	utils.h	553;"	d
TO_ROOM	comm.h	64;"	d
TO_SLEEP	comm.h	68;"	d
TO_VICT	comm.h	65;"	d
TRACER_AMMUNITION	mods/weapon.hpp	/^		TRACER_AMMUNITION,$/;"	e	enum:mods::weapon::magazine_t
TRACKER	mods/skills.hpp	/^			TRACKER,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
TRADE_NOCLERIC	shop.h	111;"	d
TRADE_NOEVIL	shop.h	108;"	d
TRADE_NOGOOD	shop.h	107;"	d
TRADE_NOMAGIC_USER	shop.h	110;"	d
TRADE_NONEUTRAL	shop.h	109;"	d
TRADE_NOTHIEF	shop.h	112;"	d
TRADE_NOWARRIOR	shop.h	113;"	d
TRAP_NONE	mods/item-types.hpp	/^		TRAP_NONE = 0,$/;"	e	enum:mods::weapon::type::trap
TREE	structs.h	/^			TREE,$/;"	m	struct:room_data	typeref:enum:room_data::
TRICK_MAGAZINE	mods/skills.hpp	/^			TRICK_MAGAZINE,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
TRIGGER_ALERT	mods/weapon-types.hpp	/^		TRIGGER_ALERT,$/;"	e	enum:mods::weapon::capabilities::cap_t
TRIGGER_EXPLOSION	mods/weapon-types.hpp	/^		TRIGGER_EXPLOSION,$/;"	e	enum:mods::weapon::capabilities::cap_t
TRUE	utils.h	530;"	d
TUNNEL	structs.h	/^			TUNNEL, \/** a tunnel made of any material *\/$/;"	m	struct:room_data	typeref:enum:room_data::
TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED	mods/catch.hpp	2812;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED	mods/catch.hpp	8518;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED	mods/catch.hpp	924;"	d
TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED	mods/catch.hpp	856;"	d
TWOBLUECUBES_CATCH_CLARA_H_INCLUDED	mods/catch.hpp	4220;"	d
TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED	mods/catch.hpp	3584;"	d
TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED	mods/catch.hpp	9056;"	d
TWOBLUECUBES_CATCH_COMMON_H_INCLUDED	mods/catch.hpp	67;"	d
TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED	mods/catch.hpp	70;"	d
TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED	mods/catch.hpp	3587;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED	mods/catch.hpp	5856;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED	mods/catch.hpp	8205;"	d
TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED	mods/catch.hpp	532;"	d
TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED	mods/catch.hpp	8005;"	d
TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED	mods/catch.hpp	9213;"	d
TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED	mods/catch.hpp	2120;"	d
TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED	mods/catch.hpp	12040;"	d
TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED	mods/catch.hpp	1291;"	d
TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED	mods/catch.hpp	7853;"	d
TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED	mods/catch.hpp	1288;"	d
TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED	mods/catch.hpp	6760;"	d
TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED	mods/catch.hpp	2529;"	d
TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED	mods/catch.hpp	8439;"	d
TWOBLUECUBES_CATCH_HPP_INCLUDED	mods/catch.hpp	14;"	d
TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED	mods/catch.hpp	3570;"	d
TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED	mods/catch.hpp	2083;"	d
TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED	mods/catch.hpp	3902;"	d
TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED	mods/catch.hpp	2709;"	d
TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED	mods/catch.hpp	535;"	d
TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED	mods/catch.hpp	2715;"	d
TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED	mods/catch.hpp	5915;"	d
TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED	mods/catch.hpp	2186;"	d
TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED	mods/catch.hpp	3132;"	d
TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED	mods/catch.hpp	696;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED	mods/catch.hpp	8872;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED	mods/catch.hpp	8875;"	d
TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED	mods/catch.hpp	5656;"	d
TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED	mods/catch.hpp	1045;"	d
TWOBLUECUBES_CATCH_MATCHERS_STRING_H_INCLUDED	mods/catch.hpp	2978;"	d
TWOBLUECUBES_CATCH_MATCHERS_VECTOR_H_INCLUDED	mods/catch.hpp	3033;"	d
TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED	mods/catch.hpp	8838;"	d
TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED	mods/catch.hpp	2027;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED	mods/catch.hpp	7984;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED	mods/catch.hpp	64;"	d
TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED	mods/catch.hpp	1543;"	d
TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED	mods/catch.hpp	3338;"	d
TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED	mods/catch.hpp	3156;"	d
TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED	mods/catch.hpp	2123;"	d
TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED	mods/catch.hpp	559;"	d
TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED	mods/catch.hpp	10648;"	d
TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED	mods/catch.hpp	7592;"	d
TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED	mods/catch.hpp	10057;"	d
TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED	mods/catch.hpp	11664;"	d
TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED	mods/catch.hpp	11154;"	d
TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED	mods/catch.hpp	10891;"	d
TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED	mods/catch.hpp	9900;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED	mods/catch.hpp	10309;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED	mods/catch.hpp	7810;"	d
TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED	mods/catch.hpp	10054;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED	mods/catch.hpp	9579;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED	mods/catch.hpp	859;"	d
TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED	mods/catch.hpp	862;"	d
TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED	mods/catch.hpp	3581;"	d
TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED	mods/catch.hpp	6371;"	d
TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED	mods/catch.hpp	9174;"	d
TWOBLUECUBES_CATCH_SECTION_H_INCLUDED	mods/catch.hpp	2367;"	d
TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED	mods/catch.hpp	2370;"	d
TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED	mods/catch.hpp	3975;"	d
TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED	mods/catch.hpp	8008;"	d
TWOBLUECUBES_CATCH_STREAM_H_INCLUDED	mods/catch.hpp	3972;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED	mods/catch.hpp	3135;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED	mods/catch.hpp	9724;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED	mods/catch.hpp	9727;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED	mods/catch.hpp	8608;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED	mods/catch.hpp	3254;"	d
TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED	mods/catch.hpp	7595;"	d
TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED	mods/catch.hpp	6374;"	d
TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED	mods/catch.hpp	693;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED	mods/catch.hpp	3598;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED	mods/catch.hpp	3590;"	d
TWOBLUECUBES_CATCH_TEXT_H_INCLUDED	mods/catch.hpp	5659;"	d
TWOBLUECUBES_CATCH_TIMER_H_INCLUDED	mods/catch.hpp	2473;"	d
TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED	mods/catch.hpp	9332;"	d
TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED	mods/catch.hpp	1533;"	d
TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED	mods/catch.hpp	2373;"	d
TWOBLUECUBES_CATCH_TYPE_TRAITS_HPP_INCLUDED	mods/catch.hpp	2198;"	d
TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED	mods/catch.hpp	8803;"	d
TWOBLUECUBES_CATCH_VERSION_H_INCLUDED	mods/catch.hpp	7331;"	d
TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED	mods/catch.hpp	3606;"	d
TWOBLUECUBES_CATCH_WINDOWS_H_PROXY_H_INCLUDED	mods/catch.hpp	6776;"	d
TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED	mods/catch.hpp	10396;"	d
TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED	mods/catch.hpp	4439;"	d
TWOBLUECUBES_CLARA_H_INCLUDED	mods/catch.hpp	4239;"	d
TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED	mods/catch.hpp	12;"	d
TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED	mods/catch.hpp	5669;"	d
TYPE_ANNIHILATE	spells.h	/^TYPE_ANNIHILATE,$/;"	e	enum:weapon_attack_types_t
TYPE_ANNIHILATE	spells.h	183;"	d
TYPE_BITE	spells.h	/^TYPE_BITE,$/;"	e	enum:weapon_attack_types_t
TYPE_BITE	spells.h	165;"	d
TYPE_BLAST	spells.h	/^TYPE_BLAST,$/;"	e	enum:weapon_attack_types_t
TYPE_BLAST	spells.h	173;"	d
TYPE_BLUDGEON	spells.h	/^TYPE_BLUDGEON,$/;"	e	enum:weapon_attack_types_t
TYPE_BLUDGEON	spells.h	166;"	d
TYPE_CLAW	spells.h	/^TYPE_CLAW,$/;"	e	enum:weapon_attack_types_t
TYPE_CLAW	spells.h	169;"	d
TYPE_COMPLETELY_DESTROY	spells.h	/^TYPE_COMPLETELY_DESTROY,$/;"	e	enum:weapon_attack_types_t
TYPE_COMPLETELY_DESTROY	spells.h	184;"	d
TYPE_CRUSH	spells.h	/^TYPE_CRUSH,$/;"	e	enum:weapon_attack_types_t
TYPE_CRUSH	spells.h	167;"	d
TYPE_DECOMPOSE	spells.h	/^TYPE_DECOMPOSE,$/;"	e	enum:weapon_attack_types_t
TYPE_DECOMPOSE	spells.h	182;"	d
TYPE_DEVOID	spells.h	/^TYPE_DEVOID$/;"	e	enum:weapon_attack_types_t
TYPE_DEVOID	spells.h	186;"	d
TYPE_GRENADE	spells.h	/^TYPE_GRENADE,$/;"	e	enum:weapon_attack_types_t
TYPE_GRENADE	spells.h	180;"	d
TYPE_HIT	spells.h	/^	TYPE_HIT = 300,$/;"	e	enum:weapon_attack_types_t
TYPE_HIT	spells.h	161;"	d
TYPE_LIGHT_MACHINE_GUN	spells.h	/^TYPE_LIGHT_MACHINE_GUN,$/;"	e	enum:weapon_attack_types_t
TYPE_LIGHT_MACHINE_GUN	spells.h	179;"	d
TYPE_MAUL	spells.h	/^TYPE_MAUL,$/;"	e	enum:weapon_attack_types_t
TYPE_MAUL	spells.h	170;"	d
TYPE_PIERCE	spells.h	/^TYPE_PIERCE,$/;"	e	enum:weapon_attack_types_t
TYPE_PIERCE	spells.h	172;"	d
TYPE_POUND	spells.h	/^TYPE_POUND,$/;"	e	enum:weapon_attack_types_t
TYPE_POUND	spells.h	168;"	d
TYPE_PUNCH	spells.h	/^TYPE_PUNCH,$/;"	e	enum:weapon_attack_types_t
TYPE_PUNCH	spells.h	174;"	d
TYPE_SHOTGUN	spells.h	/^TYPE_SHOTGUN,$/;"	e	enum:weapon_attack_types_t
TYPE_SHOTGUN	spells.h	177;"	d
TYPE_SLASH	spells.h	/^TYPE_SLASH,$/;"	e	enum:weapon_attack_types_t
TYPE_SLASH	spells.h	164;"	d
TYPE_SNIPE	spells.h	/^TYPE_SNIPE,$/;"	e	enum:weapon_attack_types_t
TYPE_SNIPE	spells.h	176;"	d
TYPE_STAB	spells.h	/^TYPE_STAB,$/;"	e	enum:weapon_attack_types_t
TYPE_STAB	spells.h	175;"	d
TYPE_STING	spells.h	/^TYPE_STING,$/;"	e	enum:weapon_attack_types_t
TYPE_STING	spells.h	162;"	d
TYPE_SUB_MACHINE_GUN	spells.h	/^TYPE_SUB_MACHINE_GUN,$/;"	e	enum:weapon_attack_types_t
TYPE_SUB_MACHINE_GUN	spells.h	178;"	d
TYPE_SUFFER	spells.h	181;"	d
TYPE_SUFFERING	spells.h	/^TYPE_SUFFERING,$/;"	e	enum:weapon_attack_types_t
TYPE_THRASH	spells.h	/^TYPE_THRASH,$/;"	e	enum:weapon_attack_types_t
TYPE_THRASH	spells.h	171;"	d
TYPE_UNDEFINED	spells.h	36;"	d
TYPE_UTTERLY_DECIMATE	spells.h	/^TYPE_UTTERLY_DECIMATE,$/;"	e	enum:weapon_attack_types_t
TYPE_UTTERLY_DECIMATE	spells.h	185;"	d
TYPE_WHIP	spells.h	/^TYPE_WHIP,$/;"	e	enum:weapon_attack_types_t
TYPE_WHIP	spells.h	163;"	d
TYPO_FILE	db.h	89;"	d
TestFailureException	mods/catch.hpp	/^	struct TestFailureException {};$/;"	s	namespace:Catch
TestFunction	mods/catch.hpp	/^	typedef void(*TestFunction)();$/;"	t	namespace:Catch
ThrewException	mods/catch.hpp	/^			ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
TrueType	mods/catch.hpp	/^		struct TrueType {$/;"	s	namespace:Catch::Detail
TupleDetail	mods/catch.hpp	/^	namespace TupleDetail {$/;"	n	namespace:Catch
UNCOMMON	mods/randomized-items.hpp	/^	UNCOMMON,$/;"	e	enum:mods::rarity_enum_t
UNCOMMON	mods/rarity.hpp	/^		constexpr static float UNCOMMON = 0.1503172;$/;"	m	namespace:mods::rarity
UNCOMMON_DROP_RATE	mods/randomized-items.hpp	/^		constexpr static float UNCOMMON_DROP_RATE = 15.0;$/;"	m	class:mods::randomized_items
UNDERWATER	structs.h	/^			UNDERWATER,$/;"	m	struct:room_data	typeref:enum:room_data::
UNKNOWN_STATUS	mods/behaviour_tree_status.hpp	/^		UNKNOWN_STATUS,$/;"	e	enum:mods::behaviour_tree_status
UNLOCK_DOOR	act.movement.cpp	348;"	d	file:
UNMARK	graph.cpp	54;"	d	file:
UNSWITCH	interpreter.cpp	1628;"	d	file:
UNUSED16	mods/flags.hpp	/^		UNUSED16,				\/\/ useless$/;"	e	enum:mods::flags::aff
UNUSED17	mods/flags.hpp	/^		UNUSED17,				\/\/ useless$/;"	e	enum:mods::flags::aff
UP	structs.h	152;"	d
UPDATE	mods/lmdb.hpp	/^		EXEC, UPDATE, INSERT $/;"	e	enum:mods::lmdb::transact_type_t
UPPER	utils.h	156;"	d
USERS_FORMAT	act.informative.cpp	1619;"	d	file:
USE_AUTOEQ	structs.h	111;"	d
USURP	interpreter.cpp	1627;"	d	file:
Unknown	mods/catch.hpp	/^			Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
VALID_EDGE	graph.cpp	/^int VALID_EDGE(room_rnum x, int y) {$/;"	f
VALID_OBJ_RNUM	utils.h	397;"	d
VALID_ROOM_RNUM	utils.h	263;"	d
VANISH	act.item.cpp	477;"	d	file:
VERSION3_TAG	shop.h	84;"	d
VERTICAL_GRIP	mods/weapon.hpp	/^		VERTICAL_GRIP, ANGLED_GRIP$/;"	e	enum:mods::weapon::grip_t
VEST	mods/object.hpp	/^				VEST,$/;"	e	enum:mods::object::object_type_enum_t
VIP	mods/skills.hpp	/^			VIP,$/;"	e	enum:mods::skills::proficiencies::proficiency_name_t
VIPER_RECON	mods/object.hpp	/^				VIPER_RECON,$/;"	e	enum:mods::object::object_type_enum_t
VIRTUAL	db.h	/^	VIRTUAL\\$/;"	e	enum:__anon1
VISION	mods/flags.hpp	/^		VISION,$/;"	e	enum:mods::flags::chunk_type_t
VOLATILE	structs.h	/^			VOLATILE,		\/** Volatile means any slight spark will ignite an explosion *\/$/;"	m	struct:room_data	typeref:enum:room_data::
VULTURE_COMBAT	mods/object.hpp	/^				VULTURE_COMBAT,$/;"	e	enum:mods::object::object_type_enum_t
Valid_Name	ban.cpp	/^int Valid_Name(const char *newname) {$/;"	f
WAIT_STATE	utils.h	377;"	d
WANDER	mods/ai_state.hpp	/^				WANDER, SUSPICIOUS, FIGHT,SUSPICIOUS2,PROTECT,AGGRESSIVE_PROTECT,$/;"	e	enum:mods::ai_state::state
WANING_CRESCENT	mods/date-time.hpp	/^		WANING_CRESCENT,$/;"	e	enum:mods::date_time::moon_phase
WANING_GIBBOUS	mods/date-time.hpp	/^		WANING_GIBBOUS,$/;"	e	enum:mods::date_time::moon_phase
WATER	structs.h	/^			WATER,$/;"	m	struct:room_data	typeref:enum:room_data::
WATERWALK	mods/flags.hpp	/^		WATERWALK,			\/\/ useless$/;"	e	enum:mods::flags::aff
WAXING_CRESCENT	mods/date-time.hpp	/^		WAXING_CRESCENT,$/;"	e	enum:mods::date_time::moon_phase
WAXING_GIBBOUS	mods/date-time.hpp	/^		WAXING_GIBBOUS,$/;"	e	enum:mods::date_time::moon_phase
WC_FROZEN	mods/world-configuration.hpp	/^constexpr static int WC_FROZEN = 0;$/;"	v
WC_IDLE	mods/world-configuration.hpp	/^constexpr static int WC_IDLE = 1;$/;"	v
WC_IMM	mods/world-configuration.hpp	/^constexpr static int WC_IMM = 2;$/;"	v
WC_MOR	mods/world-configuration.hpp	/^constexpr static int WC_MOR = 3;$/;"	v
WEAPON	mods/object.hpp	/^				WEAPON,$/;"	e	enum:mods::object::object_type_enum_t
WEAPON_HANDLING	mods/skills.hpp	/^		WEAPON_HANDLING,$/;"	e	enum:mods::skills::fields_of_study
WEAPON_SET_NUM	mods/player.hpp	38;"	d
WEAR_ABOUT	structs.h	396;"	d
WEAR_ARMS	structs.h	394;"	d
WEAR_BACKPACK	structs.h	408;"	d
WEAR_BODY	structs.h	389;"	d
WEAR_ELBOW_L	structs.h	411;"	d
WEAR_ELBOW_R	structs.h	412;"	d
WEAR_FEET	structs.h	392;"	d
WEAR_FINGER_L	structs.h	386;"	d
WEAR_FINGER_R	structs.h	385;"	d
WEAR_GOGGLES	structs.h	409;"	d
WEAR_HANDS	structs.h	393;"	d
WEAR_HEAD	structs.h	390;"	d
WEAR_HOLD	structs.h	402;"	d
WEAR_LEGS	structs.h	391;"	d
WEAR_LIGHT	structs.h	384;"	d
WEAR_NECK_1	structs.h	387;"	d
WEAR_NECK_2	structs.h	388;"	d
WEAR_PRIMARY	structs.h	401;"	d
WEAR_SECONDARY	structs.h	404;"	d
WEAR_SECONDARY_WEAPON	structs.h	403;"	d
WEAR_SHIELD	structs.h	395;"	d
WEAR_SHOULDERS_L	structs.h	406;"	d
WEAR_SHOULDERS_R	structs.h	407;"	d
WEAR_VEST_PACK	structs.h	410;"	d
WEAR_WAIST	structs.h	397;"	d
WEAR_WEAPON_ATTACHMENT	structs.h	405;"	d
WEAR_WIELD	structs.h	400;"	d
WEAR_WRIST_L	structs.h	399;"	d
WEAR_WRIST_R	structs.h	398;"	d
WELC_MESSG	config.cpp	/^const char *WELC_MESSG =$/;"	v
WEST	structs.h	151;"	d
WHEN	mods/catch.hpp	12215;"	d
WHO_FORMAT	act.informative.cpp	1430;"	d	file:
WILL	telnet.h	46;"	d
WILL_BANK_MONEY	shop.h	164;"	d
WILL_START_FIGHT	shop.h	163;"	d
WIN32_LEAN_AND_MEAN	mods/catch.hpp	6782;"	d
WIN32_LEAN_AND_MEAN	mods/catch.hpp	6795;"	d
WIZLIST_FILE	db.h	82;"	d
WLD_PREFIX	db.h	68;"	d
WONT	telnet.h	45;"	d
WOODEN_WALLS	structs.h	/^			WOODEN_WALLS,$/;"	m	struct:room_data	typeref:enum:room_data::
WRITE_LVL	boards.h	38;"	d
WRITING	mods/flags.hpp	/^		WRITING,$/;"	e	enum:mods::flags::plr
Warning	mods/catch.hpp	/^			Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
XNAME_FILE	db.h	93;"	d
YES	config.cpp	20;"	d	file:
YESNO	utils.h	152;"	d
YamlFeedExceptionInfo	mods/object-utils.hpp	/^		YamlFeedExceptionInfo($/;"	f	struct:mods::object_utils::YamlFeedExceptionInfo
YamlFeedExceptionInfo	mods/object-utils.hpp	/^	struct YamlFeedExceptionInfo {$/;"	s	namespace:mods::object_utils
Yes	mods/catch.hpp	/^			Yes,$/;"	e	enum:Catch::CaseSensitive::Choice
Z	db.cpp	1842;"	d	file:
Z	db.cpp	1850;"	d	file:
ZONE_ERROR	db.cpp	2186;"	d	file:
ZON_PREFIX	db.h	71;"	d
ZOOM	mods/weapon-types.hpp	/^		ZOOM,$/;"	e	enum:mods::weapon::capabilities::cap_t
ZO_DEAD	db.cpp	2105;"	d	file:
Z_KINGS_C	castle.cpp	31;"	d	file:
_ARPA_TELNET_H	telnet.h	37;"	d
_BSD_SNPRINTF_H	bsd-snprintf.h	41;"	d
_BSD_SOURCE	mods/catch.hpp	146;"	d
_CIRCLEMUD	structs.h	101;"	d
_POSIX_C_SOURCE	sysdep.h	293;"	d
_POSIX_C_SOURCE	sysdep.h	295;"	d
__ACT_OTHER_C__	act.other.cpp	11;"	d	file:
__AFFECT_SIZE	mods/affects.hpp	/^		__AFFECT_SIZE = 5$/;"	e	enum:mods::affects::affect_t
__AFF_FIRST	mods/flags.hpp	/^		__AFF_FIRST = BLIND,$/;"	e	enum:mods::flags::aff
__AFF_LAST	mods/flags.hpp	/^		__AFF_LAST = NORMAL_SIGHT$/;"	e	enum:mods::flags::aff
__AOE_FIRST	mods/aoe.hpp	/^		__AOE_FIRST = EXPLOSIVE,$/;"	e	enum:mods::aoe::types_t
__AOE_LAST	mods/aoe.hpp	/^		__AOE_LAST = CORROSIVE$/;"	e	enum:mods::aoe::types_t
__ARMOR_BRANDS_END__	mods/object.hpp	/^				__ARMOR_BRANDS_END__,$/;"	e	enum:mods::object::object_type_enum_t
__ARMOR_BRANDS_START__	mods/object.hpp	/^				__ARMOR_BRANDS_START__,$/;"	e	enum:mods::object::object_type_enum_t
__ARMOR_POSITION_END__	mods/object.hpp	/^				__ARMOR_POSITION_END__,$/;"	e	enum:mods::object::object_type_enum_t
__ARMOR_POSITION_START__	mods/object.hpp	/^				__ARMOR_POSITION_START__,$/;"	e	enum:mods::object::object_type_enum_t
__BROAD_CATEGORY_END__	mods/object.hpp	/^				__BROAD_CATEGORY_END__,$/;"	e	enum:mods::object::object_type_enum_t
__BROAD_CATEGORY_START__	mods/object.hpp	/^				__BROAD_CATEGORY_START__,$/;"	e	enum:mods::object::object_type_enum_t
__CIRCLEMUD_SRC_MODS_GLOBALS_HEADER__	globals.hpp	2;"	d
__CIRCLEMUD_SRC_MODS_GLOBALS_SOURCE__	globals.cpp	2;"	d	file:
__CIRCLEMUD_STRUCTS_HEADER__	structs.h	12;"	d
__COMM_C__	comm.cpp	11;"	d	file:
__CONFIG_C__	config.cpp	11;"	d	file:
__DB_C__	db.cpp	11;"	d	file:
__EV_FIRST	mods/projectile.hpp	/^			__EV_FIRST = EV_TRAVEL,$/;"	e	enum:mods::projectile::projectile_event_t
__EV_LAST	mods/projectile.hpp	/^			__EV_LAST = EV_EXPOSED$/;"	e	enum:mods::projectile::projectile_event_t
__FIRST	mods/date-time.hpp	/^		__FIRST = NEW_MOON,$/;"	e	enum:mods::date_time::moon_phase
__GENERIC_QUALIFIERS_END__	mods/object.hpp	/^				__GENERIC_QUALIFIERS_END__,$/;"	e	enum:mods::object::object_type_enum_t
__GENERIC_QUALIFIERS_START__	mods/object.hpp	/^				__GENERIC_QUALIFIERS_START__,$/;"	e	enum:mods::object::object_type_enum_t
__GET_POS	mods/macro_impl.cpp	/^	byte& __GET_POS(char_data* ch){$/;"	f	namespace:mods::macro_impl
__INTERPRETER_C__	interpreter.cpp	11;"	d	file:
__INTERPRETER_C__	login.hpp	3;"	d
__INTERPRETER_HEADER__	interpreter.h	2;"	d
__LAST	mods/date-time.hpp	/^		__LAST = WANING_CRESCENT$/;"	e	enum:mods::date_time::moon_phase
__LAST	mods/doors.hpp	/^		__LAST = EIM_ELECTRIFIED << 1$/;"	e	enum:mods::doors::exit_info_masks_t
__LAST	mods/weapon-types.hpp	/^		__LAST = GRAPPLE$/;"	e	enum:mods::weapon::capabilities::cap_t
__MELEE_WEAPON_END__	mods/object.hpp	/^				__MELEE_WEAPON_END__,$/;"	e	enum:mods::object::object_type_enum_t
__MELEE_WEAPON_START__	mods/object.hpp	/^				__MELEE_WEAPON_START__,$/;"	e	enum:mods::object::object_type_enum_t
__MENTOC_ACT_DEBUG_HEADER__	act.debug.hpp	2;"	d
__MENTOC_BUILDER_UTILS_ACCEPT_ZERO_INDEX__	mods/builder.hpp	3;"	d
__MENTOC_CONFIG_HEADER__	config.hpp	2;"	d
__MENTOC_DB_HEADER__	db.h	2;"	d
__MENTOC_DEBUG__	globals.hpp	63;"	d
__MENTOC_HELL_HEADER__	mods/hell.hpp	2;"	d
__MENTOC_ITEM_CONSTANTS_DEFINED__	structs.h	453;"	d
__MENTOC_LOGIN_HEADER__	login.hpp	2;"	d
__MENTOC_MODS_ACL_LIST_HEADER__	mods/acl_list.hpp	2;"	d
__MENTOC_MODS_AFFECTS_HEADER__	mods/affects.hpp	2;"	d
__MENTOC_MODS_AFFECTS_SHOW_DEBUG_OUTPUT__	mods/affects.hpp	11;"	d
__MENTOC_MODS_AOE_HEADER__	mods/aoe.hpp	2;"	d
__MENTOC_MODS_AUTO_LOGIN_HEADER__	mods/auto-login.hpp	2;"	d
__MENTOC_MODS_BAN_SYSTEM_HEADER__	mods/ban_system.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_HEADER__	mods/behaviour_tree.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_IMPL_HEADER__	mods/behaviour_tree_impl.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_NODE_HEADER__	mods/behaviour_tree_node.hpp	2;"	d
__MENTOC_MODS_BEHAVIOUR_TREE_STATUS_HEADER__	mods/behaviour_tree_status.hpp	2;"	d
__MENTOC_MODS_BUILDER_HEADER__	mods/builder.hpp	2;"	d
__MENTOC_MODS_CALC_VISIBILITY_HEADER__	mods/calc_visibility.hpp	2;"	d
__MENTOC_MODS_CAMERA_HEADER__	mods/camera.hpp	2;"	d
__MENTOC_MODS_CAMERA_SOURCE__	mods/camera.cpp	2;"	d	file:
__MENTOC_MODS_CHARGEN_HEADER__	mods/chargen.hpp	2;"	d
__MENTOC_MODS_CHAT_HEADER__	mods/chat.hpp	2;"	d
__MENTOC_MODS_CONF_HEADER__	mods/conf.hpp	2;"	d
__MENTOC_MODS_CRYPTO_HEADER__	mods/crypto.hpp	2;"	d
__MENTOC_MODS_DATE_TIME_HEADER__	mods/date-time.hpp	2;"	d
__MENTOC_MODS_DB_LIB__	mods/db.hpp	2;"	d
__MENTOC_MODS_DEBUG_HEADER__	mods/debug.hpp	2;"	d
__MENTOC_MODS_DEBUG_PRE_GAME_HEADER__	mods/debug-pre-game.hpp	2;"	d
__MENTOC_MODS_DOORS_HEADER__	mods/doors.hpp	2;"	d
__MENTOC_MODS_DRONE_HEADER__	mods/drone.hpp	2;"	d
__MENTOC_MODS_DRONE_SOURCE__	mods/drone.cpp	2;"	d	file:
__MENTOC_MODS_EVENTS_HEADER__	mods/events.hpp	2;"	d
__MENTOC_MODS_EXTRA_DESC_DATA_HEADER__	mods/extra_desc_data.hpp	2;"	d
__MENTOC_MODS_FILESYSTEM_HEADER__	mods/filesystem.hpp	2;"	d
__MENTOC_MODS_FLAGS_HEADER__	mods/flags.hpp	2;"	d
__MENTOC_MODS_FLASHBANG_HEADER__	mods/flashbang.hpp	2;"	d
__MENTOC_MODS_HELP_HEADER__	mods/help.hpp	2;"	d
__MENTOC_MODS_IMMORTAL_HEADER__	mods/immortal.hpp	2;"	d
__MENTOC_MODS_INJURE_HEADER__	mods/injure.hpp	2;"	d
__MENTOC_MODS_ITEM_HEADER__	mods/item.hpp	2;"	d
__MENTOC_MODS_ITEM_TYPES__	mods/item-types.hpp	2;"	d
__MENTOC_MODS_JS_HEADER__	mods/js.hpp	2;"	d
__MENTOC_MODS_JS_PATH_HEADER__	mods/js-path.hpp	2;"	d
__MENTOC_MODS_JS_PLAYER_SCAFFOLDING_HEADER__	mods/js-player-scaffolding.hpp	2;"	d
__MENTOC_MODS_JX_HEADER__	mods/jx.hpp	2;"	d
__MENTOC_MODS_LMDB_HEADER__	mods/lmdb.hpp	2;"	d
__MENTOC_MODS_LOOPS_HEADER__	mods/loops.hpp	2;"	d
__MENTOC_MODS_MACRO_IMPL_HEADER__	mods/macro_impl.hpp	2;"	d
__MENTOC_MODS_META_UTILS_HEADER__	mods/meta_utils.hpp	2;"	d
__MENTOC_MODS_NPC_HEADER__	mods/npc.hpp	2;"	d
__MENTOC_MODS_OBJECT_HEADER__	mods/object.hpp	2;"	d
__MENTOC_MODS_OBJECT_SOURCE__	mods/object.cpp	2;"	d	file:
__MENTOC_MODS_OBJECT_UTILS_HEADER__	mods/object-utils.hpp	2;"	d
__MENTOC_MODS_OVERHEAD_MAP_HEADER__	mods/overhead_map.hpp	2;"	d
__MENTOC_MODS_PFIND_HEADER__	mods/pfind.hpp	2;"	d
__MENTOC_MODS_PLAYER_HEADER__	mods/player.hpp	2;"	d
__MENTOC_MODS_PLAYER_SCAFFOLDING_HEADER__	mods/player-scaffolding.hpp	2;"	d
__MENTOC_MODS_PLAYER_SOURCE__	mods/player.cpp	2;"	d	file:
__MENTOC_MODS_PLAYER_UTILS_HEADER__	mods/player-utils.hpp	2;"	d
__MENTOC_MODS_PQXX_TYPES_HEADER__	mods/pqxx-types.hpp	2;"	d
__MENTOC_MODS_PQ_HEADER__	mods/pq.hpp	2;"	d
__MENTOC_MODS_PROJECTILE_HEADER__	mods/projectile.hpp	2;"	d
__MENTOC_MODS_QUESTS_HEADER__	mods/quests.hpp	2;"	d
__MENTOC_MODS_RANDOMIZED_ITEM_DROPS_HEADER__	mods/randomized-items.hpp	2;"	d
__MENTOC_MODS_RAND_HEADER__	mods/rand.hpp	2;"	d
__MENTOC_MODS_RARITY_HEADER__	mods/rarity.hpp	2;"	d
__MENTOC_MODS_ROOMS_HEADER__	mods/rooms.hpp	2;"	d
__MENTOC_MODS_SCAN_HEADER__	mods/scan.hpp	2;"	d
__MENTOC_MODS_SCHEMA_HEADER__	mods/schema.hpp	2;"	d
__MENTOC_MODS_SENSOR_GRENADE_HEADER__	mods/sensor-grenade.hpp	2;"	d
__MENTOC_MODS_SHOP_HEADER__	mods/shop.hpp	2;"	d
__MENTOC_MODS_SKILLS_HEADER__	mods/skills.hpp	2;"	d
__MENTOC_MODS_SQL_HEADER__	mods/sql.hpp	9;"	d
__MENTOC_MODS_STRING_HEADER__	mods/string.hpp	2;"	d
__MENTOC_MODS_TESTING_INDEX_HEADER__	mods/testing_index.hpp	2;"	d
__MENTOC_MODS_VALUES_HEADER__	mods/values.hpp	2;"	d
__MENTOC_MODS_WEAPON_HEADER__	mods/weapon.hpp	2;"	d
__MENTOC_MODS_WEAPON_STAT_LIST_HEADER__	mods/weapon-stat-list.hpp	2;"	d
__MENTOC_MODS_WEAPON_TYPES_HEADER__	mods/weapon-types.hpp	2;"	d
__MENTOC_MODS_WORLD_CONFIGURATION_HEADER__	mods/world-configuration.hpp	2;"	d
__MENTOC_MODS_YAML_HEADER__	mods/yaml.hpp	2;"	d
__MENTOC_MODS_ai_state_HEADER__	mods/ai_state.hpp	2;"	d
__MENTOC_MODS_cron_HEADER__	mods/cron.hpp	2;"	d
__MENTOC_MODS_deferred_HEADER__	mods/deferred.hpp	2;"	d
__MENTOC_MODS_prefs_HEADER__	mods/prefs.hpp	2;"	d
__MENTOC_MODS_pregame_HEADER__	mods/pregame.hpp	2;"	d
__MENTOC_MUTE_BEHAVIOUR_TREE_OUTPUT__	mobact.cpp	42;"	d	file:
__MENTOC_PLR	db.cpp	2573;"	d	file:
__MENTOC_RUN_PREGAME_EXTRACT_YAML_INFO_CODE__	mods/debug-pre-game.hpp	15;"	d
__MENTOC_RUN_PREGAME_SKILL_CODE__	mods/debug-pre-game.hpp	7;"	d
__MENTOC_SHOW_DISPOSE_PLAYER_DEBUG_OUTPUT__	globals.cpp	931;"	d	file:
__MENTOC_SHOW_MODS_ROOMS_AFFECTS_DEBUG_OUTPUT__	mods/rooms.hpp	8;"	d
__MENTOC_STRING_LIT__	mods/util.hpp	21;"	d
__MENTOC_TYPES_HEADER__	types.hpp	2;"	d
__MENTOC_USE_LMDB__	mods/lmdb.cpp	10;"	d	file:
__MENTOC_UTILS_HEADER__	mods/util.hpp	2;"	d
__MENTOC_UTILS_SOURCE__	mods/util.cpp	2;"	d	file:
__MENTOC_UTIL_CONF_HEADER__	mods/util-conf.hpp	2;"	d
__MENTOC_UTIL_MAP_HEADER__	mods/util-map.hpp	2;"	d
__PLR_FIRST	mods/flags.hpp	/^		__PLR_FIRST = KILLER,$/;"	e	enum:mods::flags::plr
__PLR_LAST	mods/flags.hpp	/^		__PLR_LAST = CRYO$/;"	e	enum:mods::flags::plr
__SHOP_HEADER__	shop.h	12;"	d
__SPELL_HEADER__	spells.h	2;"	d
__STATE_GUARD__	utils.h	29;"	d
__WEAPON_END__	mods/object.hpp	/^				__WEAPON_END__,$/;"	e	enum:mods::object::object_type_enum_t
__WEAPON_START__	mods/object.hpp	/^				__WEAPON_START__,$/;"	e	enum:mods::object::object_type_enum_t
__attribute__	sysdep.h	339;"	d
__find_player_by_name	mods/js.cpp	/^			static inline bool __find_player_by_name(player_ptr_t player_ptr,find_player_payload_t* param){$/;"	f	namespace:mods::js::utils
_clrlevel	screen.h	26;"	d
_db_handle	mods/lmdb.cpp	/^	_db_handle::_db_handle(std::string directory,std::string db_name,const uint64_t & flags,const uint16_t & mode,bool unused) $/;"	f	class:mods::lmdb::_db_handle
_db_handle	mods/lmdb.hpp	/^	struct _db_handle {$/;"	s	namespace:mods::lmdb
_old_unused_vwrite_to_output_unused_	comm.cpp	/^size_t _old_unused_vwrite_to_output_unused_(mods::descriptor_data &t, const char *format, va_list args) {$/;"	f
_parse_name	interpreter.cpp	/^int _parse_name(char *arg, char *name) {$/;"	f
_s	mods/lmdb.hpp	/^	inline static std::string operator "" _s(const char* str,std::size_t size){ $/;"	f	namespace:mods::lmdb
_s	mods/util.hpp	/^static inline std::string operator "" _s(const char* s,uint64_t i) {$/;"	f
_selector	mods/lmdb.hpp	/^	struct _selector {$/;"	s	namespace:mods::lmdb
_write_one_node	ban.cpp	/^void _write_one_node(FILE *fp, struct ban_list_element *node) {$/;"	f
a	random.cpp	48;"	d	file:
abort_txn	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::abort_txn(){$/;"	f	class:mods::lmdb::_db_handle
abs_val	bsd-snprintf.cpp	155;"	d	file:
account	structs.h	/^		int	account;$/;"	m	struct:rent_info
accuracy	mods/weapon-types.hpp	/^		weapon_accuracy_t accuracy;$/;"	m	struct:mods::weapon::weapon_type_statistics_t
accuracy_map	mods/yaml.hpp	/^			std::array<float,MAX_ROOM_DISTANCE> accuracy_map;$/;"	m	struct:mods::yaml::rifle_description_t
acl_allowed	globals.cpp	/^		bool acl_allowed(char_data *ch,const char* command_name,const char* file,int cmd,const char* arg,int subcmd) {$/;"	f	namespace:mods::globals
acl_list	mods/acl_list.cpp	/^namespace mods::acl_list {$/;"	n	class:mods	file:
acl_list	mods/acl_list.hpp	/^namespace mods::acl_list {$/;"	n	class:mods
acl_list	mods/player.hpp	/^namespace mods::acl_list {$/;"	n	class:mods
act	comm.cpp	/^void act(const std::string & str, int hide_invisible, char_data *ch,$/;"	f
act_nr	act.social.cpp	/^	int act_nr;$/;"	m	struct:social_messg	file:
action_bits	constants.cpp	/^const char *action_bits[] = {$/;"	v
action_bits	constants.hpp	/^const char *action_bits[] = {$/;"	v
action_bits_count	constants.cpp	/^        action_bits_count = sizeof(action_bits) \/ sizeof(action_bits[0]) - 1,$/;"	v
action_bits_count	constants.hpp	/^	action_bits_count = sizeof(action_bits) \/ sizeof(action_bits[0]) - 1,$/;"	v
action_description	structs.h	/^		mods::string action_description;      \/* What to write when used          *\/$/;"	m	struct:obj_data
add	mods/deferred.hpp	/^		uint64_t add;$/;"	m	struct:mods::chunk_affect_t
addRef	mods/catch.hpp	/^		virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl
add_affected_by	mods/player.hpp	/^		std::vector<affected_type>& add_affected_by(affected_type&& add_this){$/;"	f	struct:mods::player
add_callback	mods/rooms.cpp	/^		void add_callback(room_rnum room, affect_t affect, callback_t f){$/;"	f	namespace:mods::rooms::affects
add_follower	utils.cpp	/^void add_follower(char_data *ch, char_data *leader) {$/;"	f
add_private_publisher	mods/chat.cpp	/^	void channel::add_private_publisher(std::string_view user) {$/;"	f	class:mods::chat::channel
add_room_dissolve_affect	mods/rooms.cpp	/^		void add_room_dissolve_affect(room_rnum room, affect_map_t& items){$/;"	f	namespace:mods::rooms::affects
add_room_dissolve_affect_every_n_tick	mods/rooms.cpp	/^		void add_room_dissolve_affect_every_n_tick(room_rnum room, affect_t affect, affect_amount_t amt, uint32_t n_ticks){$/;"	f	namespace:mods::rooms::affects
add_room_to_pavements	mods/builder.cpp	/^	void add_room_to_pavements(player_ptr_t& player, int room_id){$/;"	f	namespace:mods::builder
add_subscriber	mods/chat.cpp	/^	void channel::add_subscriber(const socket_t& sock) {$/;"	f	class:mods::chat::channel
add_texture	structs.cpp	/^		void room_data::add_texture(texture_type_t t){$/;"	f	class:room_data
add_textures	structs.h	/^		void add_textures(std::set<texture_type_t> m){$/;"	f
add_to_list	shop.cpp	/^int add_to_list(struct shop_buy_data *list, int type, int *len, int *val) {$/;"	f
add_tree	mods/behaviour_tree_impl.cpp	/^	void add_tree(std::string sv_tree_name,node & n){$/;"	f	namespace:mods::behaviour_tree_impl
add_type	mods/object.cpp	/^	object& object::add_type(object_type_enum_t type){$/;"	f	class:mods::object
adhoc	act.builder.cpp	/^namespace mods::adhoc {$/;"	n	class:mods	file:
advance_level	class.cpp	/^void advance_level(char_data *ch) {$/;"	f
aff	mods/flags.hpp	/^	enum aff {$/;"	g	namespace:mods::flags
aff_abils	mods/player.hpp	/^		char_ability_data& aff_abils(){	 \/* Abils with spells\/stones\/etc  *\/$/;"	f	struct:mods::player
aff_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,22> aff_flags = { {$/;"	m	namespace:mods::builder	file:
affect	mods/affects.hpp	/^			void affect(TAffects aff_id){$/;"	f	struct:mods::affects::dissolver
affect	mods/affects.hpp	/^			void affect(TAffects affect,int amount){$/;"	f	struct:mods::affects::dissolver
affect	mods/player.cpp	/^	void player::affect(uint64_t flag){$/;"	f	class:mods::player
affect_every_n_ticks	mods/affects.hpp	/^			void affect_every_n_ticks(TAffects affect,uint32_t starting_amount, uint32_t every_n_ticks){$/;"	f	struct:mods::affects::dissolver
affect_from_char	handler.cpp	/^void affect_from_char(char_data *ch, int type) {$/;"	f
affect_from_char	mods/js.cpp	/^		static duk_ret_t affect_from_char(duk_context *ctx) {$/;"	f	namespace:mods::js
affect_join	handler.cpp	/^void affect_join(char_data *ch, struct affected_type *af,$/;"	f
affect_map	mods/affects.hpp	/^			void affect_map(TAffectsMap affects){$/;"	f	struct:mods::affects::dissolver
affect_modify	handler.cpp	/^void affect_modify(char_data *ch, byte loc, sbyte mod,$/;"	f
affect_player	mods/affects.cpp	/^	void affect_player(affect_vector_t a,player_ptr_t player){$/;"	f	namespace:mods::affects
affect_player_for	mods/affects.cpp	/^	void affect_player_for(affect_vector_t a,player_ptr_t p,uint64_t ticks){$/;"	f	namespace:mods::affects
affect_plr	mods/player.cpp	/^	void player::affect_plr(uint64_t flag){$/;"	f	class:mods::player
affect_remove	handler.cpp	/^void affect_remove(char_data *ch, struct affected_type *af) {$/;"	f
affect_room	mods/flashbang.hpp	/^	inline void affect_room(room_rnum room, obj_ptr_t& object){$/;"	f	namespace:mods::flashbang
affect_room	mods/flashbang.hpp	/^	inline void affect_room(room_rnum room, uuid_t uuid){$/;"	f	namespace:mods::flashbang
affect_room_light	globals.cpp	/^		void affect_room_light(int room,int offset){$/;"	f	namespace:mods::globals
affect_string_list	mods/affects.cpp	/^std::vector<std::string>& affect_string_list() { return mods::affects::affect_string_list_impl(); }$/;"	f
affect_string_list_impl	mods/affects.cpp	/^std::vector<std::string>& affect_string_list_impl() {$/;"	f	namespace:mods::affects
affect_t	mods/affects.hpp	/^	enum affect_t {$/;"	g	namespace:mods::affects
affect_to_char	handler.cpp	/^void affect_to_char(char_data *ch,affected_type *af) {$/;"	f
affect_total	handler.cpp	/^void affect_total(char_data *ch) {$/;"	f
affect_update	magic.cpp	/^void affect_update(void) {$/;"	f
affect_via	mods/affects.hpp	/^			void affect_via(TAffectsContainer affects){$/;"	f	struct:mods::affects::dissolver
affected	structs.h	/^		obj_affected_type affected[MAX_OBJ_AFFECT];  \/* affects *\/$/;"	m	struct:obj_data
affected	structs.h	/^		struct obj_affected_type affected[MAX_OBJ_AFFECT];$/;"	m	struct:obj_file_elem	typeref:struct:obj_file_elem::obj_affected_type
affected_bits	constants.cpp	/^const char *affected_bits[] = {$/;"	v
affected_bits	constants.hpp	/^const char *affected_bits[] =$/;"	v
affected_bits_count	constants.cpp	/^        affected_bits_count = sizeof(affected_bits) \/ sizeof(affected_bits[0]) - 1,$/;"	v
affected_bits_count	constants.hpp	/^	affected_bits_count = sizeof(affected_bits) \/ sizeof(affected_bits[0]) - 1,$/;"	v
affected_by_spell	handler.cpp	/^bool affected_by_spell(char_data *ch, int type) {$/;"	f
affected_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,38> affected_flags = { {$/;"	m	namespace:mods::builder	file:
affects	mods/affects.cpp	/^namespace mods::affects {$/;"	n	class:mods	file:
affects	mods/affects.cpp	/^namespace mods::rooms::affects {$/;"	n	class:mods::rooms	file:
affects	mods/affects.hpp	/^namespace mods::affects {$/;"	n	class:mods
affects	mods/rooms.cpp	/^	namespace affects {$/;"	n	namespace:mods::rooms	file:
affects	mods/rooms.hpp	/^	namespace affects {$/;"	n	namespace:mods::rooms
age	db.h	/^	int	age;                \/* current age of this zone (minutes) *\/$/;"	m	struct:zone_data
age	utils.cpp	/^struct time_info_data *age(char_data *ch) {$/;"	f
aggressive_mob_on_a_leash	mobact.cpp	/^bool aggressive_mob_on_a_leash(char_data *slave,char_data *master,char_data *attack) {$/;"	f
ai_state	mods/ai_state.hpp	/^			ai_state(char_data* ch,uint8_t st,uint32_t aggr) : m_char_data(ch), m_state(st), mpub_aggro(aggr) {$/;"	f	class:mods::ai_state
ai_state	mods/ai_state.hpp	/^	class ai_state {$/;"	c	namespace:mods
ai_state	structs.h	/^		uint8_t ai_state;$/;"	m	struct:obj_data
alias	interpreter.h	/^	char *alias;$/;"	m	struct:alias_data
alias_data	interpreter.h	/^struct alias_data {$/;"	s
all_integral_flags	mods/doors.hpp	/^	static inline std::vector<exit_info_masks_t> all_integral_flags(int exit_info){$/;"	f	namespace:mods::doors
all_string_flags	mods/doors.hpp	/^	static inline std::vector<std::string> all_string_flags(int exit_info){$/;"	f	namespace:mods::doors
allow	mods/weapon-types.hpp	/^		allow_shot_t allow;$/;"	m	struct:mods::weapon::weapon_type_statistics_t
alt_value_map	mods/values.cpp	/^		std::map<std::string,variants_t> alt_value_map;$/;"	m	namespace:mods::values	file:
alternate_explosion_t	mods/yaml.hpp	/^enum alternate_explosion_t {$/;"	g
alwaysFalse	mods/catch.hpp	/^	inline bool alwaysFalse() {$/;"	f	namespace:Catch
alwaysTrue	mods/catch.hpp	/^	inline bool alwaysTrue() {$/;"	f	namespace:Catch
ammo	mods/player.hpp	/^		uint16_t ammo(){ auto eq = m_equipment[WEAR_WIELD]; return eq ? eq->obj_flags.ammo : 0 ; }$/;"	f	struct:mods::player
ammo	structs.h	/^		uint16_t ammo;$/;"	m	struct:obj_flag_data
ammo	structs.h	/^		uint16_t ammo;$/;"	m	struct:rifle_instance_data
ammo_adjustment	mods/player.cpp	/^	void player::ammo_adjustment(int increment) {$/;"	f	class:mods::player
ammo_max	mods/weapon.hpp	/^			int ammo_max;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
ammo_max	structs.h	/^		uint16_t ammo_max;$/;"	m	struct:obj_flag_data
ammo_type	mods/weapon.hpp	/^			std::string ammo_type;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
ammo_type_adjustment	mods/player.cpp	/^	int player::ammo_type_adjustment(int increment,const weapon_type_t& type) {$/;"	f	class:mods::player
amount	mods/deferred.hpp	/^		int64_t amount;$/;"	m	struct:mods::chunk_affect_t
another_hour	weather.cpp	/^void another_hour(int mode) {$/;"	f
any_one_arg	interpreter.cpp	/^char *any_one_arg(char *argument, char *first_arg) {$/;"	f
aoe	mods/aoe.hpp	/^namespace mods::aoe {$/;"	n	class:mods
aoe_triggers	mods/yaml.hpp	/^		std::array<aoe_type_t,MAX_AOE_TRIGGERS> aoe_triggers;$/;"	m	struct:mods::yaml::explosive_description_t
apcrit_debug	mods/injure.cpp	3;"	d	file:
apcrit_debug	mods/injure.cpp	5;"	d	file:
appear	fight.cpp	/^void appear(char_data *ch) {$/;"	f
append_child	mods/behaviour_tree_node.hpp	/^		void append_child(const child_node_t & child){$/;"	f	struct:mods::behaviour_tree_node
applyEvaluator	mods/catch.hpp	/^		bool applyEvaluator(T1 const& lhs, T2 const& rhs) {$/;"	f	namespace:Catch::Internal
apply_ac	handler.cpp	/^int apply_ac(char_data *ch, int eq_pos) {$/;"	f
apply_saving_throw	mods/player.hpp	/^		sh_int& apply_saving_throw(std::size_t i){$/;"	f	struct:mods::player
apply_saving_throw	mods/player.hpp	/^		sh_int* apply_saving_throw(){$/;"	f	struct:mods::player
apply_types	constants.cpp	/^const char *apply_types[] = {$/;"	v
apply_types	constants.hpp	/^const char *apply_types[] = {$/;"	v
arcSafeRelease	mods/catch.hpp	/^inline void arcSafeRelease(NSObject* obj) {$/;"	f
arcSafeRelease	mods/catch.hpp	/^inline void arcSafeRelease(NSObject*) {}$/;"	f
arg1	db.h	/^	int	arg1;		\/*                                      *\/$/;"	m	struct:reset_com
arg2	db.h	/^	int	arg2;		\/* Arguments to the command             *\/$/;"	m	struct:reset_com
arg3	db.h	/^	int	arg3;		\/*                                      *\/$/;"	m	struct:reset_com
arglist	mods/util.hpp	/^		T arglist(std::string in_arglist_argument) {$/;"	f	namespace:mods::util
argument_interpreter	interpreter.h	42;"	d
armor	mods/item-types.hpp	/^	enum armor {$/;"	g	namespace:mods::weapon::type
armor	mods/player.hpp	/^		sh_int& armor() {$/;"	f	struct:mods::player
armor	mods/skills.hpp	/^		static std::vector<proficiency_t> armor = {$/;"	m	namespace:mods::skills::proficiencies
armor_description_t	mods/yaml.hpp	/^		armor_description_t() :$/;"	f	struct:mods::yaml::armor_description_t
armor_description_t	mods/yaml.hpp	/^	struct armor_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
array_end	mods/jx.hpp	/^			compositor& array_end() {$/;"	f	struct:mods::jx::compositor
array_start	mods/jx.hpp	/^			compositor& array_start(const std::string& key) {$/;"	f	struct:mods::jx::compositor
as_int	mods/pq.cpp	/^	int as_int(result& r,int index, int index_y) {$/;"	f	namespace:mods::pq
asciiflag_conv	db.cpp	/^bitvector_t asciiflag_conv(char *flag) {$/;"	f
assert	sysdep.h	241;"	d
assign	mods/string.cpp	/^	void string::assign(const std::string & other){$/;"	f	class:mods::string
assign	mods/string.cpp	/^	void string::assign(mentoc_pqxx_result_t other){$/;"	f	class:mods::string
assign	mods/string.cpp	/^	void string::assign(mentoc_pqxx_result_t::reference str){$/;"	f	class:mods::string
assign	mods/string.cpp	/^	void string::assign(nullptr_t a){$/;"	f	class:mods::string
assign_kings_castle	castle.cpp	/^void assign_kings_castle(void) {$/;"	f
assign_m	mods/string.cpp	/^	void string::assign_m(const mods::string & other){$/;"	f	class:mods::string
assign_mobiles	mods/hell.hpp	/^	constexpr inline bool assign_mobiles = false;$/;"	m	namespace:mods::hell
assign_mobiles	spec_assign.cpp	/^void assign_mobiles() {$/;"	f
assign_objects	mods/hell.hpp	/^	constexpr inline bool assign_objects = false;$/;"	m	namespace:mods::hell
assign_objects	spec_assign.cpp	/^void assign_objects() {$/;"	f
assign_rooms	mods/hell.hpp	/^	constexpr inline bool assign_rooms = false;$/;"	m	namespace:mods::hell
assign_rooms	spec_assign.cpp	/^void assign_rooms(void) {$/;"	f
assign_the_shopkeepers	mods/hell.hpp	/^	constexpr inline bool assign_the_shopkeepers = false;$/;"	m	namespace:mods::hell
assign_the_shopkeepers	shop.cpp	/^void assign_the_shopkeepers(void) {$/;"	f
atrium	house.h	/^	room_vnum atrium;		\/* vnum of atrium		*\/$/;"	m	struct:house_control_rec
attachment	mods/item-types.hpp	/^	enum attachment {$/;"	g	namespace:mods::weapon::type
attachment_description_t	mods/yaml.hpp	/^		attachment_description_t() :$/;"	f	struct:mods::yaml::attachment_description_t
attachment_description_t	mods/yaml.hpp	/^	struct attachment_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
attachment_t	mods/weapon.hpp	/^	enum attachment_t {$/;"	g	namespace:mods::weapon
attachments	structs.h	/^		std::deque<attachment_data_t> attachments;$/;"	m	struct:rifle_instance_data
attack_hit_text	fight.cpp	/^struct attack_hit_type attack_hit_text[] = {$/;"	v	typeref:struct:attack_hit_type
attack_hit_type	spells.h	/^struct attack_hit_type {$/;"	s
attack_message	fight.cpp	/^int attack_message(mw_rifle type){$/;"	f
attacking_with	mods/player.hpp	/^		obj_data_ptr_t attacking_with(){ return m_attacking_with; }$/;"	f	struct:mods::player
attacking_with_type	mods/player.hpp	/^		int attacking_with_type(){ return m_attacking_with->rifle()->attributes->type; }$/;"	f	struct:mods::player
authenticated	mods/player.hpp	/^		bool authenticated() const { return m_authenticated; }$/;"	f	struct:mods::player
authtype_names	telnet.h	/^char *authtype_names[] = {$/;"	v
auto_equip	objsave.cpp	/^void auto_equip(char_data *ch, struct obj_data *obj, int location) {$/;"	f
auto_login	mods/auto-login.cpp	/^namespace mods::auto_login {$/;"	n	class:mods	file:
auto_login	mods/auto-login.hpp	/^namespace mods::auto_login {$/;"	n	class:mods
auto_login_enabled	mods/auto-login.cpp	/^	bool auto_login_enabled(){ return mods::auto_login::get_user().length(); }$/;"	f	namespace:mods::auto_login
auto_save	config.cpp	/^int auto_save = YES;$/;"	v
autosave_time	config.cpp	/^int autosave_time = 5;$/;"	v
award_quest	mods/quests.cpp	/^		void award_quest(char_data* ch,int quest_id) {$/;"	f	namespace:mods::quests
background	db.cpp	/^char *background = NULL;	\/* background story		 *\/$/;"	v
backstab_mult	class.cpp	/^int backstab_mult(int level) {$/;"	f
ban_list	ban.cpp	/^struct ban_list_element *ban_list = NULL;$/;"	v	typeref:struct:ban_list_element
ban_list_element	db.h	/^struct ban_list_element {$/;"	s
ban_system	mods/ban_system.hpp	/^	namespace ban_system {$/;"	n	namespace:mods
ban_types	ban.cpp	/^const char *ban_types[] = {$/;"	v
bank	spec_assign.cpp	/^SPECIAL(bank);$/;"	v
bank	spec_procs.cpp	/^SPECIAL(bank);$/;"	v
bankAccount	shop.h	/^	int	 bankAccount;		\/* Store all gold over 15000 (disabled)	*\/$/;"	m	struct:shop_data
bank_gold	mods/player.hpp	/^		int& bank_gold() {$/;"	f	struct:mods::player
banzaii	castle.cpp	/^int banzaii(char_data *ch) {$/;"	f
barrel_t	mods/weapon.hpp	/^	enum barrel_t {$/;"	g	namespace:mods::weapon
base_items	mods/yaml.cpp	/^	void base_items(std::ofstream* out_file,std::string_view name,std::string_view obj_type){$/;"	f	namespace:mods::yaml
base_rifle_object	mods/weapon.cpp	/^	obj_data_ptr_t base_rifle_object(){$/;"	f	namespace:mods::weapon
base_stat_list	mods/yaml.hpp	/^			mods::weapon::weapon_stat_list_t* base_stat_list;$/;"	m	struct:mods::yaml::rifle_description_t
basic_mud_log	utils.cpp	/^void basic_mud_log(const char *format, ...) {$/;"	f
basic_mud_vlog	utils.cpp	/^void basic_mud_vlog(const char *format, va_list args) {$/;"	f
behaviour_tree	mods/behaviour_tree.hpp	/^		behaviour_tree() : m_tree_name("default") {}$/;"	f	struct:mods::behaviour_tree
behaviour_tree	mods/behaviour_tree.hpp	/^		behaviour_tree(const std::string_view & name) : m_tree_name(name) {}$/;"	f	struct:mods::behaviour_tree
behaviour_tree	mods/behaviour_tree.hpp	/^		behaviour_tree(const std::string_view & name,$/;"	f	struct:mods::behaviour_tree
behaviour_tree	mods/behaviour_tree.hpp	/^	struct behaviour_tree {$/;"	s	namespace:mods
behaviour_tree_impl	mods/behaviour_tree_impl.cpp	/^namespace mods::behaviour_tree_impl {$/;"	n	class:mods	file:
behaviour_tree_impl	mods/behaviour_tree_impl.hpp	/^	namespace behaviour_tree_impl { $/;"	n	namespace:mods
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(callback_t& c, const node_type_t& t) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(callback_t& c,const node_type_t& t, const children_t& ch) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(const node_type_t& t) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^		behaviour_tree_node(const node_type_t& t,const children_t & ch) : $/;"	f	struct:mods::behaviour_tree_node
behaviour_tree_node	mods/behaviour_tree_node.hpp	/^	struct behaviour_tree_node {$/;"	s	namespace:mods
behaviour_tree_status	mods/behaviour_tree_status.hpp	/^	enum behaviour_tree_status {$/;"	g	namespace:mods
bfs_clear_queue	graph.cpp	/^void bfs_clear_queue(void) {$/;"	f
bfs_dequeue	graph.cpp	/^void bfs_dequeue(void) {$/;"	f
bfs_enqueue	graph.cpp	/^void bfs_enqueue(room_rnum room, int dir) {$/;"	f
bfs_queue_struct	graph.cpp	/^struct bfs_queue_struct {$/;"	s	file:
bht_debug	mobact.cpp	44;"	d	file:
bht_debug	mobact.cpp	46;"	d	file:
bit	mods/deferred.hpp	/^		uint64_t bit;$/;"	m	struct:mods::chunk_affect_t
bitvector	shop.h	/^	bitvector_t	 bitvector;	\/* Can attack? Use bank? Cast here?	*\/$/;"	m	struct:shop_data
bitvector	structs.h	/^		long \/*bitvector_t*\/	bitvector;	\/* To set chars bits                *\/$/;"	m	struct:obj_flag_data
bitvector	structs.h	/^		long \/*bitvector_t*\/	bitvector;$/;"	m	struct:obj_file_elem
blacklist_zone	mods/builder.cpp	/^void blacklist_zone(int zone){$/;"	f
blank_object	db.cpp	/^obj_ptr_t blank_object() {$/;"	f
blank_room	globals.cpp	/^		static mods::globals::player_list_t blank_room;$/;"	m	namespace:mods::globals	file:
blind_target	mods/projectile.cpp	/^		void blind_target(player_ptr_t victim){$/;"	f	namespace:mods::projectile
blindness_clears_up	mods/projectile.cpp	/^		void blindness_clears_up(player_ptr_t victim){$/;"	f	namespace:mods::projectile
block_for	mods/player.cpp	/^	void player::block_for(uint16_t ticks, uint32_t unblock_event,uuid_t optional_uuid){$/;"	f	class:mods::player
block_type	mail.h	/^	long	block_type;		\/* -1 if header block, -2 if last data block$/;"	m	struct:data_block_type_d
block_type	mail.h	/^	long	block_type;		\/* is this a header or data block?	*\/$/;"	m	struct:header_block_type_d
block_way	castle.cpp	/^int block_way(char_data *ch, int cmd, char *arg, room_vnum iIn_room,$/;"	f
board_info	boards.cpp	/^struct board_info_type board_info[NUM_OF_BOARDS] = {$/;"	v	typeref:struct:board_info_type
board_info_type	boards.h	/^struct board_info_type {$/;"	s
board_msginfo	boards.h	/^struct board_msginfo {$/;"	s
bool	structs.h	/^	typedef char			bool;$/;"	t
boot_db	db.cpp	/^void boot_db(void) {$/;"	f
boot_hell	db.cpp	/^void boot_hell(void){$/;"	f
boot_social_messages	act.social.cpp	/^void boot_social_messages(void) {$/;"	f
boot_social_messages	mods/hell.hpp	/^	constexpr inline bool boot_social_messages = false;$/;"	m	namespace:mods::hell
boot_sql_shops	shop.cpp	/^void boot_sql_shops() {$/;"	f
boot_suite	mods/pregame.cpp	/^	void boot_suite(std::string_view suite){$/;"	f	namespace:mods::pregame
boot_the_shops	shop.cpp	/^void boot_the_shops() {$/;"	f
boot_time	db.cpp	/^time_t boot_time = 0;		\/* time of mud boot		 *\/$/;"	v
boot_type	globals.cpp	/^		boot_type_t boot_type;$/;"	m	namespace:mods::globals	file:
boot_type_hell	utils.cpp	/^bool boot_type_hell(){$/;"	f
boot_type_t	globals.hpp	/^		enum boot_type_t { BOOT_DB,BOOT_HELL };$/;"	g	namespace:mods::globals
boot_world	db.cpp	/^void boot_world(void) {$/;"	f
bootup_test_suite	globals.cpp	/^		std::string bootup_test_suite;$/;"	m	namespace:mods::globals	file:
bot	db.h	/^	uint64_t bot;           \/* starting room number for this zone *\/$/;"	m	struct:zone_data
breached	mods/doors.hpp	/^	static inline void breached(const room_rnum room,int direction){$/;"	f	namespace:mods::doors
bti_debug	mods/behaviour_tree_impl.cpp	9;"	d	file:
buf_largecount	comm.cpp	/^int buf_largecount = 0;		\/* # of large buffers which exist *\/$/;"	v
buf_overflows	comm.cpp	/^int buf_overflows = 0;		\/* # of overflows of output *\/$/;"	v
buf_switches	comm.cpp	/^int buf_switches = 0;		\/* # of switches from small to large buf *\/$/;"	v
bufpool	comm.cpp	/^struct txt_block *bufpool = 0;	\/* pool of large output buffers *\/$/;"	v	typeref:struct:txt_block
build_player_index	db.cpp	/^void build_player_index(void) {$/;"	f
builder	mods/builder.cpp	/^namespace mods::builder {$/;"	n	class:mods	file:
builder	mods/builder.hpp	/^namespace mods::builder {$/;"	n	class:mods
builder_data	mods/builder.hpp	/^		std::shared_ptr<builder_data_t> builder_data(){ return m_builder_data; }$/;"	f	struct:mods::builder::sandbox_data_t
builder_data	mods/player.hpp	/^		std::shared_ptr<builder_data_t> builder_data;$/;"	m	struct:mods::player
builder_data_t	structs.cpp	/^		builder_data_t::builder_data_t(int type,int start_room,int start_zone) {$/;"	f	class:builder_data_t
builder_mode	mods/player.cpp	/^	bool player::builder_mode() const{$/;"	f	class:mods::player
builder_util	mods/builder_util.hpp	/^namespace mods::builder_util {$/;"	n	class:mods
builders	mods/acl_list.cpp	/^		static player_acl_list_t builders;$/;"	m	namespace:mods::acl_list::list_container	file:
built_on	house.h	/^	time_t built_on;		\/* date this house was built	*\/$/;"	m	struct:house_control_rec
buy_item	mods/shop.hpp	/^	void buy_item(player_ptr_t& player, TShopMap& shop_map, std::string_view argument){$/;"	f	namespace:mods::shop
buy_price	shop.cpp	/^int buy_price(struct obj_data *obj, int shop_nr, char_data *keeper, char_data *buyer) {$/;"	f
by_name	mods/pfind.cpp	/^	player_ptr_t by_name(const char* player_name){$/;"	f	namespace:mods::pfind
by_uuid	mods/pfind.cpp	/^	player_ptr_t by_uuid(uuid_t player_uuid){$/;"	f	namespace:mods::pfind
byte	structs.h	/^	typedef signed char			byte;$/;"	t
c_str	mods/string.cpp	/^	const char* string::c_str() const {$/;"	f	class:mods::string
cached_room_distance	mods/scan.cpp	/^	std::tuple<bool,distance_t> cached_room_distance(const room_rnum& hunters_room,$/;"	f	namespace:mods::scan
calculate_shrapnel_rooms	mods/projectile.cpp	/^		rooms_away_t calculate_shrapnel_rooms(room_rnum room, obj_ptr_t held_object,std::size_t blast_radius){$/;"	f	namespace:mods::projectile
call_magic	spell_parser.cpp	/^int call_magic(char_data *caster, char_data *cvict,$/;"	f
callback	mods/projectile.hpp	/^		typedef std::function<void (room_rnum,int)> callback;$/;"	t	namespace:mods::projectile
camera	mods/camera.cpp	/^	camera::camera(uuid_t  owner, uuid_t  obj) :$/;"	f	class:mods::camera
camera	mods/camera.cpp	/^	camera::camera(uuid_t  owner, uuid_t  obj, uint16_t time) :$/;"	f	class:mods::camera
camera	mods/camera.hpp	/^	class camera {$/;"	c	namespace:mods
camera_viewing	mods/player.cpp	/^	bool player::camera_viewing(){ return m_camera_viewing; }$/;"	f	class:mods::player
can	globals.hpp	/^static inline bool can(player_ptr_t& player,int skill){ return mods::skills::player_can(player,skill); }$/;"	f
can	structs.h	/^		bool can(std::size_t val){$/;"	f	struct:obj_data
can_attack_same_room	mods/object-utils.hpp	/^		bool can_attack_same_room(T& obj){$/;"	f	namespace:mods::object_utils
can_carry_n	act.item.cpp	/^int can_carry_n(player_ptr_t player){$/;"	f
can_modify	olc.cpp	/^int can_modify(char_data *ch, int vnum) {$/;"	f
can_see_player	mods/sensor-grenade.cpp	/^	bool can_see_player(uuid_t nade,player_ptr_t& target){$/;"	f	namespace:mods::sensor_grenade
can_see_through_fire	mods/rooms.hpp	/^	static inline bool can_see_through_fire(room_rnum room) {$/;"	f	namespace:mods::rooms
can_snipe	mods/player.cpp	/^	bool player::can_snipe(player_ptr_t target) {$/;"	f	class:mods::player
can_take_obj	act.item.cpp	/^int can_take_obj(char_data *ch, struct obj_data *obj) {$/;"	f
cancel_block	mods/player.cpp	/^	void player::cancel_block(){$/;"	f	class:mods::player
cancel_event	mods/deferred.cpp	/^	void deferred::cancel_event(event_queue_iterator it){$/;"	f	class:mods::deferred
cancel_lambda	mods/deferred.cpp	/^	void deferred::cancel_lambda(lambda_queue_iterator it){$/;"	f	class:mods::deferred
cap_t	mods/weapon-types.hpp	/^	enum cap_t {$/;"	g	namespace:mods::weapon::capabilities
capabilities	mods/weapon-types.hpp	/^namespace mods::weapon::capabilities {$/;"	n	class:mods::weapon
capabilities	structs.h	/^		capability_list_t& capabilities(){ return m_capabilities; }$/;"	f	struct:obj_data
capability_t	mods/item.hpp	/^	enum capability_t {$/;"	g	namespace:mods::item
capture_output	mods/player.cpp	/^	void player::capture_output(bool capture_status) {$/;"	f	class:mods::player
capturedExpression	mods/catch.hpp	/^		std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo
carried_by	structs.h	/^		char_data *carried_by;  \/* Carried by :NULL in room\/conta   *\/$/;"	m	struct:obj_data
carry	mods/player.cpp	/^	void player::carry(obj_ptr_t obj){$/;"	f	class:mods::player
carry_items	mods/player.hpp	/^		byte& carry_items(){$/;"	f	struct:mods::player
carry_weight	mods/player.hpp	/^		int&	carry_weight(){$/;"	f	struct:mods::player
carrying	mods/player.cpp	/^	obj_data* player::carrying(){$/;"	f	class:mods::player
carrying_ammo_of_type	mods/player.cpp	/^	bool player::carrying_ammo_of_type(const weapon_type_t& type) {$/;"	f	class:mods::player
cast_spell	spell_parser.cpp	/^int cast_spell(char_data *ch, char_data *tch,$/;"	f
castle_cleaner	castle.cpp	/^int castle_cleaner(char_data *ch, int cmd, int gripe) {$/;"	f
castle_mob_spec	castle.cpp	/^void castle_mob_spec(mob_vnum mobnum, SPECIAL(*specproc)) {$/;"	f
castle_real_room	castle.cpp	/^room_rnum castle_real_room(room_vnum roomoffset) {$/;"	f
castle_twin_proc	castle.cpp	/^int castle_twin_proc(char_data *ch, int cmd, char *arg, int ctlnum, const char *twinname) {$/;"	f
castle_virtual	castle.cpp	/^mob_vnum castle_virtual(mob_vnum offset) {$/;"	f
cd	mods/drone.hpp	/^			char_data* cd() const {$/;"	f	class:mods::drone
cd	mods/player.hpp	/^		char_data* cd() const {$/;"	f	struct:mods::player
ch	mods/scan.hpp	/^			char_data* ch;$/;"	m	struct:mods::scan::__anon4
ch_time	mods/player.hpp	/^		time_data& ch_time(){$/;"	f	struct:mods::player
chan	globals.cpp	/^		std::vector<mods::chat::channel> chan;$/;"	m	namespace:mods::globals	file:
chan_verbs	globals.cpp	/^		std::vector<std::string> chan_verbs;$/;"	m	namespace:mods::globals	file:
chance_to_injure	mods/weapon.hpp	/^			float chance_to_injure;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
change_alignment	fight.cpp	/^void change_alignment(char_data *ch, char_data *victim) {$/;"	f
channel	mods/chat.hpp	/^			channel(std::string_view name,std::string_view verb,bool b_private) :$/;"	f	struct:mods::mods::chat::channel
channel	mods/chat.hpp	/^	struct channel {$/;"	s	namespace:mods::mods::chat
char_auto	act.social.cpp	/^	char *char_auto;$/;"	m	struct:social_messg	file:
char_data	mods/ai_state.hpp	/^typedef struct char_data char_data;$/;"	t	typeref:struct:char_data
char_data	structs.cpp	/^		char_data::char_data(char_data* o){$/;"	f	class:char_data
char_exists	db.cpp	/^bool char_exists(const std::string& name){$/;"	f
char_exists	db.cpp	/^bool char_exists(const std::string& name, aligned_int_t & meta_int_id){$/;"	f
char_exists	db.cpp	/^bool char_exists(player_ptr_t player_ptr){$/;"	f
char_found	act.social.cpp	/^	char *char_found;		\/* if NULL, read no further, ignore args *\/$/;"	m	struct:social_messg	file:
char_from_room	globals.cpp	/^			void char_from_room(char_data* ch) {$/;"	f	namespace:mods::globals::rooms
char_from_room	handler.cpp	/^void char_from_room(char_data *ch) {$/;"	f
char_from_room	handler.h	/^static inline void	char_from_room(player_ptr_t player){$/;"	f
char_from_room	mods/js.cpp	/^		static duk_ret_t char_from_room(duk_context *ctx){$/;"	f	namespace:mods::js
char_no_arg	act.social.cpp	/^	char *char_no_arg;$/;"	m	struct:social_messg	file:
char_player_data	structs.cpp	/^		char_player_data::char_player_data(){$/;"	f	class:char_player_data
char_specials	mods/player.hpp	/^		char_special_data& char_specials(){$/;"	f	struct:mods::player
char_to_int	bsd-snprintf.cpp	154;"	d	file:
char_to_room	globals.cpp	/^			void char_to_room(const room_rnum& room,char_data* ch) {$/;"	f	namespace:mods::globals::rooms
char_to_room	handler.cpp	/^void char_to_room(char_data *ch, room_rnum room) {$/;"	f
char_to_room	handler.h	/^static inline void	char_to_room(player_ptr_t player, room_rnum room) {$/;"	f
char_to_store	db.cpp	/^void char_to_store(char_data *ch, struct char_file_u *st) {$/;"	f
character_list	globals.cpp	/^char_data* character_list = NULL;$/;"	v
chargen	mods/chargen.cpp	/^namespace mods::chargen {$/;"	n	class:mods	file:
chargen	mods/chargen.hpp	/^namespace mods::chargen {$/;"	n	class:mods
chat	mods/chat.cpp	/^namespace mods::chat {$/;"	n	class:mods	file:
chat	mods/chat.hpp	/^namespace mods::chat {$/;"	n	class:mods
chat	mods/chat.hpp	/^namespace mods::chat {$/;"	n	class:mods::mods
chclass	mods/player.hpp	/^		byte& chclass(){$/;"	f	struct:mods::player
chdir	sysdep.h	355;"	d
check_bitvector_names	db.cpp	/^int check_bitvector_names(bitvector_t bits, size_t namecount, const char *whatami, const char *whatbits) {$/;"	f
check_idle_passwords	comm.cpp	/^void check_idle_passwords(void) {$/;"	f
check_idling	limits.cpp	/^void check_idling(player_ptr_t player) {$/;"	f
check_killer	fight.cpp	/^void check_killer(char_data *ch, char_data *vict) {$/;"	f
check_object	db.cpp	/^int check_object(struct obj_data *obj) {$/;"	f
check_object_level	db.cpp	/^int check_object_level(struct obj_data *obj, int val) {$/;"	f
check_object_spell_number	db.cpp	/^int check_object_spell_number(struct obj_data *obj, int val) {$/;"	f
check_start_rooms	db.cpp	/^void check_start_rooms(void) {$/;"	f
checkpointing	comm.cpp	/^RETSIGTYPE checkpointing(int sig) {$/;"	f
chemical_damage	mods/projectile.cpp	/^		int chemical_damage(player_ptr_t victim, obj_ptr_t item){$/;"	f	namespace:mods::projectile
chemistry	mods/skills.hpp	/^		static std::vector<proficiency_t> chemistry = {$/;"	m	namespace:mods::skills::proficiencies
chunk	mods/deferred.hpp	/^		std::size_t chunk;$/;"	m	struct:mods::chunk_affect_t
chunk_affect_t	mods/deferred.hpp	/^	struct chunk_affect_t {$/;"	s	namespace:mods
chunk_type_t	mods/flags.hpp	/^	enum chunk_type_t {$/;"	g	namespace:mods::flags
circle_follow	utils.cpp	/^bool circle_follow(char_data *ch, char_data *victim) {$/;"	f
circle_random	random.cpp	/^unsigned long circle_random(void) {$/;"	f
circle_reboot	comm.cpp	/^int circle_reboot = 0;		\/* reboot the game after a shutdown *\/$/;"	v
circle_restrict	db.cpp	/^int circle_restrict = 0;	\/* level of game restriction	 *\/$/;"	v
circle_shutdown	comm.cpp	/^int circle_shutdown = 0;	\/* clean shutdown *\/$/;"	v
circle_sleep	comm.cpp	/^void circle_sleep(struct timeval *timeout) {$/;"	f
circle_srandom	random.cpp	/^void circle_srandom(unsigned long initial_seed) {$/;"	f
circlemud_version	constants.cpp	/^const char *circlemud_version =$/;"	v
circlemud_version	constants.hpp	/^constexpr const char *circlemud_version =$/;"	v
cityguard	spec_assign.cpp	/^SPECIAL(cityguard);$/;"	v
cityguard	spec_procs.cpp	/^SPECIAL(cityguard);$/;"	v
cl_medic	mods/player.cpp	/^	std::shared_ptr<mods::classes::medic> 	player::cl_medic(){$/;"	f	class:mods::player
cl_sentinel	mods/player.hpp	/^		std::shared_ptr<mods::classes::sentinel> cl_sentinel(){ return m_class_sentinel; }$/;"	f	struct:mods::player
cl_sniper	mods/player.cpp	/^	std::shared_ptr<mods::classes::sniper> 	player::cl_sniper(){$/;"	f	class:mods::player
class_abbrevs	class.cpp	/^const char *class_abbrevs[] = {$/;"	v
class_menu	class.cpp	/^const char* class_menu =$/;"	v
classes	mods/player.hpp	/^	namespace classes {$/;"	n	namespace:mods
classes	mods/player.hpp	/^namespace mods::classes {$/;"	n	class:mods
cleaning	castle.cpp	/^SPECIAL(cleaning);$/;"	v
clear	mods/affects.hpp	/^			void clear(TAffectsContainer affects){$/;"	f	struct:mods::affects::dissolver
clear	mods/sql.hpp	/^			compositor<T>& clear() {$/;"	f	struct:mods::sql::compositor
clear	mods/string.cpp	/^	void string::clear(){$/;"	f	class:mods::string
clearMemory	mobact.cpp	/^void clearMemory(char_data *ch) {$/;"	f
clear_all_affected	mods/player.cpp	/^	void player::clear_all_affected(){$/;"	f	class:mods::player
clear_all_affected_flags	mods/js.cpp	/^		static duk_ret_t clear_all_affected_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
clear_all_affected_plr	mods/player.cpp	/^	void player::clear_all_affected_plr(){$/;"	f	class:mods::player
clear_all_plr_flags	mods/js.cpp	/^		static duk_ret_t clear_all_plr_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
clear_attacking_with	mods/player.hpp	/^		void clear_attacking_with(){ m_attacking_with = nullptr; }$/;"	f	struct:mods::player
clear_behaviour_tree	structs.cpp	/^		void mob_special_data::clear_behaviour_tree(){$/;"	f	class:mob_special_data
clear_camera	mods/player.cpp	/^	void player::clear_camera(){$/;"	f	class:mods::player
clear_capabilities	structs.h	/^		void clear_capabilities() {$/;"	f	struct:obj_data
clear_captured_output	mods/player.cpp	/^	void player::clear_captured_output() {$/;"	f	class:mods::player
clear_free_list	mail.cpp	/^void clear_free_list(void) {$/;"	f
clear_object	db.cpp	/^void clear_object(struct obj_data *obj) {$/;"	f
clear_pluck_filter	mods/lmdb.cpp	/^	void _db_handle::clear_pluck_filter(){$/;"	f	class:mods::lmdb::_db_handle
clear_yaml_exceptions	mods/object-utils.hpp	/^	static inline void clear_yaml_exceptions(){$/;"	f	namespace:mods::object_utils
clip_size	mods/weapon.hpp	/^			int clip_size;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
clip_size	structs.h	/^		uint16_t clip_size;$/;"	m	struct:obj_flag_data
close	mods/lmdb.cpp	/^	void _db_handle::close(){$/;"	f	class:mods::lmdb::_db_handle
close1	shop.h	/^	int	 close1, close2;	\/* When does the shop close?		*\/$/;"	m	struct:shop_data
close2	shop.h	/^	int	 close1, close2;	\/* When does the shop close?		*\/$/;"	m	struct:shop_data
close_socket	comm.cpp	/^void close_socket(mods::descriptor_data& d) {$/;"	f
clr	screen.h	28;"	d
clr_affected_by	mods/player.hpp	/^		void clr_affected_by(){ m_affected_by.clear(); }$/;"	f	struct:mods::player
cmd	act.wizard.cpp	/^	const char *cmd;$/;"	m	struct:set_struct	file:
cmd	db.h	/^	std::vector<reset_com> cmd;   \/* command table for reset	          *\/$/;"	m	struct:zone_data
cmd	mods/js.cpp	/^		static duk_ret_t cmd(duk_context *ctx) {$/;"	f	namespace:mods::js
cmd_door	act.movement.cpp	/^	const char *cmd_door[] = {$/;"	v
cmd_emote	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_exec	mods/js.cpp	/^		static duk_ret_t cmd_exec(duk_context *ctx) {$/;"	f	namespace:mods::js
cmd_info	interpreter.cpp	/^cpp_extern const struct command_info cmd_info[] = {$/;"	v	typeref:struct:command_info
cmd_puke	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_say	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_slap	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
cmd_sort_info	act.informative.cpp	/^int *cmd_sort_info;$/;"	v
cmd_tell	shop.cpp	/^int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;$/;"	v
color_eval	globals.cpp	/^		std::string color_eval(std::string_view buffer) {$/;"	f	namespace:mods::globals
color_liquid	constants.cpp	/^const char *color_liquid[] = {$/;"	v
color_liquid	constants.hpp	/^const char *color_liquid[] =$/;"	v
column	mods/lmdb.hpp	/^		key_type_t column;$/;"	m	struct:mods::lmdb::_selector
combat_list	fight.cpp	/^char_data *combat_list = NULL;	\/* head of l-list of fighting chars *\/$/;"	v
command	db.h	/^	char	command;   \/* current command                      *\/$/;"	m	struct:reset_com
command	interpreter.h	/^	const char *command;$/;"	m	struct:command_info
command_info	interpreter.h	/^struct command_info {$/;"	s
command_interpreter	globals.cpp	/^		bool command_interpreter(player_ptr_t player,std::string_view in_argument) {$/;"	f	namespace:mods::globals
command_interpreter	interpreter.cpp	/^void command_interpreter(player_ptr_t & player, std::string in_argument){$/;"	f
command_pointer	interpreter.h	/^	void	(*command_pointer)$/;"	m	struct:command_info
commit	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::commit(){$/;"	f	class:mods::lmdb::_db_handle
commit	mods/pq.cpp	/^	void commit(transaction& txn) {$/;"	f	namespace:mods::pq
common_weaponry_skillset	class.cpp	/^std::string common_weaponry_skillset() {$/;"	f
compare	mods/catch.hpp	/^		bool compare(T1 const& lhs, T2 const& rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, long long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(T* lhs, std::nullptr_t) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(int lhs, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(long lhs, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(long long lhs, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op, typename T> bool compare(std::nullptr_t, T* rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(int lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(int lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(int lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned long long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(long long lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned char lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned char lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned int lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned int lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, char rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, int rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, long long rhs) {$/;"	f	namespace:Catch::Internal
compare	mods/catch.hpp	/^		template<Operator Op> bool compare(unsigned long long lhs, long rhs) {$/;"	f	namespace:Catch::Internal
compare_spells	spec_procs.cpp	/^int compare_spells(const void *x, const void *y) {$/;"	f
complete_key	mods/quests.cpp	/^		std::string complete_key(char_data *ch,room_rnum room,int n_index) {$/;"	f	namespace:mods::quests
compositor	mods/jx.hpp	/^			compositor() : m_current_level(0) {$/;"	f	struct:mods::jx::compositor
compositor	mods/jx.hpp	/^	struct compositor {$/;"	s	namespace:mods::jx
compositor	mods/sql.hpp	/^			compositor(str_object table, T* txn_ptr) :$/;"	f	struct:mods::sql::compositor
compositor	mods/sql.hpp	/^	struct compositor {$/;"	s	namespace:mods::sql
compute_armor_class	fight.cpp	/^int compute_armor_class(char_data *ch) {$/;"	f
compute_thaco	fight.cpp	/^int compute_thaco(char_data *ch, char_data *victim) {$/;"	f
con_app	constants.cpp	/^cpp_extern const struct con_app_type con_app[] = {$/;"	v	typeref:struct:con_app_type
con_app	constants.hpp	/^cpp_extern const struct con_app_type con_app[] = {$/;"	v	typeref:struct:con_app_type
concat	mods/string.cpp	/^	void string::concat(const std::string & str){$/;"	f	class:mods::string
concat	mods/string.cpp	/^	void string::concat(int ch){$/;"	f	class:mods::string
conf	mods/conf.cpp	/^namespace mods::conf {$/;"	n	class:mods	file:
conf	mods/conf.hpp	/^namespace mods::conf {$/;"	n	class:mods
conf	mods/util-conf.hpp	/^		namespace conf {$/;"	n	namespace:mods::util
config	config.cpp	/^namespace config {$/;"	n	file:
config	config.hpp	/^namespace config {$/;"	n
config	globals.cpp	/^namespace config {$/;"	n	file:
connected_types	constants.cpp	/^const char *connected_types[] = {$/;"	v
connected_types	constants.hpp	/^const char *connected_types[] = {$/;"	v
consumable	mods/item-types.hpp	/^	enum consumable {$/;"	g	namespace:mods::weapon::type
consumable_description_t	mods/yaml.hpp	/^		consumable_description_t() :$/;"	f	struct:mods::yaml::consumable_description_t
consumable_description_t	mods/yaml.hpp	/^	struct consumable_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
consume	mods/sensor-grenade.cpp	/^	void consume(uuid_t nade_uuid){$/;"	f	namespace:mods::sensor_grenade
consume_from_carrying	mods/player.cpp	/^	void player::consume_from_carrying(obj_ptr_t& item){$/;"	f	class:mods::player
container_bits	constants.cpp	/^const char *container_bits[] = {$/;"	v
container_bits	constants.hpp	/^const char *container_bits[] = {$/;"	v
contains	structs.h	/^		obj_data *contains;     \/* Contains objects                 *\/$/;"	m	struct:obj_data
contents	structs.h	/^		obj_data *contents;   \/* List of items in room              *\/$/;"	v
contents_container	structs.h	/^		std::deque<std::shared_ptr<obj_data>>& contents_container(){ return this->m_contents; }$/;"	f
contextual_eval_string	mods/js.cpp	/^		void contextual_eval_string(char_data* player,duk_context* ctx,const std::string& str) {$/;"	f	namespace:mods::js
contextual_eval_string	mods/js.cpp	/^		void contextual_eval_string(mods::player* player,duk_context* ctx,const std::string& str) {$/;"	f	namespace:mods::js
convert	mods/catch.hpp	/^			static std::string convert(T const& _value) {$/;"	f	struct:Catch::Detail::StringMakerBase
convert	mods/catch.hpp	/^			static std::string convert(T const& v) {$/;"	f	struct:Catch::Detail::EnumStringMaker
convert	mods/catch.hpp	/^			static std::string convert(T const& v) {$/;"	f	struct:Catch::Detail::StringMakerBase
convert	mods/catch.hpp	/^			static std::string convert(T const&) {$/;"	f	struct:Catch::Detail::EnumStringMaker
convert	mods/catch.hpp	/^		static std::string convert(R C::* p) {$/;"	f	struct:Catch::StringMaker
convert	mods/catch.hpp	/^		static std::string convert(U* p) {$/;"	f	struct:Catch::StringMaker
cooldown_between_shots	mods/weapon.hpp	/^			float cooldown_between_shots;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
core_dump	utils.h	56;"	d
core_dump_real	utils.cpp	/^void core_dump_real(const char *who, int line) {$/;"	f
cost	structs.h	/^		int	cost;		\/* Value when sold (gp.)            *\/$/;"	m	struct:obj_flag_data
cost_per_day	structs.h	/^		int	cost_per_day;	\/* Cost to keep pr. real day        *\/$/;"	m	struct:obj_flag_data
count	mods/pq.cpp	/^	int count(std::string_view query) {$/;"	f	namespace:mods::pq
count_alias_records	db.cpp	/^int count_alias_records(FILE *fl) {$/;"	f
count_gathering	mods/sensor-grenade.cpp	/^	static count_gathering_t count_gathering;$/;"	m	namespace:mods::sensor_grenade	file:
count_hash_records	db.cpp	/^int count_hash_records(FILE *fl) {$/;"	f
count_pages	modify.cpp	/^int count_pages(char *str) {$/;"	f
cpp_extern	sysdep.h	400;"	d
cpp_extern	sysdep.h	402;"	d
crash_file_timeout	config.cpp	/^int crash_file_timeout = 10;$/;"	v
crawl_blast_radius	mods/sensor-grenade.cpp	/^	void crawl_blast_radius($/;"	f	namespace:mods::sensor_grenade
crawl_lambda	mods/overhead_map.cpp	/^	void crawl_lambda(std::vector<std::vector<std::string>>& map_coordinates,$/;"	f	namespace:mods::overhead_map
create	mods/behaviour_tree_node.hpp	/^		static child_node_t create(callback_t& c,node_type_t n_type){$/;"	f	struct:mods::behaviour_tree_node
create	mods/behaviour_tree_node.hpp	/^		static child_node_t create(callback_t& c,node_type_t n_type,children_t& ch){$/;"	f	struct:mods::behaviour_tree_node
create	mods/behaviour_tree_node.hpp	/^		static child_node_t create(node_type_t n_type){$/;"	f	struct:mods::behaviour_tree_node
create	mods/drone.cpp	/^	 char_data* drone::create(char_data* owner) {$/;"	f	class:mods::drone
create	mods/events.cpp	/^			void create(uuid_t uuid){$/;"	f	namespace:mods::events::publish::objects
create	mods/events.cpp	/^			void create(uuid_t uuid){$/;"	f	namespace:mods::events::publish::players
create	mods/sql.hpp	/^			compositor<T>& create() {$/;"	f	struct:mods::sql::compositor
create_direction	mods/builder.cpp	/^	bool create_direction(room_rnum room_id,byte direction,room_rnum to_room) {$/;"	f	namespace:mods::builder
create_entry	db.cpp	/^int create_entry(const char *name) {$/;"	f
create_leaf	mods/behaviour_tree_node.hpp	/^		static child_node_t create_leaf(callback_t c){$/;"	f	struct:mods::behaviour_tree_node
create_money	handler.cpp	/^obj_ptr_t create_money(int amount) {$/;"	f
create_muted_player_target	mods/player-scaffolding.cpp	/^	player_ptr_t player_scaffolding::create_muted_player_target() {$/;"	f	class:mods::player_scaffolding
create_object	db.cpp	/^obj_ptr_t create_object(int type,std::string yaml_file) {$/;"	f
create_object_from_index	db.cpp	/^obj_ptr_t create_object_from_index(std::size_t proto_index){$/;"	f
create_player	mods/player-scaffolding.cpp	/^	player_ptr_t player_scaffolding::create_player() {$/;"	f	class:mods::player_scaffolding
create_selector	mods/behaviour_tree_node.hpp	/^		static child_node_t create_selector(const children_t& ch){$/;"	f	struct:mods::behaviour_tree_node
create_sequence	mods/behaviour_tree_node.hpp	/^		static child_node_t create_sequence(const children_t& ch){$/;"	f	struct:mods::behaviour_tree_node
create_shop_from_index	db.cpp	/^shop_ptr_t create_shop_from_index(std::size_t proto_index){$/;"	f
credits	db.cpp	/^char *credits = NULL;		\/* game credits			 *\/$/;"	v
crit	mods/values.hpp	/^			static inline void crit(T& p){$/;"	f	namespace:mods::values::msg
critical_chance	mods/weapon.hpp	/^			float critical_chance;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
critical_range	mods/weapon.hpp	/^			int critical_range;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
cron	mods/cron.hpp	/^			cron(uint64_t tick_resolution) : m_tres(tick_resolution) {$/;"	f	class:mods::cron
cron	mods/cron.hpp	/^	class cron {$/;"	c	namespace:mods
cryogenicist	objsave.cpp	/^SPECIAL(cryogenicist);$/;"	v
cryogenicist	spec_assign.cpp	/^SPECIAL(cryogenicist);$/;"	v
crypto	mods/crypto.cpp	/^namespace mods::crypto {$/;"	n	class:mods	file:
crypto	mods/crypto.hpp	/^namespace mods::crypto {$/;"	n	class:mods
ctypes	act.informative.cpp	/^const char *ctypes[] = {$/;"	v
current_block	mods/player.cpp	/^	uint32_t player::current_block(){$/;"	f	class:mods::player
current_key	mods/quests.cpp	/^		std::string current_key(char_data* ch) {$/;"	f	namespace:mods::quests
current_player	globals.cpp	/^		player_ptr_t current_player;$/;"	m	namespace:mods::globals	file:
current_quest	mods/quests.cpp	/^		std::string current_quest(char_data *ch) {$/;"	f	namespace:mods::quests
current_value	mods/quests.cpp	/^		std::string current_value(room_rnum room,int t_index) {$/;"	f	namespace:mods::quests
current_working_dir	mods/js.cpp	/^			std::string current_working_dir(){$/;"	f	namespace:mods::js
current_working_dir	mods/yaml.hpp	/^			static inline std::string current_working_dir(){$/;"	f	namespace:mods::yaml
customer_string	shop.cpp	/^char *customer_string(int shop_nr, int detailed) {$/;"	f
d	globals.hpp	68;"	d
d	globals.hpp	71;"	d
d	structs.h	41;"	d
d	structs.h	44;"	d
dam_message	fight.cpp	/^void dam_message(int dam, char_data *ch, char_data *victim,$/;"	f
damage	fight.cpp	/^int damage(char_data *ch, char_data *victim, int dam, int attacktype) {$/;"	f
damage	mods/weapon-types.hpp	/^		weapon_damage_t damage;$/;"	m	struct:mods::weapon::weapon_type_statistics_t
damage	mods/yaml.hpp	/^		int damage;$/;"	m	struct:mods::yaml::drone_description_t
damage	mods/yaml.hpp	/^		int damage;$/;"	m	struct:mods::yaml::explosive_description_t
damage_map	mods/weapon.hpp	/^			std::array<float,MAX_ROOM_DISTANCE> damage_map;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
damage_map	mods/yaml.hpp	/^			std::array<float,MAX_ROOM_DISTANCE> damage_map;	\/** Percent per room *\/$/;"	m	struct:mods::yaml::rifle_description_t
damage_per_second	mods/weapon.hpp	/^			int damage_per_second;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
damroll	mods/player.hpp	/^		sbyte& damroll() {$/;"	f	struct:mods::player
data	shop.h	/^	int data[100];$/;"	m	struct:stack_data
data_block_type	mail.h	/^typedef struct data_block_type_d data_block_type;$/;"	t	typeref:struct:data_block_type_d
data_block_type_d	mail.h	/^struct data_block_type_d {$/;"	s
date	db.h	/^	time_t date;$/;"	m	struct:ban_list_element
date_time	mods/date-time.cpp	/^namespace mods::date_time {$/;"	n	class:mods	file:
date_time	mods/date-time.hpp	/^namespace mods::date_time {$/;"	n	class:mods
date_to_string	mods/date-time.cpp	/^		std::string date_to_string(){$/;"	f	namespace:mods::date_time::irl
day	mods/date-time.cpp	/^	static uint8_t day;$/;"	m	namespace:mods::date_time	file:
db	db.cpp	/^namespace db {$/;"	n	file:
db	db.h	/^namespace db {$/;"	n
db	db.h	/^namespace mods::db { $/;"	n	class:mods
db	globals.cpp	/^		std::unique_ptr<lmdb_db> db;$/;"	m	namespace:mods::globals	file:
db	mods/db.cpp	/^namespace mods::db {$/;"	n	class:mods	file:
db	mods/db.hpp	/^namespace mods::db{$/;"	n	class:mods
db	mods/schema.hpp	/^	static schema_list_t db = {$/;"	m	namespace:mods::schema
db_commit	mods/js.cpp	/^		static duk_ret_t db_commit(duk_context *ctx) {$/;"	f	namespace:mods::js
db_get	mods/js.cpp	/^		static duk_ret_t db_get(duk_context *ctx) {$/;"	f	namespace:mods::js
db_get	mods/lmdb.cpp	/^std::string db_get(std::string key){$/;"	f
db_get_all	mods/lmdb.cpp	/^mods::pq::result db_get_all(std::string table){$/;"	f
db_get_all_pluck	mods/lmdb.cpp	/^auto db_get_all_pluck(std::string table,const std::vector<std::string>& pluck){$/;"	f
db_get_by_meta	mods/lmdb.cpp	/^pqxx::result db_get_by_meta(std::string table, std::string col,const pqxx::result::reference & value){$/;"	f
db_get_by_meta	mods/lmdb.cpp	/^pqxx::result db_get_by_meta(std::string table, std::string col,const std::string & value){$/;"	f
db_get_by_meta_multi	mods/lmdb.hpp	/^pqxx::result db_get_by_meta_multi(std::string table, std::string col,const TIDListContainer& values){$/;"	f
db_geti	mods/js.cpp	/^		static duk_ret_t db_geti(duk_context *ctx) {$/;"	f	namespace:mods::js
db_has_been_booted	db.cpp	/^bool db_has_been_booted = false;$/;"	v
db_id	mods/player.hpp	/^		aligned_int_t db_id() const { return m_db_id; }$/;"	f	struct:mods::player
db_id	mods/yaml.cpp	/^	uint64_t armor_description_t::db_id(){$/;"	f	class:mods::yaml::armor_description_t
db_id	mods/yaml.cpp	/^	uint64_t attachment_description_t::db_id(){$/;"	f	class:mods::yaml::attachment_description_t
db_id	mods/yaml.cpp	/^	uint64_t consumable_description_t::db_id(){$/;"	f	class:mods::yaml::consumable_description_t
db_id	mods/yaml.cpp	/^	uint64_t drone_description_t::db_id(){$/;"	f	class:mods::yaml::drone_description_t
db_id	mods/yaml.cpp	/^	uint64_t explosive_description_t::db_id(){$/;"	f	class:mods::yaml::explosive_description_t
db_id	mods/yaml.cpp	/^	uint64_t gadget_description_t::db_id(){$/;"	f	class:mods::yaml::gadget_description_t
db_id	mods/yaml.cpp	/^	uint64_t rifle_description_t::db_id(){$/;"	f	class:mods::yaml::rifle_description_t
db_id	mods/yaml.cpp	/^	uint64_t trap_description_t::db_id(){$/;"	f	class:mods::yaml::trap_description_t
db_id	structs.h	/^		uint64_t db_id(){ return this->m_db_id; }$/;"	f	struct:obj_data
db_id_to_uuid_map	globals.cpp	/^		std::map<uint64_t,uuid_t> db_id_to_uuid_map;$/;"	m	namespace:mods::globals	file:
db_key	mods/lmdb.cpp	/^std::string db_key(const std::vector<std::string> & parts){$/;"	f
db_meta_array_values	mods/schema.hpp	/^	static schema_list_t db_meta_array_values = {$/;"	m	namespace:mods::schema
db_meta_values	mods/schema.hpp	/^	static schema_list_t db_meta_values = {$/;"	m	namespace:mods::schema
db_put	mods/lmdb.cpp	/^void db_put(std::string key,std::string value){$/;"	f
db_renew_txn	mods/js.cpp	/^		static duk_ret_t db_renew_txn(duk_context *ctx) {$/;"	f	namespace:mods::js
db_renew_txn	mods/lmdb.cpp	/^void db_renew_txn(){$/;"	f
db_set	mods/js.cpp	/^		static duk_ret_t db_set(duk_context *ctx) {$/;"	f	namespace:mods::js
db_seti	mods/js.cpp	/^		static duk_ret_t db_seti(duk_context *ctx) {$/;"	f	namespace:mods::js
dbg_print	mods/quests.cpp	3;"	d	file:
deactivate_account	mods/player.cpp	/^	void player::deactivate_account(){$/;"	f	class:mods::player
death_cry	fight.cpp	/^void death_cry(char_data *ch) {$/;"	f
debug	mods/db.hpp	10;"	d
debug	mods/db.hpp	8;"	d
debug	mods/debug.cpp	/^namespace mods::debug {$/;"	n	class:mods	file:
debug	mods/debug.hpp	/^namespace mods::debug {$/;"	n	class:mods
debug_echo	mods/yaml.cpp	12;"	d	file:
debug_state	mods/debug.cpp	/^	std::unique_ptr<state> debug_state;$/;"	m	namespace:mods::debug	file:
decomposedExpression	mods/catch.hpp	/^		mutable DecomposedExpression const* decomposedExpression;$/;"	m	struct:Catch::AssertionResultData
decorate_authenticated_player	db.cpp	/^void decorate_authenticated_player(player_ptr_t player_ptr){$/;"	f
decrypt	mods/crypto.cpp	/^int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key,$/;"	f	namespace:mods::crypto
decrypt_buffer	mods/crypto.cpp	/^	std::string decrypt_buffer(std::string_view in_ciphertext,std::string_view in_key,std::string in_iv,std::string buffer){$/;"	f	namespace:mods::crypto
default_yaml_file	structs.cpp	/^static inline std::string default_yaml_file(const std::string& type){$/;"	f	file:
defer_queue	globals.cpp	/^		std::unique_ptr<mods::deferred> defer_queue;$/;"	m	namespace:mods::globals	file:
deferred	mods/deferred.hpp	/^			deferred(uint64_t tick_resolution) : $/;"	f	class:mods::deferred
deferred	mods/deferred.hpp	/^	class deferred {$/;"	c	namespace:mods
definition	mods/sql.hpp	/^			compositor<T>& definition(const std::vector<std::string>& members) {$/;"	f	struct:mods::sql::compositor
del	mods/lmdb.cpp	/^	int _db_handle::del(std::string key){$/;"	f	class:mods::lmdb::_db_handle
del	mods/sql.hpp	/^			compositor<T>& del() {$/;"	f	struct:mods::sql::compositor
del_affected_by	mods/player.hpp	/^		std::vector<affected_type>& del_affected_by(const affected_type& af){$/;"	f	struct:mods::player
del_affected_by	mods/player.hpp	/^		std::vector<affected_type>& del_affected_by(const std::size_t& idx){$/;"	f	struct:mods::player
deleteAll	mods/catch.hpp	/^	inline void deleteAll(ContainerT& container) {$/;"	f	namespace:Catch
deleteAllValues	mods/catch.hpp	/^	inline void deleteAllValues(AssociativeContainerT& container) {$/;"	f	namespace:Catch
delete_aliases	alias.cpp	/^void delete_aliases(const char *charname) {$/;"	f
delete_doubledollar	interpreter.cpp	/^char *delete_doubledollar(char *string) {$/;"	f
delete_zone	mods/builder.cpp	/^	bool delete_zone(int id) {$/;"	f	namespace:mods::builder
demolitions	mods/skills.hpp	/^		static std::vector<proficiency_t> demolitions = {$/;"	m	namespace:mods::skills::proficiencies
deregister_player	comm.cpp	/^void deregister_player(player_ptr_t player_obj){$/;"	f
desc	mods/player.cpp	/^	descriptor_data& player::desc(){ $/;"	f	class:mods::player
description	mods/aoe.hpp	/^	static inline std::string description(const types_t& type) {$/;"	f	namespace:mods::aoe
description	mods/builder.cpp	/^	bool description(room_rnum room_id,std::string_view str_description) {$/;"	f	namespace:mods::builder
description	mods/catch.hpp	/^		const char* description;$/;"	m	struct:Catch::NameAndDesc
description	mods/extra_desc_data.hpp	/^		mods::string description;$/;"	m	struct:mods::extra_desc_data
description	mods/player.hpp	/^		mods::string& description(){$/;"	f	struct:mods::player
description	mods/skills.hpp	/^			mods::string description;$/;"	m	struct:mods::skills::proficiencies::proficiency_t
description	shop.h	/^	mods::string description;$/;"	m	struct:shop_data
description	structs.h	/^		mods::string	description;           \/* Shown when entered                 *\/$/;"	v
description	structs.h	/^		mods::string description;		  \/* When in room                     *\/$/;"	m	struct:obj_data
description	structs.h	/^		mods::string description;             \/* What to see                      *\/$/;"	m	struct:extra_descr_data
desert_eagle	mods/weapon.cpp	/^	obj_data_ptr_t desert_eagle(){$/;"	f	namespace:mods::weapon
destroy	mods/events.cpp	/^			void destroy(uuid_t uuid){$/;"	f	namespace:mods::events::publish::objects
destroy	mods/events.cpp	/^			void destroy(uuid_t uuid){$/;"	f	namespace:mods::events::publish::players
destroy_db	db.cpp	/^void destroy_db(void) {$/;"	f
destroy_direction	mods/builder.cpp	/^	bool destroy_direction(room_rnum room_id,int direction) {$/;"	f	namespace:mods::builder
destroy_player	comm.cpp	/^int destroy_player(player_ptr_t player){$/;"	f
destroy_shops	shop.cpp	/^void destroy_shops(void) {$/;"	f
destroy_socket	comm.cpp	/^void destroy_socket(socket_t sock_fd){$/;"	f
destruct_now	mods/camera.cpp	/^	void camera::destruct_now() {$/;"	f	class:mods::camera
destruct_object	globals.cpp	/^		void destruct_object(uuid_t uuid){$/;"	f	namespace:mods::globals
detail	mods/util.hpp	/^namespace detail{ $/;"	n	namespace:mods::util
detexturize_room	mods/deferred.cpp	/^	void deferred::detexturize_room(uint64_t ticks_in_future,room_rnum room_id,room_data::texture_type_t texture){$/;"	f	class:mods::deferred
detexturize_room	mods/util.hpp	/^	static inline void detexturize_room(room_rnum room_id, room_data::texture_type_t texture_type){$/;"	f	namespace:mods::util
dex_app	constants.cpp	/^cpp_extern const struct dex_app_type dex_app[] = {$/;"	v	typeref:struct:dex_app_type
dex_app	constants.hpp	/^cpp_extern const struct dex_app_type dex_app[] = {$/;"	v	typeref:struct:dex_app_type
dex_app_skill	constants.cpp	/^cpp_extern const struct dex_skill_type dex_app_skill[] = {$/;"	v	typeref:struct:dex_skill_type
dex_app_skill	constants.hpp	/^cpp_extern const struct dex_skill_type dex_app_skill[] = {$/;"	v	typeref:struct:dex_skill_type
diag_char_to_char	act.informative.cpp	/^void diag_char_to_char(char_data *i, char_data *ch) {$/;"	f
dice	mods/rand.cpp	/^int dice(int num, int size) {$/;"	f
dice_sides_index	mods/rand.hpp	/^	static constexpr uint8_t dice_sides_index[] = {$/;"	m	namespace:mods::rand
die	fight.cpp	/^void die(char_data *ch) {$/;"	f
die	fight.cpp	/^void die(char_data* killer,char_data *victim) {$/;"	f
die_follower	utils.cpp	/^void die_follower(char_data *ch) {$/;"	f
dir	graph.cpp	/^	char dir;$/;"	m	struct:bfs_queue_struct	file:
dir	mods/util.hpp	/^		int dir;$/;"	m	struct:mods::util::objdir_struct
dir_exists	mods/util.cpp	/^	bool dir_exists(const char* dir){$/;"	f	namespace:mods::util
dir_int	globals.cpp	/^		int dir_int(char dir) {$/;"	f	namespace:mods::globals
dir_option	mods/builder.cpp	/^	std::optional<std::string> dir_option(room_rnum room_id,int direction,std::optional<std::string_view> description,$/;"	f	namespace:mods::builder
dir_option	structs.h	/^		room_direction_data *dir_option[NUM_OF_DIRS]; \/* Directions *\/$/;"	v
dir_to_str	globals.cpp	/^		std::string dir_to_str(int dir, bool adjective){$/;"	f	namespace:mods::globals
direction	mods/scan.hpp	/^			int direction;$/;"	m	struct:mods::scan::find_results_t
direction	mods/scan.hpp	/^			uint8_t direction;$/;"	m	struct:mods::scan::__anon4
directional_dirstr	mods/doors.hpp	/^	static inline std::string directional_dirstr(const int & direction){$/;"	f	namespace:mods::doors
directions	mods/scan.cpp	/^	int directions[] = { NORTH,EAST,SOUTH,WEST,UP,DOWN };$/;"	m	namespace:mods::scan	file:
directions	structs.cpp	/^		const std::vector<uint8_t>& room_data::directions() const {$/;"	f	class:room_data
dirs	constants.cpp	/^const char *dirs[] = {$/;"	v
dirs	constants.hpp	/^const char *dirs[] =$/;"	v
dirstr	mods/doors.hpp	/^	static inline std::string dirstr(const int & direction){$/;"	f	namespace:mods::doors
disable_all_zone_resets	db.cpp	/^bool disable_all_zone_resets = false;$/;"	v
disable_electronics	mods/projectile.cpp	/^		void disable_electronics(room_rnum room){$/;"	f	namespace:mods::projectile
disable_zone_resets	mods/builder.cpp	/^void disable_zone_resets(){$/;"	f
discrete_load	db.cpp	/^void discrete_load(FILE *fl, int mode, char *filename) {$/;"	f
disorient_amount	mods/weapon.hpp	/^			int disorient_amount;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
disorient_clears_up	mods/projectile.cpp	/^		void disorient_clears_up(player_ptr_t victim){$/;"	f	namespace:mods::projectile
disorient_person	mods/projectile.cpp	/^		void disorient_person(player_ptr_t victim){$/;"	f	namespace:mods::projectile
disorient_target	mods/projectile.cpp	/^		void disorient_target(player_ptr_t player){$/;"	f	namespace:mods::projectile
dispatch	mods/ai_state.cpp	/^	uint32_t ai_state::dispatch(char_data* ch) {$/;"	f	class:mods::ai_state
dispatch	mods/behaviour_tree_impl.cpp	/^	int8_t dispatch(uuid_t mob_uuid){$/;"	f	namespace:mods::behaviour_tree_impl
dispatch_ptr	mods/behaviour_tree_impl.cpp	/^	int8_t dispatch_ptr(argument_type& ch){$/;"	f	namespace:mods::behaviour_tree_impl
dispatch_status_t	mods/behaviour_tree_impl.hpp	/^		enum dispatch_status_t {$/;"	g	namespace:mods::behaviour_tree_impl
dispose_breach	mods/doors.hpp	/^	static inline void dispose_breach(uuid_t obj_uuid){$/;"	f	namespace:mods::doors
dispose_object	globals.cpp	/^		void dispose_object(uuid_t obj_uuid){$/;"	f	namespace:mods::globals
dispose_player	globals.cpp	/^		void dispose_player(uuid_t pl_uuid){$/;"	f	namespace:mods::globals
dissolver	mods/affects.hpp	/^			dissolver() {$/;"	f	struct:mods::affects::dissolver
dissolver	mods/affects.hpp	/^			dissolver(TAffectsContainer affects){$/;"	f	struct:mods::affects::dissolver
dissolver	mods/affects.hpp	/^			dissolver(TAffectsMap affects){$/;"	f	struct:mods::affects::dissolver
dissolver	mods/affects.hpp	/^		struct dissolver {$/;"	s	namespace:mods::affects
dissolver_queue	globals.cpp	/^		std::set<player_ptr_t> dissolver_queue;$/;"	m	namespace:mods::globals	file:
distance	mods/scan.hpp	/^			uint16_t distance;$/;"	m	struct:mods::scan::__anon4
distance	mods/scan.hpp	/^			uint16_t distance;$/;"	m	struct:mods::scan::find_results_t
distance_cache	mods/scan.cpp	/^	static std::map<std::pair<room_rnum,room_rnum>,distance_t> distance_cache;$/;"	m	namespace:mods::scan	file:
distance_to	mods/scan.cpp	/^	std::tuple<bool,distance_t> distance_to(chptr player_hunter,chptr player_hunted){$/;"	f	namespace:mods::scan
do_action	act.informative.cpp	/^ACMD(do_action);$/;"	v
do_action	act.social.cpp	/^ACMD(do_action);$/;"	v
do_action	interpreter.cpp	/^ACMD(do_action);$/;"	v
do_action	mobact.cpp	/^ACMD(do_action);$/;"	v
do_action	objsave.cpp	/^ACMD(do_action);$/;"	v
do_action	shop.cpp	/^ACMD(do_action);$/;"	v
do_action	spec_procs.cpp	/^ACMD(do_action);$/;"	v
do_advance	act.wizard.cpp	/^ACMD(do_advance);$/;"	v
do_advance	interpreter.cpp	/^ACMD(do_advance);$/;"	v
do_affect_me	interpreter.cpp	/^ACMD(do_affect_me);$/;"	v
do_alias	interpreter.cpp	/^ACMD(do_alias);$/;"	v
do_assist	interpreter.cpp	/^ACMD(do_assist);$/;"	v
do_at	act.wizard.cpp	/^ACMD(do_at);$/;"	v
do_at	interpreter.cpp	/^ACMD(do_at);$/;"	v
do_auto_exits	act.informative.cpp	/^void do_auto_exits(char_data *ch) {$/;"	f
do_backstab	interpreter.cpp	/^ACMD(do_backstab);$/;"	v
do_ban	ban.cpp	/^ACMD(do_ban);$/;"	v
do_ban	interpreter.cpp	/^ACMD(do_ban);$/;"	v
do_bash	interpreter.cpp	/^ACMD(do_bash);$/;"	v
do_breach	interpreter.cpp	/^ACMD(do_breach);$/;"	v
do_buy	interpreter.cpp	/^ACMD(do_buy);	\/** in shop.cpp *\/$/;"	v
do_cancel	interpreter.cpp	/^ACMD(do_cancel);$/;"	v
do_cast	interpreter.cpp	/^ACMD(do_cast);$/;"	v
do_cast	spell_parser.cpp	/^ACMD(do_cast);$/;"	v
do_chanmgr	interpreter.cpp	/^ACMD(do_chanmgr);$/;"	v
do_color	act.informative.cpp	/^ACMD(do_color);$/;"	v
do_color	interpreter.cpp	/^ACMD(do_color);$/;"	v
do_commands	act.informative.cpp	/^ACMD(do_commands);$/;"	v
do_commands	interpreter.cpp	/^ACMD(do_commands);$/;"	v
do_consider	act.informative.cpp	/^ACMD(do_consider);$/;"	v
do_consider	interpreter.cpp	/^ACMD(do_consider);$/;"	v
do_credits	interpreter.cpp	/^ACMD(do_credits);$/;"	v
do_critical_roll	mods/injure.cpp	/^	bool do_critical_roll(int chance){$/;"	f	namespace:mods::injure
do_date	act.wizard.cpp	/^ACMD(do_date);$/;"	v
do_date	interpreter.cpp	/^ACMD(do_date);$/;"	v
do_dc	act.wizard.cpp	/^ACMD(do_dc);$/;"	v
do_dc	interpreter.cpp	/^ACMD(do_dc);$/;"	v
do_diagnose	act.informative.cpp	/^ACMD(do_diagnose);$/;"	v
do_diagnose	interpreter.cpp	/^ACMD(do_diagnose);$/;"	v
do_display	act.other.cpp	/^ACMD(do_display);$/;"	v
do_display	interpreter.cpp	/^ACMD(do_display);$/;"	v
do_doorcmd	act.movement.cpp	/^	void do_doorcmd(char_data *ch, struct obj_data *obj, int door, int scmd) {$/;"	f
do_drink	act.item.cpp	/^ACMD(do_drink);$/;"	v
do_drink	interpreter.cpp	/^ACMD(do_drink);$/;"	v
do_drone	act.informative.cpp	/^ACMD(do_drone);	\/*!mods*\/$/;"	v
do_drone	interpreter.cpp	/^ACMD(do_drone);$/;"	v
do_drop	act.item.cpp	/^ACMD(do_drop);$/;"	v
do_drop	interpreter.cpp	/^ACMD(do_drop);$/;"	v
do_drop	spec_procs.cpp	/^ACMD(do_drop);$/;"	v
do_eat	act.item.cpp	/^ACMD(do_eat);$/;"	v
do_eat	interpreter.cpp	/^ACMD(do_eat);$/;"	v
do_echo	act.wizard.cpp	/^ACMD(do_echo);$/;"	v
do_echo	interpreter.cpp	/^ACMD(do_echo);$/;"	v
do_echo	shop.cpp	/^ACMD(do_echo);$/;"	v
do_enter	act.movement.cpp	/^ACMD(do_enter);$/;"	v
do_enter	interpreter.cpp	/^ACMD(do_enter);$/;"	v
do_equipment	act.informative.cpp	/^ACMD(do_equipment);$/;"	v
do_equipment	interpreter.cpp	/^ACMD(do_equipment);$/;"	v
do_examine	act.informative.cpp	/^ACMD(do_examine);$/;"	v
do_examine	interpreter.cpp	/^ACMD(do_examine);$/;"	v
do_exit	interpreter.cpp	/^ACMD(do_exit);$/;"	v
do_exits	act.informative.cpp	/^ACMD(do_exits);$/;"	v
do_exits	interpreter.cpp	/^ACMD(do_exits);$/;"	v
do_feed_player	interpreter.cpp	/^ACMD(do_feed_player);$/;"	v
do_flee	fight.cpp	/^ACMD(do_flee);$/;"	v
do_flee	interpreter.cpp	/^ACMD(do_flee);$/;"	v
do_flush_holding	interpreter.cpp	/^ACMD(do_flush_holding);$/;"	v
do_flush_player	interpreter.cpp	/^ACMD(do_flush_player);$/;"	v
do_follow	act.movement.cpp	/^ACMD(do_follow);$/;"	v
do_follow	castle.cpp	/^ACMD(do_follow);$/;"	v
do_follow	interpreter.cpp	/^ACMD(do_follow);$/;"	v
do_force	act.wizard.cpp	/^ACMD(do_force);$/;"	v
do_force	interpreter.cpp	/^ACMD(do_force);$/;"	v
do_gecho	act.wizard.cpp	/^ACMD(do_gecho);$/;"	v
do_gecho	interpreter.cpp	/^ACMD(do_gecho);$/;"	v
do_gen_comm	act.comm.cpp	/^ACMD(do_gen_comm);$/;"	v
do_gen_comm	act.other.cpp	/^ACMD(do_gen_comm);$/;"	v
do_gen_comm	interpreter.cpp	/^ACMD(do_gen_comm);$/;"	v
do_gen_door	act.movement.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_door	castle.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_door	interpreter.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_door	spec_procs.cpp	/^ACMD(do_gen_door);$/;"	v
do_gen_ps	act.informative.cpp	/^ACMD(do_gen_ps);$/;"	v
do_gen_ps	interpreter.cpp	/^ACMD(do_gen_ps);$/;"	v
do_gen_tog	act.other.cpp	/^ACMD(do_gen_tog);$/;"	v
do_gen_tog	interpreter.cpp	/^ACMD(do_gen_tog);$/;"	v
do_gen_write	act.other.cpp	/^ACMD(do_gen_write);$/;"	v
do_gen_write	interpreter.cpp	/^ACMD(do_gen_write);$/;"	v
do_get	act.item.cpp	/^ACMD(do_get);$/;"	v
do_get	interpreter.cpp	/^ACMD(do_get);$/;"	v
do_get	mobact.cpp	/^ACMD(do_get);$/;"	v
do_get_ticks_per_minute	interpreter.cpp	/^ACMD(do_get_ticks_per_minute);$/;"	v
do_give	act.item.cpp	/^ACMD(do_give);$/;"	v
do_give	interpreter.cpp	/^ACMD(do_give);$/;"	v
do_giveme_camera	interpreter.cpp	/^ACMD(do_giveme_camera);$/;"	v
do_giveme_emp_grenades	interpreter.cpp	/^ACMD(do_giveme_emp_grenades);$/;"	v
do_giveme_flashbang_grenades	interpreter.cpp	/^ACMD(do_giveme_flashbang_grenades);$/;"	v
do_giveme_frag_grenades	interpreter.cpp	/^ACMD(do_giveme_frag_grenades);$/;"	v
do_giveme_incendiary_grenades	interpreter.cpp	/^ACMD(do_giveme_incendiary_grenades);$/;"	v
do_giveme_night_vision_camera	interpreter.cpp	/^ACMD(do_giveme_night_vision_camera);$/;"	v
do_giveme_sensor_grenades	interpreter.cpp	/^ACMD(do_giveme_sensor_grenades);$/;"	v
do_giveme_smoke_grenades	interpreter.cpp	/^ACMD(do_giveme_smoke_grenades);$/;"	v
do_giveme_sniper_rifle	interpreter.cpp	/^ACMD(do_giveme_sniper_rifle);$/;"	v
do_giveme_thermal_camera	interpreter.cpp	/^ACMD(do_giveme_thermal_camera);$/;"	v
do_givemegold	act.informative.cpp	/^ACMD(do_givemegold); \/*!mods*\/$/;"	v
do_givemegold	interpreter.cpp	/^ACMD(do_givemegold);$/;"	v
do_givemenades	act.debug.hpp	/^ACMD(do_givemenades);$/;"	v
do_givemenades	interpreter.cpp	/^ACMD(do_givemenades);$/;"	v
do_gold	act.informative.cpp	/^ACMD(do_gold);$/;"	v
do_gold	interpreter.cpp	/^ACMD(do_gold);$/;"	v
do_goto	act.wizard.cpp	/^ACMD(do_goto);$/;"	v
do_goto	interpreter.cpp	/^ACMD(do_goto);$/;"	v
do_grab	act.item.cpp	/^ACMD(do_grab);$/;"	v
do_grab	interpreter.cpp	/^ACMD(do_grab);$/;"	v
do_group	act.other.cpp	/^ACMD(do_group);$/;"	v
do_group	interpreter.cpp	/^ACMD(do_group);$/;"	v
do_gsay	act.comm.cpp	/^ACMD(do_gsay);$/;"	v
do_gsay	interpreter.cpp	/^ACMD(do_gsay);$/;"	v
do_hcontrol	house.cpp	/^ACMD(do_hcontrol);$/;"	v
do_hcontrol	interpreter.cpp	/^ACMD(do_hcontrol);$/;"	v
do_heal	interpreter.cpp	/^ACMD(do_heal);$/;"	v
do_help	act.informative.cpp	/^ACMD(do_help);$/;"	v
do_help	interpreter.cpp	/^ACMD(do_help);$/;"	v
do_help_throw	interpreter.cpp	/^ACMD(do_help_throw);$/;"	v
do_hide	act.other.cpp	/^ACMD(do_hide);$/;"	v
do_hide	interpreter.cpp	/^ACMD(do_hide);$/;"	v
do_histfile	interpreter.cpp	/^ACMD(do_histfile);$/;"	v
do_hit	interpreter.cpp	/^ACMD(do_hit);$/;"	v
do_hold_anything	interpreter.cpp	/^ACMD(do_hold_anything);$/;"	v
do_house	house.cpp	/^ACMD(do_house);$/;"	v
do_house	interpreter.cpp	/^ACMD(do_house);$/;"	v
do_idle	interpreter.cpp	/^ACMD(do_idle);$/;"	v
do_injure_roll	mods/injure.cpp	/^	bool do_injure_roll(uint8_t chance){$/;"	f	namespace:mods::injure
do_install	interpreter.cpp	/^ACMD(do_install);$/;"	v
do_insult	act.informative.cpp	/^ACMD(do_insult);$/;"	v
do_insult	act.social.cpp	/^ACMD(do_insult);$/;"	v
do_insult	interpreter.cpp	/^ACMD(do_insult);$/;"	v
do_inventory	act.informative.cpp	/^ACMD(do_inventory);$/;"	v
do_inventory	interpreter.cpp	/^ACMD(do_inventory);$/;"	v
do_invis	act.wizard.cpp	/^ACMD(do_invis);$/;"	v
do_invis	interpreter.cpp	/^ACMD(do_invis);$/;"	v
do_js	act.informative.cpp	/^ACMD(do_js);	\/*!mods*\/$/;"	v
do_js	interpreter.cpp	/^ACMD(do_js);$/;"	v
do_jstest	interpreter.cpp	/^ACMD(do_jstest);$/;"	v
do_kick	interpreter.cpp	/^ACMD(do_kick);$/;"	v
do_kill	interpreter.cpp	/^ACMD(do_kill);$/;"	v
do_kill_now	interpreter.cpp	/^ACMD(do_kill_now);$/;"	v
do_last	act.wizard.cpp	/^ACMD(do_last);$/;"	v
do_last	interpreter.cpp	/^ACMD(do_last);$/;"	v
do_leave	act.movement.cpp	/^ACMD(do_leave);$/;"	v
do_leave	interpreter.cpp	/^ACMD(do_leave);$/;"	v
do_levels	act.informative.cpp	/^ACMD(do_levels);$/;"	v
do_levels	interpreter.cpp	/^ACMD(do_levels);$/;"	v
do_list	interpreter.cpp	/^ACMD(do_list);	\/** in shop.cpp *\/$/;"	v
do_load	act.wizard.cpp	/^ACMD(do_load);$/;"	v
do_load	interpreter.cpp	/^ACMD(do_load);$/;"	v
do_look	act.informative.cpp	/^ACMD(do_look);$/;"	v
do_look	interpreter.cpp	/^ACMD(do_look);$/;"	v
do_mbuild	interpreter.cpp	/^ACMD(do_mbuild);$/;"	v
do_move	interpreter.h	/^ACMD(do_move);$/;"	v
do_my_uuid	interpreter.cpp	/^ACMD(do_my_uuid);$/;"	v
do_newjs	interpreter.cpp	/^ACMD(do_newjs);$/;"	v
do_next_mob_number	interpreter.cpp	/^ACMD(do_next_mob_number);$/;"	v
do_next_object_number	interpreter.cpp	/^ACMD(do_next_object_number);$/;"	v
do_next_room_number	interpreter.cpp	/^ACMD(do_next_room_number);$/;"	v
do_not_buy	shop.h	/^	mods::string do_not_buy;		\/* If keeper dosn't buy such things	*\/$/;"	m	struct:shop_data
do_not_here	act.other.cpp	/^ACMD(do_not_here);$/;"	v
do_not_here	interpreter.cpp	/^ACMD(do_not_here);$/;"	v
do_npc_rescue	castle.cpp	/^int do_npc_rescue( char_data *ch,  char_data *ch_victim) {$/;"	f
do_obuild	interpreter.cpp	/^ACMD(do_obuild);$/;"	v
do_olc	interpreter.cpp	/^ACMD(do_olc);$/;"	v
do_olc	olc.cpp	/^ACMD(do_olc);$/;"	v
do_one_punch	interpreter.cpp	/^ACMD(do_one_punch);$/;"	v
do_order	interpreter.cpp	/^ACMD(do_order);$/;"	v
do_page	act.comm.cpp	/^ACMD(do_page);$/;"	v
do_pmw_obj_from_room	interpreter.cpp	/^ACMD(do_pmw_obj_from_room);$/;"	v
do_point_update	act.debug.hpp	/^ACMD(do_point_update);$/;"	v
do_point_update	interpreter.cpp	/^ACMD(do_point_update);$/;"	v
do_poofset	act.wizard.cpp	/^ACMD(do_poofset);$/;"	v
do_poofset	interpreter.cpp	/^ACMD(do_poofset);$/;"	v
do_pour	act.item.cpp	/^ACMD(do_pour);$/;"	v
do_pour	interpreter.cpp	/^ACMD(do_pour);$/;"	v
do_practice	act.other.cpp	/^ACMD(do_practice);$/;"	v
do_practice	interpreter.cpp	/^ACMD(do_practice);$/;"	v
do_pref	interpreter.cpp	/^ACMD(do_pref);$/;"	v
do_pref	mods/prefs.hpp	/^ACMD(do_pref);$/;"	v
do_preferences	act.informative.cpp	/^ACMD(do_preferences); \/*!mods *\/$/;"	v
do_purge	act.wizard.cpp	/^ACMD(do_purge);$/;"	v
do_purge	interpreter.cpp	/^ACMD(do_purge);$/;"	v
do_put	act.item.cpp	/^ACMD(do_put);$/;"	v
do_put	interpreter.cpp	/^ACMD(do_put);$/;"	v
do_qcomm	act.comm.cpp	/^ACMD(do_qcomm);$/;"	v
do_qcomm	interpreter.cpp	/^ACMD(do_qcomm);$/;"	v
do_quest	act.informative.cpp	/^ACMD(do_quest);	\/*!mods*\/$/;"	v
do_quest	interpreter.cpp	/^ACMD(do_quest);$/;"	v
do_quit	act.other.cpp	/^ACMD(do_quit);$/;"	v
do_quit	interpreter.cpp	/^ACMD(do_quit);$/;"	v
do_rbuild	interpreter.cpp	/^ACMD(do_rbuild);$/;"	v
do_rbuild_sandbox	interpreter.cpp	/^ACMD(do_rbuild_sandbox);$/;"	v
do_reboot	db.cpp	/^ACMD(do_reboot);$/;"	v
do_reboot	interpreter.cpp	/^ACMD(do_reboot);$/;"	v
do_recall	act.informative.cpp	/^ACMD(do_recall);	\/*!mods*\/$/;"	v
do_recall	interpreter.cpp	/^ACMD(do_recall);$/;"	v
do_reload	interpreter.cpp	/^ACMD(do_reload);$/;"	v
do_remove	act.item.cpp	/^ACMD(do_remove);$/;"	v
do_remove	interpreter.cpp	/^ACMD(do_remove);$/;"	v
do_reply	act.comm.cpp	/^ACMD(do_reply);$/;"	v
do_reply	interpreter.cpp	/^ACMD(do_reply);$/;"	v
do_report	act.other.cpp	/^ACMD(do_report);$/;"	v
do_report	interpreter.cpp	/^ACMD(do_report);$/;"	v
do_rescue	interpreter.cpp	/^ACMD(do_rescue);$/;"	v
do_rest	act.movement.cpp	/^ACMD(do_rest);$/;"	v
do_rest	interpreter.cpp	/^ACMD(do_rest);$/;"	v
do_restore	act.wizard.cpp	/^ACMD(do_restore);$/;"	v
do_restore	interpreter.cpp	/^ACMD(do_restore);$/;"	v
do_return	act.wizard.cpp	/^ACMD(do_return);$/;"	v
do_return	handler.cpp	/^ACMD(do_return);$/;"	v
do_return	interpreter.cpp	/^ACMD(do_return);$/;"	v
do_revive	interpreter.cpp	/^ACMD(do_revive);$/;"	v
do_rnumlist	interpreter.cpp	/^ACMD(do_rnumlist);$/;"	v
do_rnumlist	mods/immortal.hpp	/^ACMD(do_rnumlist);$/;"	v
do_rnumtele	interpreter.cpp	/^ACMD(do_rnumtele);$/;"	v
do_rnumtele	mods/immortal.hpp	/^ACMD(do_rnumtele);$/;"	v
do_room_dark	interpreter.cpp	/^ACMD(do_room_dark);$/;"	v
do_room_fire	interpreter.cpp	/^ACMD(do_room_fire);$/;"	v
do_room_list	interpreter.cpp	/^ACMD(do_room_list);$/;"	v
do_room_list_uuid	interpreter.cpp	/^ACMD(do_room_list_uuid);$/;"	v
do_save	act.other.cpp	/^ACMD(do_save);$/;"	v
do_save	interpreter.cpp	/^ACMD(do_save);$/;"	v
do_say	act.comm.cpp	/^ACMD(do_say);$/;"	v
do_say	graph.cpp	/^ACMD(do_say);$/;"	v
do_say	interpreter.cpp	/^ACMD(do_say);$/;"	v
do_say	mods/ai_state.cpp	/^EXTERN_ACT(do_say);$/;"	v
do_say	shop.cpp	/^ACMD(do_say);$/;"	v
do_say	spec_procs.cpp	/^ACMD(do_say);$/;"	v
do_sbuild	interpreter.cpp	/^ACMD(do_sbuild);$/;"	v
do_scan	interpreter.cpp	/^ACMD(do_scan);$/;"	v
do_score	act.informative.cpp	/^ACMD(do_score);$/;"	v
do_score	interpreter.cpp	/^ACMD(do_score);$/;"	v
do_send	act.wizard.cpp	/^ACMD(do_send);$/;"	v
do_send	interpreter.cpp	/^ACMD(do_send);$/;"	v
do_send_report	interpreter.cpp	/^ACMD(do_send_report);$/;"	v
do_set	act.wizard.cpp	/^ACMD(do_set);$/;"	v
do_set	interpreter.cpp	/^ACMD(do_set);$/;"	v
do_set_ammo	interpreter.cpp	/^ACMD(do_set_ammo);$/;"	v
do_set_npc_position	interpreter.cpp	/^ACMD(do_set_npc_position);$/;"	v
do_set_position	act.debug.hpp	/^ACMD(do_set_position);$/;"	v
do_set_position	interpreter.cpp	/^ACMD(do_set_position);$/;"	v
do_shoot	interpreter.cpp	/^ACMD(do_shoot);	\/* just an alias of snipe *\/$/;"	v
do_show	act.wizard.cpp	/^ACMD(do_show);$/;"	v
do_show	interpreter.cpp	/^ACMD(do_show);$/;"	v
do_show_tics	interpreter.cpp	/^ACMD(do_show_tics);$/;"	v
do_shutdown	act.wizard.cpp	/^ACMD(do_shutdown);$/;"	v
do_shutdown	interpreter.cpp	/^ACMD(do_shutdown);$/;"	v
do_simple_move	act.movement.cpp	/^int do_simple_move(char_data *ch, int dir, int need_specials_check) {$/;"	f
do_sit	act.movement.cpp	/^ACMD(do_sit);$/;"	v
do_sit	interpreter.cpp	/^ACMD(do_sit);$/;"	v
do_skills	interpreter.cpp	/^ACMD(do_skills);$/;"	v
do_skillset	modify.cpp	/^ACMD(do_skillset);$/;"	v
do_sleep	act.movement.cpp	/^ACMD(do_sleep);$/;"	v
do_sleep	interpreter.cpp	/^ACMD(do_sleep);$/;"	v
do_sneak	act.other.cpp	/^ACMD(do_sneak);$/;"	v
do_sneak	interpreter.cpp	/^ACMD(do_sneak);$/;"	v
do_snipe	interpreter.cpp	/^ACMD(do_snipe);$/;"	v
do_snoop	act.wizard.cpp	/^ACMD(do_snoop);$/;"	v
do_snoop	interpreter.cpp	/^ACMD(do_snoop);$/;"	v
do_spec_comm	act.comm.cpp	/^ACMD(do_spec_comm);$/;"	v
do_spec_comm	interpreter.cpp	/^ACMD(do_spec_comm);$/;"	v
do_split	act.other.cpp	/^ACMD(do_split);$/;"	v
do_split	interpreter.cpp	/^ACMD(do_split);$/;"	v
do_spray	interpreter.cpp	/^ACMD(do_spray);$/;"	v
do_stand	act.movement.cpp	/^ACMD(do_stand);$/;"	v
do_stand	interpreter.cpp	/^ACMD(do_stand);$/;"	v
do_start	class.cpp	/^void do_start(char_data *ch) {$/;"	f
do_stat	act.wizard.cpp	/^ACMD(do_stat);$/;"	v
do_stat	interpreter.cpp	/^ACMD(do_stat);$/;"	v
do_stat_character	act.wizard.cpp	/^void do_stat_character(char_data *ch, char_data *k) {$/;"	f
do_stat_object	act.wizard.cpp	/^void do_stat_object(char_data *ch, struct obj_data *j) {$/;"	f
do_stat_room	act.wizard.cpp	/^void do_stat_room(char_data *ch) {$/;"	f
do_steal	act.other.cpp	/^ACMD(do_steal);$/;"	v
do_steal	interpreter.cpp	/^ACMD(do_steal);$/;"	v
do_switch	act.wizard.cpp	/^ACMD(do_switch);$/;"	v
do_switch	interpreter.cpp	/^ACMD(do_switch);$/;"	v
do_syslog	act.wizard.cpp	/^ACMD(do_syslog);$/;"	v
do_syslog	interpreter.cpp	/^ACMD(do_syslog);$/;"	v
do_teleport	act.wizard.cpp	/^ACMD(do_teleport);$/;"	v
do_teleport	interpreter.cpp	/^ACMD(do_teleport);$/;"	v
do_tell	act.comm.cpp	/^ACMD(do_tell);$/;"	v
do_tell	interpreter.cpp	/^ACMD(do_tell);$/;"	v
do_tell	mods/ai_state.cpp	/^EXTERN_ACT(do_tell);$/;"	v
do_tell	objsave.cpp	/^ACMD(do_tell);$/;"	v
do_tell	shop.cpp	/^ACMD(do_tell);$/;"	v
do_thermite	interpreter.cpp	/^ACMD(do_thermite);$/;"	v
do_throw	interpreter.cpp	/^ACMD(do_throw);$/;"	v
do_time	act.informative.cpp	/^ACMD(do_time);$/;"	v
do_time	interpreter.cpp	/^ACMD(do_time);$/;"	v
do_title	act.other.cpp	/^ACMD(do_title);$/;"	v
do_title	interpreter.cpp	/^ACMD(do_title);$/;"	v
do_toggle	act.informative.cpp	/^ACMD(do_toggle);$/;"	v
do_toggle	interpreter.cpp	/^ACMD(do_toggle);$/;"	v
do_toggle_obj_from_room	interpreter.cpp	/^ACMD(do_toggle_obj_from_room);$/;"	v
do_track	graph.cpp	/^ACMD(do_track);$/;"	v
do_track	interpreter.cpp	/^ACMD(do_track);$/;"	v
do_trans	act.wizard.cpp	/^ACMD(do_trans);$/;"	v
do_trans	interpreter.cpp	/^ACMD(do_trans);$/;"	v
do_unban	ban.cpp	/^ACMD(do_unban);$/;"	v
do_unban	interpreter.cpp	/^ACMD(do_unban);$/;"	v
do_ungroup	act.other.cpp	/^ACMD(do_ungroup);$/;"	v
do_ungroup	interpreter.cpp	/^ACMD(do_ungroup);$/;"	v
do_uninstall	interpreter.cpp	/^ACMD(do_uninstall);$/;"	v
do_use	act.other.cpp	/^ACMD(do_use);$/;"	v
do_use	interpreter.cpp	/^ACMD(do_use);$/;"	v
do_users	act.informative.cpp	/^ACMD(do_users);$/;"	v
do_users	interpreter.cpp	/^ACMD(do_users);$/;"	v
do_uuid	act.debug.hpp	/^ACMD(do_uuid);$/;"	v
do_uuid	interpreter.cpp	/^ACMD(do_uuid);$/;"	v
do_view	interpreter.cpp	/^ACMD(do_view);$/;"	v
do_visible	act.other.cpp	/^ACMD(do_visible);$/;"	v
do_visible	interpreter.cpp	/^ACMD(do_visible);$/;"	v
do_vnum	act.wizard.cpp	/^ACMD(do_vnum);$/;"	v
do_vnum	interpreter.cpp	/^ACMD(do_vnum);$/;"	v
do_vstat	act.wizard.cpp	/^ACMD(do_vstat);$/;"	v
do_vstat	interpreter.cpp	/^ACMD(do_vstat);$/;"	v
do_wake	act.movement.cpp	/^ACMD(do_wake);$/;"	v
do_wake	interpreter.cpp	/^ACMD(do_wake);$/;"	v
do_wear	act.item.cpp	/^ACMD(do_wear);$/;"	v
do_wear	interpreter.cpp	/^ACMD(do_wear);$/;"	v
do_weather	act.informative.cpp	/^ACMD(do_weather);$/;"	v
do_weather	interpreter.cpp	/^ACMD(do_weather);$/;"	v
do_where	act.informative.cpp	/^ACMD(do_where);$/;"	v
do_where	interpreter.cpp	/^ACMD(do_where);$/;"	v
do_who	act.informative.cpp	/^ACMD(do_who);$/;"	v
do_who	interpreter.cpp	/^ACMD(do_who);$/;"	v
do_wield	act.item.cpp	/^ACMD(do_wield);$/;"	v
do_wield	interpreter.cpp	/^ACMD(do_wield);$/;"	v
do_wimpy	act.other.cpp	/^ACMD(do_wimpy);$/;"	v
do_wimpy	interpreter.cpp	/^ACMD(do_wimpy);$/;"	v
do_wiz_quote	interpreter.cpp	/^ACMD(do_wiz_quote);$/;"	v
do_wizlock	act.wizard.cpp	/^ACMD(do_wizlock);$/;"	v
do_wizlock	interpreter.cpp	/^ACMD(do_wizlock);$/;"	v
do_wiznet	act.wizard.cpp	/^ACMD(do_wiznet);$/;"	v
do_wiznet	interpreter.cpp	/^ACMD(do_wiznet);$/;"	v
do_wizutil	act.wizard.cpp	/^ACMD(do_wizutil);$/;"	v
do_wizutil	interpreter.cpp	/^ACMD(do_wizutil);$/;"	v
do_write	act.comm.cpp	/^ACMD(do_write);$/;"	v
do_write	interpreter.cpp	/^ACMD(do_write);$/;"	v
do_yaml_example	interpreter.cpp	/^ACMD(do_yaml_example);$/;"	v
do_yaml_import	interpreter.cpp	/^ACMD(do_yaml_import);$/;"	v
do_yaml_log	interpreter.cpp	/^ACMD(do_yaml_log);$/;"	v
do_yaml_log_clear	interpreter.cpp	/^ACMD(do_yaml_log_clear);$/;"	v
do_yaml_log_save	interpreter.cpp	/^ACMD(do_yaml_log_save);$/;"	v
do_zbuild	interpreter.cpp	/^ACMD(do_zbuild);$/;"	v
do_zero_socket	act.debug.hpp	/^ACMD(do_zero_socket);$/;"	v
do_zero_socket	interpreter.cpp	/^ACMD(do_zero_socket);$/;"	v
do_zreset	act.wizard.cpp	/^ACMD(do_zreset);$/;"	v
do_zreset	interpreter.cpp	/^ACMD(do_zreset);$/;"	v
donation_room_1	config.cpp	/^room_vnum donation_room_1 = 3063;$/;"	v
donation_room_2	config.cpp	/^room_vnum donation_room_2 = NOWHERE;	\/* unused - room for expansion *\/$/;"	v
donation_room_3	config.cpp	/^room_vnum donation_room_3 = NOWHERE;	\/* unused - room for expansion *\/$/;"	v
done	mods/player.cpp	/^	void player::done() {$/;"	f	class:mods::player
door_explosion_event	mods/doors.hpp	/^	static inline void door_explosion_event(uuid_t player_uuid,uuid_t obj_uuid,int direction){$/;"	f	namespace:mods::doors
doors	mods/doors.hpp	/^namespace mods::doors  {$/;"	n	class:mods
dopr	bsd-snprintf.cpp	/^dopr(char *buffer, size_t maxlen, const char *format, va_list args) {$/;"	f	file:
dopr_outch	bsd-snprintf.cpp	/^dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c) {$/;"	f	file:
drink_aff	constants.cpp	/^int drink_aff[][3] = {$/;"	v
drink_aff	constants.hpp	/^int drink_aff[][3] = {$/;"	v
drinknames	constants.cpp	/^const char *drinknames[] = {$/;"	v
drinknames	constants.hpp	/^const char *drinknames[] =$/;"	v
drinks	constants.cpp	/^const char *drinks[] = {$/;"	v
drinks	constants.hpp	/^const char *drinks[] =$/;"	v
drone	mods/drone.cpp	/^	drone::drone(char_data* ch) : m_char_data(ch) { };$/;"	f	class:mods::drone
drone	mods/drone.hpp	/^	class drone {$/;"	c	namespace:mods
drone	mods/item-types.hpp	/^	enum drone {$/;"	g	namespace:mods::weapon::type
drone	mods/weapon.cpp	/^	mw_drone drone(obj_data_ptr_t& object){$/;"	f	namespace:mods::weapon
drone_description_t	mods/yaml.hpp	/^		drone_description_t() :$/;"	f	struct:mods::yaml::drone_description_t
drone_description_t	mods/yaml.hpp	/^	struct drone_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
dts_are_dumps	config.cpp	/^int dts_are_dumps = YES;$/;"	v
duktape_context	globals.cpp	/^		duk_context* duktape_context;$/;"	m	namespace:mods::globals	file:
dummy_mob	db.cpp	/^struct player_special_data dummy_mob;	\/* dummy spec area for mobs	*\/$/;"	v	typeref:struct:player_special_data
dump	mods/util-map.hpp	/^			static inline void dump(std::map<TKey,TVal> m){$/;"	f	namespace:mods::util::maps
dump	spec_assign.cpp	/^SPECIAL(dump);$/;"	v
dump	spec_procs.cpp	/^SPECIAL(dump);$/;"	v
dump_status	mods/lmdb.cpp	/^	void _db_handle::dump_status() const {$/;"	f	class:mods::lmdb::_db_handle
duplicate	db.h	/^	int duplicate;$/;"	m	struct:help_index_element
durability_profile_enum	mods/yaml.hpp	/^		durability_profile_type_t durability_profile_enum;$/;"	m	struct:mods::yaml::armor_description_t
durability_profile_enum	mods/yaml.hpp	/^		durability_profile_type_t durability_profile_enum;$/;"	m	struct:mods::yaml::gadget_description_t
durability_profile_type_t	mods/yaml.hpp	/^enum durability_profile_type_t {$/;"	g	namespace:mods::yaml
dynamic_get	mods/prefs.cpp	/^	std::string prefs::dynamic_get(const std::string& key,const std::string& section,char_data* ch) {$/;"	f	class:mods::prefs
dynamic_namify	mods/prefs.cpp	/^	std::string prefs::dynamic_namify(const std::string& key,const std::string& section,char_data* c) {$/;"	f	class:mods::prefs
dynamic_set	mods/prefs.cpp	/^	void prefs::dynamic_set(const std::string& key,const std::string& value,const std::string& section,char_data* ch) {$/;"	f	class:mods::prefs
e_commit	mods/db.hpp	/^	constexpr static int_status_t e_commit = -2;$/;"	m	namespace:mods::lmdb::error
e_get	mods/db.hpp	/^	constexpr static int_status_t e_get = -3;$/;"	m	namespace:mods::lmdb::error
e_name	mods/skills.hpp	/^			proficiency_name_t e_name;$/;"	m	struct:mods::skills::proficiencies::proficiency_t
e_name_to_proficiency	mods/skills.cpp	/^	static std::map<int,proficiencies::proficiency_t> e_name_to_proficiency;$/;"	m	namespace:mods::skills	file:
e_put	mods/db.hpp	/^	constexpr static int_status_t e_put = -1;$/;"	m	namespace:mods::lmdb::error
echo_off	comm.cpp	/^void echo_off(mods::descriptor_data &d) {$/;"	f
echo_on	comm.cpp	/^void echo_on(mods::descriptor_data &d) {$/;"	f
effective_firing_range	mods/weapon.hpp	/^			int effective_firing_range; \/\/ feet$/;"	m	struct:mods::weapon::yaml::rifle_description_t
eif_debug	mods/projectile.cpp	25;"	d	file:
eif_debug	mods/projectile.cpp	27;"	d	file:
electronics	mods/skills.hpp	/^		static std::vector<proficiency_t> electronics = {$/;"	m	namespace:mods::skills::proficiencies
emergency_unban	comm.cpp	/^byte emergency_unban;		\/* signal: SIGUSR2 *\/$/;"	v
emp_damage	mods/projectile.cpp	/^		void emp_damage(room_rnum& room_id,obj_ptr_t object){$/;"	f	namespace:mods::projectile
empty_make	mods/weapon-types.hpp	/^		std::unique_ptr<AttributesType> empty_make(){$/;"	f	namespace:mods::weapon_types
enable_zone_resets	mods/builder.cpp	/^void enable_zone_resets(){$/;"	f
encrypt	mods/crypto.cpp	/^int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key,$/;"	f	namespace:mods::crypto
encrypt_buffer	mods/crypto.cpp	/^	std::string encrypt_buffer(std::string_view in_key,std::string_view in_iv,std::string_view buffer) {$/;"	f	namespace:mods::crypto
encrypt_names	telnet.h	/^char *encrypt_names[] = {$/;"	v
enctype_names	telnet.h	/^char *enctype_names[] = {$/;"	v
end_read_list	shop.cpp	/^int end_read_list(struct shop_buy_data *list, int len, int error) {$/;"	f
engineer_skillset	class.cpp	/^std::string engineer_skillset() {$/;"	f
entry	db.h	/^	char *entry;$/;"	m	struct:help_index_element
epoch_string	mods/date-time.cpp	/^		std::string epoch_string(){$/;"	f	namespace:mods::date_time::irl
epoll_ev	comm.cpp	/^epoll_event epoll_ev;$/;"	v
epoll_fd	comm.cpp	/^int epoll_fd = -1;$/;"	v
equip	mods/player.cpp	/^	void player::equip(obj_ptr_t in_object,int pos) {$/;"	f	class:mods::player
equip	mods/player.cpp	/^	void player::equip(uuid_t obj_uuid,int pos){$/;"	f	class:mods::player
equip_char	handler.cpp	/^void equip_char(player_ptr_t player,obj_ptr_t in_object,int pos){$/;"	f
equipment	mods/player.cpp	/^	obj_ptr_t player::equipment(int pos) {$/;"	f	class:mods::player
equipment_types	constants.cpp	/^const char *equipment_types[] = {$/;"	v
equipment_types	constants.hpp	/^const char *equipment_types[] = {$/;"	v
erase_queued_items	mods/affects.hpp	/^			void erase_queued_items(){$/;"	f	struct:mods::affects::dissolver
err	mods/util.cpp	/^namespace mods::util::err {$/;"	n	class:mods::util	file:
err	mods/util.hpp	/^namespace mods::util::err {$/;"	n	class:mods::util
error	mods/db.hpp	/^namespace mods::lmdb::error { $/;"	n	class:mods::lmdb
eval_string	mods/js.cpp	/^		void eval_string(duk_context* ctx,const std::string& str) {$/;"	f	namespace:mods::js
eval_string	mods/js.cpp	/^		void eval_string(std::string_view str) {$/;"	f	namespace:mods::js
evaluate	mods/catch.hpp	/^			static bool evaluate(T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator
evaluate_expression	shop.cpp	/^int evaluate_expression(struct obj_data *obj, char *expr) {$/;"	f
evaluate_operation	shop.cpp	/^void evaluate_operation(struct stack_data *ops, struct stack_data *vals) {$/;"	f
event	mods/ai_state.cpp	/^	uint32_t ai_state::event(char_data* ch,event_type_t ev) {$/;"	f	class:mods::ai_state
event_enum	mods/events.hpp	/^	enum event_enum {$/;"	g	namespace:mods::events
event_type_t	mods/ai_state.hpp	/^			enum event_type_t {$/;"	g	class:mods::ai_state
events	mods/events.cpp	/^namespace mods::events {$/;"	n	class:mods	file:
events	mods/events.hpp	/^namespace mods::events {$/;"	n	class:mods
ex_description	structs.h	/^		std::vector<extra_descr_data> ex_description; \/* extra descriptions     *\/$/;"	m	struct:obj_data
ex_descriptions	structs.cpp	/^		std::vector<mods::extra_desc_data>& room_data::ex_descriptions(){$/;"	f	class:room_data
exec	mods/pq.cpp	/^	pqxx::result exec(transaction& txn,std::string_view query) {$/;"	f	namespace:mods::pq
executing_js	mods/player.cpp	/^	void player::executing_js(bool true_false) {$/;"	f	class:mods::player
exists	mods/filesystem.hpp	/^	static inline bool exists(const std::string& path){$/;"	f	namespace:mods::filesystem
exists	mods/lmdb.cpp	/^	bool _db_handle::exists(std::string key){$/;"	f	class:mods::lmdb::_db_handle
exists	mods/util.hpp	/^		bool exists(const ContainerType * container_ptr,$/;"	f	namespace:mods::util
exit_bits	constants.cpp	/^const char *exit_bits[] = {$/;"	v
exit_bits	constants.hpp	/^const char *exit_bits[] = {$/;"	v
exit_info	structs.h	/^		int exit_info;	\/* Exit info			*\/$/;"	m	struct:room_direction_data
exit_info_masks_t	mods/doors.hpp	/^	enum exit_info_masks_t {$/;"	g	namespace:mods::doors
exit_num	house.h	/^	sh_int exit_num;		\/* direction of house's exit	*\/$/;"	m	struct:house_control_rec
exp	mods/player.hpp	/^		int& exp() {$/;"	f	struct:mods::player
explode	mods/projectile.cpp	/^		void explode(room_rnum room_id,uuid_t object_uuid,uuid_t player_uuid){$/;"	f	namespace:mods::projectile
explode	mods/util.cpp	/^	std::vector<std::string> explode(char delim,std::string& haystack){$/;"	f	namespace:mods::util
explode_debug	mods/projectile.cpp	12;"	d	file:
explode_debug	mods/projectile.cpp	14;"	d	file:
explode_in_future	mods/projectile.cpp	/^		void explode_in_future(int room_id, int ticks, uuid_t object_uuid,uuid_t player_uuid) {$/;"	f	namespace:mods::projectile
explosive	mods/injure.cpp	/^	namespace explosive {$/;"	n	namespace:mods::injure	file:
explosive	mods/injure.hpp	/^	namespace explosive {$/;"	n	namespace:mods::injure
explosive	mods/item-types.hpp	/^	enum explosive {$/;"	g	namespace:mods::weapon::type
explosive	mods/projectile.cpp	/^	namespace explosive {$/;"	n	namespace:mods::injure	file:
explosive	mods/weapon.cpp	/^	mw_explosive explosive(obj_data_ptr_t& object){$/;"	f	namespace:mods::weapon
explosive_damage	mods/projectile.cpp	/^		int explosive_damage(player_ptr_t victim, obj_ptr_t item){$/;"	f	namespace:mods::projectile
explosive_description_t	mods/yaml.hpp	/^		explosive_description_t() :$/;"	f	struct:mods::yaml::explosive_description_t
explosive_description_t	mods/yaml.hpp	/^	struct explosive_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
export_shop	shop.cpp	/^std::map<std::string,std::string> shop_data<TOrmType,T,R>::export_shop(){$/;"	f	class:shop_data
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::armor_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::attachment_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::consumable_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::drone_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::explosive_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::gadget_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::rifle_description_t
exported	mods/yaml.hpp	/^		std::map<std::string,std::string> exported;$/;"	m	struct:mods::yaml::trap_description_t
extended_item_vnum	structs.h	/^		uint64_t extended_item_vnum;$/;"	m	struct:obj_data
extended_type	structs.h	/^		int extended_type; \/** i.e. mw_rifle::SUB_MACHINE_GUN *\/$/;"	m	struct:obj_data
extra_bits	constants.cpp	/^const char *extra_bits[] = {$/;"	v
extra_bits	constants.hpp	/^const char *extra_bits[] = {$/;"	v
extra_bits_count	constants.cpp	/^        extra_bits_count = sizeof(extra_bits) \/ sizeof(extra_bits[0]) - 1,$/;"	v
extra_bits_count	constants.hpp	/^	extra_bits_count = sizeof(extra_bits) \/ sizeof(extra_bits[0]) - 1,$/;"	v
extra_desc_data	mods/extra_desc_data.cpp	/^	extra_desc_data::extra_desc_data($/;"	f	class:mods::extra_desc_data
extra_desc_data	mods/extra_desc_data.cpp	/^	extra_desc_data::extra_desc_data() : $/;"	f	class:mods::extra_desc_data
extra_desc_data	mods/extra_desc_data.hpp	/^	struct extra_desc_data {$/;"	s	namespace:mods
extra_descr_data	structs.h	/^		extra_descr_data() : keyword(""), description("") {}$/;"	f	struct:extra_descr_data
extra_descr_data	structs.h	/^		extra_descr_data(mentoc_pqxx_result_t k,mentoc_pqxx_result_t d) :$/;"	f	struct:extra_descr_data
extra_descr_data	structs.h	/^		extra_descr_data(pqxx::field k,pqxx::field d) :$/;"	f	struct:extra_descr_data
extra_descr_data	structs.h	/^		extra_descr_data(std::string_view k,std::string_view d) :$/;"	f	struct:extra_descr_data
extra_descr_data	structs.h	/^	struct extra_descr_data {$/;"	s
extra_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,17> extra_flags = { {$/;"	m	namespace:mods::builder	file:
extra_flags	structs.h	/^		int \/*bitvector_t*\/	extra_flags;	\/* If it hums, glows, etc.	    *\/$/;"	m	struct:obj_flag_data
extra_flags	structs.h	/^		int \/*bitvector_t*\/	extra_flags;$/;"	m	struct:obj_file_elem
extra_flags_t	structs.h	/^enum extra_flags_t {$/;"	g
extract_char	handler.cpp	/^void extract_char(char_data *ch) {$/;"	f
extract_char_final	handler.cpp	/^void extract_char_final(char_data *ch) {$/;"	f
extract_obj	handler.cpp	/^void extract_obj(struct obj_data *obj) {$/;"	f
extract_pending_chars	handler.cpp	/^void extract_pending_chars(){$/;"	f
extract_reference_field_from_meta_key	mods/meta_utils.cpp	/^	std::string extract_reference_field_from_meta_key(const std::string& key){$/;"	f	namespace:mods::meta_utils
extract_yaml_info_from_path	mods/util.cpp	/^	std::tuple<int,std::string> extract_yaml_info_from_path(std::string_view path){$/;"	f	namespace:mods::util
extraction	db.cpp	/^	namespace extraction {$/;"	n	namespace:db	file:
extraction	db.h	/^	namespace extraction {$/;"	n	namespace:db
extractions_pending	handler.cpp	/^int extractions_pending = 0;$/;"	v
f_import_rooms	globals.cpp	/^		bool f_import_rooms;$/;"	m	namespace:mods::globals	file:
feed	mods/weapon-types.hpp	/^		std::tuple<std::unique_ptr<AttributesType>,uint64_t> feed(std::string_view file){$/;"	f	namespace:mods::weapon_types
feed	mods/yaml.cpp	/^	int16_t armor_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::armor_description_t
feed	mods/yaml.cpp	/^	int16_t attachment_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::attachment_description_t
feed	mods/yaml.cpp	/^	int16_t consumable_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::consumable_description_t
feed	mods/yaml.cpp	/^	int16_t drone_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::drone_description_t
feed	mods/yaml.cpp	/^	int16_t explosive_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::explosive_description_t
feed	mods/yaml.cpp	/^	int16_t gadget_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::gadget_description_t
feed	mods/yaml.cpp	/^	int16_t rifle_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::rifle_description_t
feed	mods/yaml.cpp	/^	int16_t trap_description_t::feed(std::string_view in_file){$/;"	f	class:mods::yaml::trap_description_t
feed	shop.cpp	/^	void shop_data<mods::orm::shop,mods::orm::shop_rooms,mods::orm::shop_objects>::feed(const pqxx::result::reference & in_row)$/;"	f	class:shop_data
feed	structs.cpp	/^		int16_t obj_data::feed(int16_t in_type,std::string_view feed_file){$/;"	f	class:obj_data
feed	structs.cpp	/^	void obj_flag_data::feed(const pqxx::result::reference & row){$/;"	f	class:obj_flag_data
feed_caps	mods/weapon.hpp	/^	static inline void feed_caps(TObj& obj, T type){$/;"	f	namespace:mods::weapon
feed_file	structs.h	/^		std::string_view feed_file(){ return m_feed_file; }$/;"	f	struct:obj_data
feed_from_po_record	mods/yaml.cpp	/^	int16_t gadget_description_t::feed_from_po_record(mentoc_pqxx_result_t yaml_file){$/;"	f	class:mods::yaml::gadget_description_t
feed_from_po_record	mods/yaml.cpp	/^	int16_t rifle_description_t::feed_from_po_record(mentoc_pqxx_result_t yaml_file){$/;"	f	class:mods::yaml::rifle_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::armor_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::attachment_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::consumable_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::drone_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::explosive_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::gadget_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::rifle_description_t
feed_status	mods/yaml.hpp	/^		int16_t feed_status;$/;"	m	struct:mods::yaml::trap_description_t
feed_status	structs.h	/^		int16_t feed_status;$/;"	m	struct:obj_data
fido	spec_assign.cpp	/^SPECIAL(fido);$/;"	v
fido	spec_procs.cpp	/^SPECIAL(fido);$/;"	v
fields_fed_so_far	mods/object-utils.hpp	/^		std::vector<std::string> fields_fed_so_far;$/;"	m	struct:mods::object_utils::YamlFeedExceptionInfo
fields_of_study	mods/skills.hpp	/^	enum fields_of_study {$/;"	g	namespace:mods::skills
fields_to_grab	mods/lmdb.cpp	/^	std::vector<std::string> _db_handle::fields_to_grab(const std::string& table){$/;"	f	class:mods::lmdb::_db_handle
fight_messages	db.cpp	/^struct message_list fight_messages[MAX_MESSAGES];	\/* fighting messages	 *\/$/;"	v	typeref:struct:message_list
fighting	mods/player.hpp	/^		player_ptr_t fighting(){$/;"	f	struct:mods::player
file	mods/catch.hpp	/^		char const* file;$/;"	m	struct:Catch::SourceLineInfo
file_end_pos	mail.cpp	/^long file_end_pos = 0;			\/* length of file *\/$/;"	v
file_exists	mods/filesystem.hpp	/^	static inline bool file_exists(const std::string& path){$/;"	f	namespace:mods::filesystem
file_to_lmdb	globals.cpp	/^		int file_to_lmdb(const std::string& file, const std::string& key) {$/;"	f	namespace:mods::globals
file_to_string	db.cpp	/^int file_to_string(const char *name, char *buf) {$/;"	f
file_to_string_alloc	db.cpp	/^int file_to_string_alloc(const char *name, char **buf) {$/;"	f
filename	boards.h	/^	char	filename[50];	\/* file to save this board to *\/$/;"	m	struct:board_info_type
filesystem	mods/filesystem.hpp	/^namespace mods::filesystem {$/;"	n	class:mods
fill	interpreter.cpp	/^const char *fill[] = {$/;"	v
fill_armor	act.builder.cpp	/^void fill_armor(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_attachment	act.builder.cpp	/^void fill_attachment(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_consumable	act.builder.cpp	/^void fill_consumable(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_drone	act.builder.cpp	/^void fill_drone(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_explosive	act.builder.cpp	/^void fill_explosive(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_flags	mods/yaml.cpp	/^	void armor_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::armor_description_t
fill_flags	mods/yaml.cpp	/^	void attachment_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::attachment_description_t
fill_flags	mods/yaml.cpp	/^	void consumable_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::consumable_description_t
fill_flags	mods/yaml.cpp	/^	void drone_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::drone_description_t
fill_flags	mods/yaml.cpp	/^	void explosive_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::explosive_description_t
fill_flags	mods/yaml.cpp	/^	void gadget_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::gadget_description_t
fill_flags	mods/yaml.cpp	/^	void rifle_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::rifle_description_t
fill_flags	mods/yaml.cpp	/^	void trap_description_t::fill_flags(obj_data* o){$/;"	f	class:mods::yaml::trap_description_t
fill_gadget	act.builder.cpp	/^void fill_gadget(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_rifle	act.builder.cpp	/^void fill_rifle(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_trap	act.builder.cpp	/^void fill_trap(std::shared_ptr<obj_data>& obj) {$/;"	f
fill_word	interpreter.cpp	/^int fill_word(char *argument) {$/;"	f
find_action	act.social.cpp	/^int find_action(int cmd) {$/;"	f
find_alias	interpreter.cpp	/^struct alias_data *find_alias(struct alias_data *alias_list, char *str) {$/;"	f
find_all_dots	handler.cpp	/^int find_all_dots(char *arg) {$/;"	f
find_board	boards.cpp	/^int find_board(char_data *ch) {$/;"	f
find_char_in_index	mail.cpp	/^mail_index_type *find_char_in_index(long searchee) {$/;"	f
find_class_bitvector	class.cpp	/^bitvector_t find_class_bitvector(const char *arg) {$/;"	f
find_command	interpreter.cpp	/^int find_command(const char *command) {$/;"	f
find_door	act.movement.cpp	/^	int find_door(char_data *ch, const char *type, char *dir, const char *cmdname) {$/;"	f
find_eq_pos	act.item.cpp	/^int find_eq_pos(char_data *ch, struct obj_data *obj, char *arg) {$/;"	f
find_exdesc	act.informative.cpp	/^char * find_exdesc(char *word,room_data& r){$/;"	f
find_exdesc	act.informative.cpp	/^char* find_exdesc(std::string_view word,std::vector<extra_descr_data>& in_list) {$/;"	f
find_exdesc_equipment	act.informative.cpp	/^const char* find_exdesc_equipment(std::string_view word,const char_data* ch,const std::size_t& position){$/;"	f
find_first_step	graph.cpp	/^int find_first_step(room_rnum src, room_rnum target) {$/;"	f
find_guard	castle.cpp	/^char_data * find_guard(char_data *ch) {$/;"	f
find_house	house.cpp	/^int find_house(room_vnum vnum) {$/;"	f
find_npc_by_name	castle.cpp	/^char_data *find_npc_by_name(char_data *ch,$/;"	f
find_oper_num	shop.cpp	/^int find_oper_num(char token) {$/;"	f
find_player_by_name	mods/js.cpp	/^			player_ptr_t find_player_by_name(std::string_view name,bool& found){$/;"	f	namespace:mods::js::utils
find_player_payload_t	mods/js.cpp	/^				find_player_payload_t(std::string_view name) : player_name(name.data()), found(false){$/;"	f	struct:mods::js::utils::find_player_payload_t
find_player_payload_t	mods/js.cpp	/^			struct find_player_payload_t {$/;"	s	namespace:mods::js::utils	file:
find_results_t	mods/scan.hpp	/^		struct find_results_t{$/;"	s	namespace:mods::scan
find_skill_num	spell_parser.cpp	/^int find_skill_num(char *name) {$/;"	f
find_slot	boards.cpp	/^int find_slot(void) {$/;"	f
find_target_room	act.wizard.cpp	/^room_rnum find_target_room(char_data *ch, char *rawroomstr) {$/;"	f
fire_damage	mods/projectile.cpp	/^		int fire_damage(player_ptr_t victim,obj_ptr_t projectile){$/;"	f	namespace:mods::projectile
fire_status	structs.h	/^		fire_status_t& fire_status(){$/;"	f
fire_status_start	structs.h	/^		void fire_status_start(){$/;"	f
flag_group	mods/flags.hpp	/^	enum flag_group {$/;"	g	namespace:mods::flags
flag_help	mods/builder_util.hpp	/^	void flag_help($/;"	f	namespace:mods::builder_util
flagged	mods/behaviour_tree_impl.hpp	/^		bool inline flagged(argument_type & mob){$/;"	f	namespace:mods::behaviour_tree_impl
flagged	mods/behaviour_tree_impl.hpp	/^		bool inline flagged(argument_type & mob,const type & type){$/;"	f	namespace:mods::behaviour_tree_impl
flagged	structs.cpp	/^bool obj_data::flagged(int value){$/;"	f	class:obj_data
flags	mods/flags.hpp	/^namespace mods::flags {$/;"	n	class:mods
flags	shop.h	/^	uint64_t flags;$/;"	m	struct:shop_data
flags_door	act.movement.cpp	/^	const int flags_door[] = {$/;"	v
flashbang	mods/flashbang.hpp	/^namespace mods::flashbang {$/;"	n	class:mods
flush_output	structs.cpp	/^			size_t mods::descriptor_data::flush_output(){$/;"	f	class:mods::mods::descriptor_data
flush_queues	comm.cpp	/^void flush_queues(mods::descriptor_data &d) {$/;"	f
flush_to_db	mods/builder.cpp	/^	bool flush_to_db(char_data *ch,int room) {$/;"	f	namespace:mods::builder
flush_to_db	mods/yaml.cpp	/^	uint64_t armor_description_t::flush_to_db(){$/;"	f	class:mods::yaml::armor_description_t
flush_to_db	mods/yaml.cpp	/^	uint64_t explosive_description_t::flush_to_db(){$/;"	f	class:mods::yaml::explosive_description_t
flush_to_db	mods/yaml.cpp	/^	uint64_t gadget_description_t::flush_to_db(){$/;"	f	class:mods::yaml::gadget_description_t
flush_to_db	mods/yaml.cpp	/^	uint64_t rifle_description_t::flush_to_db(){$/;"	f	class:mods::yaml::rifle_description_t
fmtfp	bsd-snprintf.cpp	/^fmtfp(char *buffer, size_t *currlen, size_t maxlen, long double fvalue,$/;"	f	file:
fmtint	bsd-snprintf.cpp	/^fmtint(char *buffer, size_t *currlen, size_t maxlen,$/;"	f	file:
fmtstr	bsd-snprintf.cpp	/^fmtstr(char *buffer, size_t *currlen, size_t maxlen,$/;"	f	file:
fname	handler.cpp	/^char *fname(const char *namelist) {$/;"	f
force_dark	mods/rooms.hpp	/^			static inline void force_dark(TRoom room) {$/;"	f	namespace:mods::rooms::gods
foreach_all	mods/loops.hpp	/^		static inline PointerType* foreach_all(function_with_return_t<PointerType> func,PointerType* param){$/;"	f	namespace:mods::loops::shptr
foreach_all	mods/loops.hpp	/^		static inline void foreach_all(function_t func){$/;"	f	namespace:mods::loops::shptr
foreach_all	mods/loops.hpp	/^	static inline void foreach_all(all_function_t func){$/;"	f	namespace:mods::loops
foreach_all_chars	mods/loops.cpp	/^	void foreach_all_chars(all_function_t func){$/;"	f	namespace:mods::loops
foreach_in_room	mods/loops.cpp	/^	void foreach_in_room(std::size_t room,player_function_t func){$/;"	f	namespace:mods::loops
foreach_mob	mods/loops.cpp	/^	void foreach_mob(mob_function_t func){$/;"	f	namespace:mods::loops
foreach_mob	mods/loops.cpp	/^	void foreach_mob(mods_npc_function_t func){$/;"	f	namespace:mods::loops
foreach_mob	mods/loops.hpp	/^		static inline PointerType* foreach_mob(function_with_return_t<PointerType> func,PointerType* param){$/;"	f	namespace:mods::loops::shptr
foreach_mob	mods/loops.hpp	/^		static inline void foreach_mob(npc_function_t func){$/;"	f	namespace:mods::loops::shptr
foreach_mob_as_player	mods/loops.hpp	/^		static inline void foreach_mob_as_player(function_t func){$/;"	f	namespace:mods::loops::shptr
foreach_player	mods/loops.cpp	/^	void foreach_player(player_function_t func){$/;"	f	namespace:mods::loops
foreach_player	mods/loops.hpp	/^		static inline PointerType* foreach_player(function_with_return_t<PointerType> func,PointerType* param){$/;"	f	namespace:mods::loops::shptr
foreach_player	mods/loops.hpp	/^		static inline void foreach_player(function_t func){$/;"	f	namespace:mods::loops::shptr
foreach_player	mods/loops.hpp	/^	static inline PointerType* foreach_player(mods_player_function_t<PointerType> func,PointerType* param){$/;"	f	namespace:mods::loops
forget	mobact.cpp	/^void forget(char_data *ch,char_data *victim) {$/;"	f
found	mods/js.cpp	/^				bool found;$/;"	m	struct:mods::js::utils::find_player_payload_t	file:
found	mods/scan.hpp	/^			bool found;$/;"	m	struct:mods::scan::find_results_t
fread_action	act.social.cpp	/^char *fread_action(FILE *fl, int nr) {$/;"	f
fread_string	db.cpp	/^char *fread_string(FILE *fl, const char *error) {$/;"	f
free_alias	interpreter.cpp	/^void free_alias(struct alias_data *a) {$/;"	f
free_char	db.cpp	/^void free_char(char_data *ch) {$/;"	f
free_extra_descriptions	db.cpp	/^void free_extra_descriptions(struct extra_descr_data *edesc) {$/;"	f
free_help	db.cpp	/^void free_help(void) {$/;"	f
free_list	mail.cpp	/^position_list_type *free_list = NULL;	\/* list of free positions in file *\/$/;"	v
free_messages	fight.cpp	/^void free_messages(void) {$/;"	f
free_messages_type	fight.cpp	/^void free_messages_type(struct msg_type *msg) {$/;"	f
free_obj	db.cpp	/^void free_obj(struct obj_data *obj) {$/;"	f
free_player_index	db.cpp	/^void free_player_index(void) {$/;"	f
free_rent	config.cpp	/^int free_rent = YES;$/;"	v
free_social_messages	act.social.cpp	/^void free_social_messages(void) {$/;"	f
free_text_files	db.cpp	/^void free_text_files(void) {$/;"	f
from	mail.h	/^	long from;			\/* idnum of the mail's sender		*\/$/;"	m	struct:header_data_type
from	mods/sql.hpp	/^			compositor<T>& from(str_object table) {$/;"	f	struct:mods::sql::compositor
from_direction	structs.h	/^		uint8_t from_direction;$/;"	m	struct:obj_data
from_dirstr	mods/doors.hpp	/^	static inline std::string from_dirstr(const int& direction){$/;"	f	namespace:mods::doors
from_string	mods/doors.hpp	/^	static inline int from_string(std::string_view i){$/;"	f	namespace:mods::doors
fromdirstr	mods/projectile.cpp	/^		std::string fromdirstr(int direction,bool prefix, bool suffix) {$/;"	f	namespace:mods::projectile
frozen_start_room	config.cpp	/^room_vnum frozen_start_room = 0;$/;"	v
fry_victim	castle.cpp	/^void fry_victim(char_data *ch) {$/;"	f
fs	act.builder.cpp	/^namespace mods::fs {$/;"	n	class:mods	file:
fullness	constants.cpp	/^const char *fullness[] = {$/;"	v
fullness	constants.hpp	/^const char *fullness[] =$/;"	v
func	shop.h	/^	SPECIAL(*func);		\/* Secondary spec_proc for shopkeeper	*\/$/;"	m	struct:shop_data
func	structs.h	/^		SPECIAL(*func);$/;"	v
fuzzy_match	mods/util.cpp	/^		bool fuzzy_match(const std::string& _needle,const std::string & _haystack) {$/;"	f	namespace:mods::util
gadget	mods/item-types.hpp	/^	enum gadget {$/;"	g	namespace:mods::weapon::type
gadget_description_t	mods/yaml.hpp	/^		gadget_description_t() :$/;"	f	struct:mods::yaml::gadget_description_t
gadget_description_t	mods/yaml.hpp	/^	struct gadget_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
gain_condition	limits.cpp	/^void gain_condition(char_data *ch, int condition, int value) {$/;"	f
gain_exp	limits.cpp	/^void gain_exp(char_data *ch, int gain) {$/;"	f
gain_exp_regardless	limits.cpp	/^void gain_exp_regardless(char_data *ch, int gain) {$/;"	f
game_init	mods/skills.cpp	/^	void game_init(){$/;"	f	namespace:mods::skills
game_loop	comm.cpp	/^void game_loop(socket_t mother_desc) {$/;"	f
gather_room	mods/sensor-grenade.cpp	/^	void gather_room(uuid_t nade_uuid,room_rnum& room,uint8_t from_direction){$/;"	f	namespace:mods::sensor_grenade
gen_board	boards.cpp	/^SPECIAL(gen_board);$/;"	v
gen_board	spec_assign.cpp	/^SPECIAL(gen_board);$/;"	v
gen_receptionist	objsave.cpp	/^int gen_receptionist(char_data *ch, char_data *recep,$/;"	f
genders	constants.cpp	/^const char *genders[] = {$/;"	v
genders	constants.hpp	/^const char *genders[] =$/;"	v
general_description	structs.h	/^		mods::string general_description;       \/* When look DIR.			*\/$/;"	m	struct:room_direction_data
generate	mods/overhead_map.cpp	/^		std::string generate(mods::player* out,const room_rnum& room_number){$/;"	f	namespace:mods::overhead_map
generate	mods/overhead_map.hpp	/^		std::string generate(OutputDevice out,const room_rnum& room_number){$/;"	f	namespace:mods::overhead_map
generate_map	mods/yaml.cpp	/^	void armor_description_t::generate_map(){$/;"	f	class:mods::yaml::armor_description_t
generate_map	mods/yaml.cpp	/^	void explosive_description_t::generate_map(){$/;"	f	class:mods::yaml::explosive_description_t
generate_map	mods/yaml.cpp	/^	void gadget_description_t::generate_map(){$/;"	f	class:mods::yaml::gadget_description_t
generate_map	mods/yaml.cpp	/^	void rifle_description_t::generate_map(){$/;"	f	class:mods::yaml::rifle_description_t
generate_stat_page	structs.cpp	/^		std::string obj_data::generate_stat_page() {$/;"	f	class:obj_data
generic_find	handler.cpp	/^int generic_find(char *arg, bitvector_t bitvector, char_data *ch,$/;"	f
genstr	mods/util-conf.hpp	/^			bool genstr(const std::string& file_name,$/;"	f	namespace:mods::util::conf
get	mods/catch.hpp	/^			T* get() const {$/;"	f	class:Catch::Ptr
get	mods/jx.hpp	/^			std::string get() {$/;"	f	struct:mods::jx::compositor
get	mods/lmdb.cpp	/^	int _db_handle::get(std::string key,std::string & in_value){$/;"	f	class:mods::lmdb::_db_handle
get	mods/lmdb.cpp	/^	std::string _db_handle::get(std::string key){$/;"	f	class:mods::lmdb::_db_handle
get	mods/prefs.cpp	/^	std::string prefs::get(const std::string& key,char_data* ch) {$/;"	f	class:mods::prefs
getName	mods/catch.hpp	/^			static const char* getName() {$/;"	f	struct:Catch::Internal::OperatorTraits
get_affect_dissolver	mods/player.cpp	/^	player::affect_dissolver_t& player::get_affect_dissolver() {$/;"	f	class:mods::player
get_affected	mods/player.cpp	/^	aligned_int_t player::get_affected(){$/;"	f	class:mods::player
get_affected_by	mods/player.hpp	/^		std::vector<affected_type>& get_affected_by() { return m_affected_by; }$/;"	f	struct:mods::player
get_affected_plr	mods/player.cpp	/^	aligned_int_t player::get_affected_plr(){$/;"	f	class:mods::player
get_affects	mods/affects.hpp	/^		TAffectsMap& get_affects(){ return m_affects; }$/;"	f	struct:mods::affects::dissolver
get_all	mods/lmdb.cpp	/^		result_container_t transaction_t::get_all(T consumer){$/;"	f	class:mods::lmdb::transaction_t
get_all_meta_values	mods/meta_utils.cpp	/^	std::vector<std::string> get_all_meta_values($/;"	f	namespace:mods::meta_utils
get_ammo	mods/object-utils.hpp	/^	uint16_t get_ammo(T& weapon){$/;"	f	namespace:mods::object_utils
get_ammo	mods/object-utils.hpp	/^	uint16_t get_ammo(obj_ptr_t& weapon){$/;"	f	namespace:mods::object_utils
get_ammo	mods/player.cpp	/^	obj_data* player::get_ammo(const weapon_type_t& type) {$/;"	f	class:mods::player
get_ammo_for	mods/player.cpp	/^	obj_ptr_t player::get_ammo_for(obj_ptr_t& weapon){$/;"	f	class:mods::player
get_bad_password_count	mods/player.cpp	/^	int player::get_bad_password_count(){$/;"	f	class:mods::player
get_bind_addr	comm.cpp	/^struct in_addr *get_bind_addr() {$/;"	f
get_bui_mode	mods/player.hpp	/^		bool get_bui_mode(){ return m_bui_mode; }$/;"	f	struct:mods::player
get_camera	mods/player.cpp	/^	std::shared_ptr<mods::camera> player::get_camera() const {$/;"	f	class:mods::player
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_armor type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_attachment type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_consumable type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_drone type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_explosive type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_gadget type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_rifle type){$/;"	f	namespace:mods::weapon
get_caps	mods/weapon.cpp	/^	std::vector<cap_t> get_caps(mw_trap type){$/;"	f	namespace:mods::weapon
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_armor)this->type); }$/;"	f	struct:mods::yaml::armor_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_attachment)this->type); }$/;"	f	struct:mods::yaml::attachment_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_consumable)this->type); }$/;"	f	struct:mods::yaml::consumable_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_drone)this->type); }$/;"	f	struct:mods::yaml::drone_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_explosive)this->type); }$/;"	f	struct:mods::yaml::explosive_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_gadget)this->type); }$/;"	f	struct:mods::yaml::gadget_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_rifle)this->type); }$/;"	f	struct:mods::yaml::rifle_description_t
get_caps	mods/yaml.hpp	/^		std::vector<cap_t> get_caps(){ return mods::weapon::get_caps((mw_trap)this->type); }$/;"	f	struct:mods::yaml::trap_description_t
get_captured_output	mods/player.cpp	/^	std::string_view player::get_captured_output() {$/;"	f	class:mods::player
get_char_num	handler.cpp	/^char_data *get_char_num(mob_rnum nr) {$/;"	f
get_char_room	handler.cpp	/^char_data *get_char_room(char *name, int *number, room_rnum room) {$/;"	f
get_char_room_vis	handler.cpp	/^char_data * get_char_room_vis( char_data *ch, char *name, int *number) {$/;"	f
get_char_vis	handler.cpp	/^char_data *get_char_vis(char_data *ch, char *name, int *number, int where) {$/;"	f
get_char_vis	handler.cpp	/^player_ptr_t get_char_vis(player_ptr_t player, char *name, int *number, int where) {$/;"	f
get_char_world_vis	handler.cpp	/^ char_data *get_char_world_vis( char_data *ch, char *name, int *number) {$/;"	f
get_check_money	act.item.cpp	/^void get_check_money(char_data *ch, struct obj_data *obj) {$/;"	f
get_children	mods/behaviour_tree_node.hpp	/^		children_t & get_children() const { return m_children; }$/;"	f	struct:mods::behaviour_tree_node
get_chunk	mods/player.hpp	/^		aligned_int_t get_chunk(chunk_type_t chunk) const {$/;"	f	struct:mods::player
get_class	mods/player.hpp	/^		player_class_t get_class() const { return m_class; }$/;"	f	struct:mods::player
get_clip_by_name	mods/weapon.cpp	/^	obj_ptr_t get_clip_by_name(player_ptr_t & player, std::string_view arg){$/;"	f	namespace:mods::weapon
get_context	mods/js.hpp	/^				inline duk_context* get_context() {$/;"	f	struct:mods::js::include
get_current_player	mods/js.cpp	/^		static duk_ret_t get_current_player(duk_context *ctx) {$/;"	f	namespace:mods::js
get_day	mods/date-time.cpp	/^	std::string get_day(){$/;"	f	namespace:mods::date_time
get_day	mods/js.cpp	/^		static duk_ret_t get_day(duk_context *ctx) {$/;"	f	namespace:mods::js
get_db_id	mods/player.cpp	/^	aligned_int_t player::get_db_id() const {$/;"	f	class:mods::player
get_dir	mods/js.hpp	/^				inline std::string_view get_dir() {$/;"	f	struct:mods::js::include
get_drone	mods/drone.cpp	/^	 void drone::get_drone(char_data* owner) {$/;"	f	class:mods::drone
get_enum_by_name	mods/skills.cpp	/^	int get_enum_by_name(std::string_view name){$/;"	f	namespace:mods::skills
get_existing	mods/drone.cpp	/^	 char_data * drone::get_existing(char_data* owner) {$/;"	f	class:mods::drone
get_explosive_type	mods/object-utils.hpp	/^	inline mw_explosive get_explosive_type<uuid_t>(uuid_t& obj_uuid){$/;"	f	namespace:mods::object_utils
get_explosive_type	mods/object-utils.hpp	/^	static inline mw_explosive get_explosive_type(T& obj){$/;"	f	namespace:mods::object_utils
get_file	mods/js.hpp	/^				inline std::string_view get_file() {$/;"	f	struct:mods::js::include
get_filename	utils.cpp	/^int get_filename(char *filename, size_t fbufsize, int mode, const char *orig_name) {$/;"	f
get_fire_status	mods/rooms.hpp	/^		static inline fire_status_t get_fire_status(TRoom room) {$/;"	f	namespace:mods::rooms
get_first_ammo_of_type	mods/player.cpp	/^	obj_data* player::get_first_ammo_of_type(const weapon_type_t& type) const {$/;"	f	class:mods::player
get_from_container	act.item.cpp	/^void get_from_container(char_data *ch, struct obj_data *cont,$/;"	f
get_from_q	comm.cpp	/^int get_from_q(mods::descriptor_data& d, char *dest, int *aliased) {$/;"	f
get_from_room	act.item.cpp	/^void get_from_room(char_data *ch, char *arg, int howmany) {$/;"	f
get_frozen_room_vnum	mods/world-configuration.cpp	/^	int get_frozen_room_vnum(){$/;"	f	namespace:mods::world_conf
get_hash_obj_vis	shop.cpp	/^struct obj_data *get_hash_obj_vis(char_data *ch, char *name,$/;"	f
get_hour	mods/date-time.cpp	/^	std::string get_hour() {$/;"	f	namespace:mods::date_time
get_id	db.h	/^	int64_t get_id() const { return m_id; }$/;"	f	struct:zone_data
get_id_by_name	db.cpp	/^long get_id_by_name(const char *name) {$/;"	f
get_iday	mods/date-time.cpp	/^	uint8_t get_iday() {$/;"	f	namespace:mods::date_time
get_iday	mods/js.cpp	/^		static duk_ret_t get_iday(duk_context *ctx) {$/;"	f	namespace:mods::js
get_idle_room_vnum	mods/world-configuration.cpp	/^	int get_idle_room_vnum(){$/;"	f	namespace:mods::world_conf
get_ihour	mods/date-time.cpp	/^	uint8_t get_ihour() {$/;"	f	namespace:mods::date_time
get_ihour	mods/js.cpp	/^		static duk_ret_t get_ihour(duk_context *ctx) {$/;"	f	namespace:mods::js
get_immortal_start_room_vnum	mods/world-configuration.cpp	/^	int get_immortal_start_room_vnum(){$/;"	f	namespace:mods::world_conf
get_imonth	mods/date-time.cpp	/^	uint8_t get_imonth() {$/;"	f	namespace:mods::date_time
get_imonth	mods/js.cpp	/^		static duk_ret_t get_imonth(duk_context *ctx) {$/;"	f	namespace:mods::js
get_imp_mode	mods/player.hpp	/^		bool get_imp_mode(){ return m_imp_mode; }$/;"	f	struct:mods::player
get_iyear	mods/date-time.cpp	/^	uint8_t get_iyear(){$/;"	f	namespace:mods::date_time
get_iyear	mods/js.cpp	/^		static duk_ret_t get_iyear(duk_context *ctx) {$/;"	f	namespace:mods::js
get_last_error	mods/player-scaffolding.cpp	/^	std::vector<std::string>* player_scaffolding::get_last_error(){$/;"	f	class:mods::player_scaffolding
get_lense	mods/player.hpp	/^		auto get_lense(){ return m_lense_type; }$/;"	f	struct:mods::player
get_line	utils.cpp	/^int get_line(FILE *fl, char *buf) {$/;"	f
get_logic	mods/behaviour_tree_node.hpp	/^		callback_t & get_logic() const { return m_logic; }$/;"	f	struct:mods::behaviour_tree_node
get_max_players	comm.cpp	/^int get_max_players(void) {$/;"	f
get_minimum_proficiency	mods/skills.cpp	/^	uint16_t get_minimum_proficiency(int e_name){$/;"	f	namespace:mods::skills
get_misc_pref	mods/player.hpp	/^		bool get_misc_pref(misc_pref_enum_t bit){$/;"	f	struct:mods::player
get_month	mods/date-time.cpp	/^	std::string get_month(){$/;"	f	namespace:mods::date_time
get_month	mods/js.cpp	/^		static duk_ret_t get_month(duk_context *ctx) {$/;"	f	namespace:mods::js
get_moon_phase	mods/date-time.cpp	/^	std::string get_moon_phase() {$/;"	f	namespace:mods::date_time
get_moon_phase	mods/js.cpp	/^		static duk_ret_t get_moon_phase(duk_context *ctx) {$/;"	f	namespace:mods::js
get_mortal_start_room_vnum	mods/world-configuration.cpp	/^	int get_mortal_start_room_vnum(){$/;"	f	namespace:mods::world_conf
get_name	mods/chat.cpp	/^	std::string_view channel::get_name() const {$/;"	f	class:mods::chat::channel
get_name_by_id	db.cpp	/^char *get_name_by_id(long id) {$/;"	f
get_node	mods/behaviour_tree.hpp	/^		node & get_node() const {$/;"	f	struct:mods::behaviour_tree
get_number	handler.cpp	/^int get_number(char **name) {$/;"	f
get_obj_from_room	mods/world-configuration.cpp	/^		bool get_obj_from_room(){ return mods::world_conf::toggle::status_obj_from_room; }$/;"	f	namespace:mods::world_conf::toggle
get_obj_in_equip_vis	handler.cpp	/^struct obj_data *get_obj_in_equip_vis(char_data *ch, char *arg, int *number, struct obj_data *equipment[]) {$/;"	f
get_obj_in_list_num	handler.cpp	/^obj_data *get_obj_in_list_num(int num, struct obj_data *list) {$/;"	f
get_obj_in_list_vis	handler.cpp	/^struct obj_data *get_obj_in_list_vis(char_data *ch, char *name, int *number, struct obj_data *list) {$/;"	f
get_obj_num	handler.cpp	/^struct obj_data *get_obj_num(obj_rnum nr) {$/;"	f
get_obj_pos_in_equip_vis	handler.cpp	/^int get_obj_pos_in_equip_vis(char_data *ch, char *arg, int *number, struct obj_data *equipment[]) {$/;"	f
get_obj_vis	handler.cpp	/^struct obj_data *get_obj_vis(char_data *ch, char *name, int *number) {$/;"	f
get_one_line	db.cpp	/^void get_one_line(FILE *fl, char *buf) {$/;"	f
get_overhead_map_height	mods/player.hpp	/^		uint8_t get_overhead_map_height() const {$/;"	f	struct:mods::player
get_overhead_map_width	mods/player.hpp	/^		uint8_t get_overhead_map_width() const { $/;"	f	struct:mods::player
get_owner	structs.h	/^		uuid_t get_owner(){ return m_owner; }$/;"	f	struct:obj_data
get_password	mods/auto-login.cpp	/^	const std::string& get_password() { return mods::auto_login::password; }$/;"	f	namespace:mods::auto_login
get_password	mods/player.cpp	/^	std::string player::get_password(){$/;"	f	class:mods::player
get_player_level	mods/skills.cpp	/^	uint16_t get_player_level(player_ptr_t& player,int skill){$/;"	f	namespace:mods::skills
get_player_level	mods/skills.cpp	/^	uint16_t get_player_level(player_ptr_t& player,std::string_view skill){$/;"	f	namespace:mods::skills
get_player_map	mods/db.cpp	/^int get_player_map(std::string_view player_name,std::string prefix, std::map<std::string,std::string>& values){$/;"	f
get_player_vector	mods/db.cpp	/^int get_player_vector(std::string_view player_name,std::string prefix, std::vector<std::string>& values){$/;"	f
get_player_vis	handler.cpp	/^char_data *get_player_vis(char_data *ch, char *name, int *number, int inroom) {$/;"	f
get_pluck_filter	mods/lmdb.cpp	/^	const std::vector<std::string> & _db_handle::get_pluck_filter() const {$/;"	f	class:mods::lmdb::_db_handle
get_prefs	mods/player.hpp	/^		auto get_prefs(){ return cd()->player_specials->saved.pref; }$/;"	f	struct:mods::player
get_private	mods/chat.hpp	/^			bool get_private() const {$/;"	f	struct:mods::mods::chat::channel
get_private_publishers	mods/chat.hpp	/^			const std::vector<std::string>& get_private_publishers() const {$/;"	f	struct:mods::mods::chat::channel
get_ptable_by_name	db.cpp	/^long get_ptable_by_name(const char *name) {$/;"	f
get_purchase_obj	shop.cpp	/^struct obj_data *get_purchase_obj(char_data *ch, char *arg,$/;"	f
get_room_flag_strings	mods/rooms.hpp	/^	static inline std::vector<std::string> get_room_flag_strings(){$/;"	f	namespace:mods::rooms
get_room_flags_from_room	mods/rooms.hpp	/^	static inline std::vector<std::string> get_room_flags_from_room(room_rnum r){$/;"	f	namespace:mods::rooms
get_room_list	globals.cpp	/^		player_list_t& get_room_list(player_ptr_t& player){$/;"	f	namespace:mods::globals
get_room_list	globals.cpp	/^		player_list_t& get_room_list(room_rnum room){$/;"	f	namespace:mods::globals
get_selling_obj	shop.cpp	/^struct obj_data *get_selling_obj(char_data *ch, char *name, char_data *keeper, int shop_nr, int msg) {$/;"	f
get_shared_ptr	mods/object.cpp	/^	std::shared_ptr<obj_data> object::get_shared_ptr(){$/;"	f	class:mods::object
get_slide_obj_vis	shop.cpp	/^struct obj_data *get_slide_obj_vis(char_data *ch, char *name,$/;"	f
get_string	mods/util.cpp	/^	std::string get_string(int _errno){$/;"	f	namespace:mods::util::err
get_ticks_per_minute	mods/affects.cpp	/^	uint32_t get_ticks_per_minute() {$/;"	f	namespace:mods::affects
get_ticks_per_minute	mods/deferred.cpp	/^ 	uint32_t deferred::get_ticks_per_minute(){$/;"	f	class:mods::deferred
get_time_birth	mods/player.cpp	/^	time_t player::get_time_birth() const {$/;"	f	class:mods::player
get_time_login	mods/player.cpp	/^	time_t player::get_time_login() const {$/;"	f	class:mods::player
get_time_played	mods/player.cpp	/^	int player::get_time_played() const{$/;"	f	class:mods::player
get_type	mods/weapon.cpp	/^	std::variant<mw_rifle,mw_explosive,mw_drone> get_type(obj_data_ptr_t& o){$/;"	f	namespace:mods::weapon
get_type_string	mods/player.cpp	/^	std::string player::get_type_string(){$/;"	f	class:mods::player
get_user	mods/auto-login.cpp	/^	const std::string& get_user() { return mods::auto_login::user; }$/;"	f	namespace:mods::auto_login
get_verb	mods/chat.cpp	/^	std::string_view channel::get_verb() const {$/;"	f	class:mods::chat::channel
get_victim	castle.cpp	/^char_data *get_victim( char_data *ch) {$/;"	f
get_yaml_exception_list	mods/object-utils.hpp	/^	static inline auto& get_yaml_exception_list() {$/;"	f	namespace:mods::object_utils
get_yaml_transaction_id	mods/object-utils.hpp	/^	static inline uint32_t get_yaml_transaction_id(){$/;"	f	namespace:mods::object_utils
give_find_vict	act.item.cpp	/^char_data *give_find_vict(char_data *ch, char *arg) {$/;"	f
glob	mods/util.cpp	/^		directory_list_t glob(std::string_view path){$/;"	f	namespace:mods::util
globals	comm.cpp	/^namespace mods::globals { $/;"	n	class:mods	file:
globals	config.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	db.cpp	/^namespace mods::globals {$/;"	n	class:mods	file:
globals	globals.cpp	/^	namespace globals {$/;"	n	namespace:mods	file:
globals	globals.hpp	/^	namespace globals {$/;"	n	namespace:mods
globals	mods/db.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	mods/deferred.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	mods/lmdb.cpp	/^namespace mods::globals {$/;"	n	class:mods	file:
globals	mods/lmdb.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	mods/player.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	mods/pq.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	mods/projectile.hpp	/^namespace mods::globals {$/;"	n	class:mods
globals	shop.cpp	/^namespace mods::globals {$/;"	n	class:mods	file:
globals	structs.h	/^namespace mods::globals {$/;"	n	class:mods
god_mode	mods/player.cpp	/^	bool player::god_mode() const{$/;"	f	class:mods::player
gods	mods/acl_list.cpp	/^		static player_acl_list_t gods;$/;"	m	namespace:mods::acl_list::list_container	file:
gods	mods/object-utils.hpp	/^	namespace gods {$/;"	n	namespace:mods::object_utils
gods	mods/rooms.cpp	/^namespace mods::rooms::gods {$/;"	n	class:mods::rooms	file:
gods	mods/rooms.hpp	/^	namespace gods {$/;"	n	namespace:mods::rooms
godsend	mods/player.cpp	/^	size_t player::godsend(const char *messg, ...) {$/;"	f	class:mods::player
gold	mods/player.hpp	/^		int& gold() {$/;"	f	struct:mods::player
gold	structs.h	/^		int	gold;$/;"	m	struct:rent_info
good	mods/js.hpp	/^				inline bool good() {$/;"	f	struct:mods::js::include
grab_mobile	mods/builder.cpp	/^char_data* grab_mobile(std::size_t index,bool &fetched){$/;"	f
grab_raw_histfile_seconds	mods/player.cpp	/^	std::string grab_raw_histfile_seconds(){$/;"	f	namespace:mods
grab_tree_by_name	mods/behaviour_tree_impl.cpp	/^	uint8_t grab_tree_by_name(const std::string& sv_tree){$/;"	f	namespace:mods::behaviour_tree_impl
graf	limits.cpp	/^int graf(int grafage, int p0, int p1, int p2, int p3, int p4, int p5, int p6) {$/;"	f
grenade	mods/weapon.hpp	/^		static constexpr uint64_t grenade = (1 << 1);$/;"	m	struct:mods::weapon::mask
grenade_damage	mods/projectile.cpp	/^		int grenade_damage(player_ptr_t victim,obj_ptr_t projectile){$/;"	f	namespace:mods::projectile
grip_t	mods/weapon.hpp	/^	enum grip_t {$/;"	g	namespace:mods::weapon
group_gain	fight.cpp	/^void group_gain(char_data *ch, char_data *victim) {$/;"	f
guests	house.h	/^	long guests[MAX_GUESTS];	\/* idnums of house's guests	*\/$/;"	m	struct:house_control_rec
guild	castle.cpp	/^SPECIAL(guild);$/;"	v
guild	spec_assign.cpp	/^SPECIAL(guild);$/;"	v
guild	spec_procs.cpp	/^SPECIAL(guild);$/;"	v
guild_guard	spec_assign.cpp	/^SPECIAL(guild_guard);$/;"	v
guild_guard	spec_procs.cpp	/^SPECIAL(guild_guard);$/;"	v
guild_info	class.cpp	/^struct guild_info_type guild_info[] = {$/;"	v	typeref:struct:guild_info_type
h_cancel	mods/help.hpp	/^	static constexpr const char* h_cancel = "usage: cancel\\r\\n"$/;"	m	namespace:mods::help::pages
h_grenade	mods/help.hpp	/^	static constexpr const char* h_grenade = "usage: throw <direction> [room_count=4]\\r\\n"$/;"	m	namespace:mods::help::pages
h_install	mods/help.hpp	/^	static constexpr const char* h_install = "usage: install <object> <direction>\\r\\n"$/;"	m	namespace:mods::help::pages
h_set_npc_position	mods/help.hpp	/^	static constexpr const char* h_set_npc_position = "usage: set_npc_position <UUID> <POSITION>\\r\\n"$/;"	m	namespace:mods::help::pages
h_set_position	mods/help.hpp	/^	static constexpr const char* h_set_position = "usage: set_position <POSITION>\\r\\n"$/;"	m	namespace:mods::help::pages
h_view	mods/help.hpp	/^	static constexpr const char* h_view = "usage: view camera\\r\\n"$/;"	m	namespace:mods::help::pages
half_chop	interpreter.cpp	/^void half_chop(char *string, char *arg1, char *arg2) {$/;"	f
handbook	db.cpp	/^char *handbook = NULL;		\/* handbook for new immortals	 *\/$/;"	v
handleErrors	mods/crypto.cpp	/^void handleErrors(void)$/;"	f	namespace:mods::crypto
handle_crit_injure	mods/injure.cpp	/^		void handle_crit_injure(obj_ptr_t& object, player_ptr_t& player){$/;"	f	namespace:mods::injure::explosive
handle_crit_injure	mods/injure.cpp	/^		void handle_crit_injure(obj_ptr_t& object, player_ptr_t& player){$/;"	f	namespace:mods::injure::rifle
handle_crit_injure	mods/injure.cpp	/^	void handle_crit_injure(int critical_chance, int injure_chance, player_ptr_t& victim, int type){$/;"	f	namespace:mods::injure
handle_disconnects	comm.cpp	/^std::size_t handle_disconnects(){$/;"	f
handle_explosion	mods/sensor-grenade.cpp	/^	void handle_explosion(uuid_t nade_uuid, uuid_t player_uuid, room_rnum room_id, int from_direction) {$/;"	f	namespace:mods::sensor_grenade
handle_primary_choice	mods/chargen.cpp	/^	void handle_primary_choice(player_ptr_t p,char arg_choice,player_class_t class_type){$/;"	f	namespace:mods::chargen
hardcoded_iv	mods/crypto.hpp	/^	static std::string hardcoded_iv = "1218749!-Z0*$761";$/;"	m	namespace:mods::crypto
hardcoded_key	mods/crypto.hpp	/^	static std::string hardcoded_key = "1218749!-Z0*$7611218749!-Z0*$761";$/;"	m	namespace:mods::crypto
has_affect	mods/affects.hpp	/^			bool has_affect(TAffects a){$/;"	f	struct:mods::affects::dissolver
has_affect	mods/player.cpp	/^	bool player::has_affect(mods::flags::aff flag){$/;"	f	class:mods::player
has_affect	mods/player.cpp	/^	bool player::has_affect(uint64_t flag){$/;"	f	class:mods::player
has_affect_plr	mods/player.cpp	/^	bool player::has_affect_plr(mods::flags::plr flag) {$/;"	f	class:mods::player
has_affect_plr	mods/player.cpp	/^	bool player::has_affect_plr(uint64_t flag) {$/;"	f	class:mods::player
has_all_affects	mods/affects.hpp	/^			bool has_all_affects(TAffectsContainer in_affects){$/;"	f	struct:mods::affects::dissolver
has_ammo	mods/player.cpp	/^	bool player::has_ammo() {$/;"	f	class:mods::player
has_any_affect	mods/affects.hpp	/^	bool has_any_affect(TAffectsContainer in_affects){$/;"	f	struct:mods::affects::dissolver
has_boat	act.movement.cpp	/^int has_boat(char_data *ch) {$/;"	f
has_builder_data	mods/player.cpp	/^	bool player::has_builder_data(){$/;"	f	class:mods::player
has_class_capability	mods/player.cpp	/^	bool player::has_class_capability(class_type type) {$/;"	f	class:mods::player
has_clip	mods/weapon.hpp	/^	static inline bool has_clip(rifle_data_t* weapon){$/;"	f	namespace:mods::weapon
has_equipment_tag	mods/player.cpp	/^	bool player::has_equipment_tag(const std::string& tag) {$/;"	f	class:mods::player
has_flag	mods/builder.cpp	/^	bool has_flag(player_ptr_t player,uint64_t flag){$/;"	f	namespace:mods::builder
has_flag	mods/player.hpp	/^		bool has_flag(chunk_type_t chunk,aligned_int_t bit) const {$/;"	f	struct:mods::player
has_inventory_capability	mods/player.cpp	/^	bool player::has_inventory_capability(int type) {$/;"	f	class:mods::player
has_key	act.movement.cpp	/^	int has_key(char_data *ch, obj_vnum key) {$/;"	f
has_mail	mail.cpp	/^int has_mail(long recipient) {$/;"	f
has_max_amount	mods/affects.hpp	/^			bool has_max_amount(TAffects affect){$/;"	f	struct:mods::affects::dissolver
has_night_vision	mods/player.cpp	/^	bool player::has_night_vision() const {$/;"	f	class:mods::player
has_quest	mods/quests.cpp	/^		bool has_quest(char_data * ch) {$/;"	f	namespace:mods::quests
has_texture	structs.cpp	/^		bool room_data::has_texture(texture_type_t t){$/;"	f	class:room_data
has_textures	mods/rooms.cpp	/^	bool has_textures(room_rnum r, std::vector<txt> textures){$/;"	f	namespace:mods::rooms
has_thermal_vision	mods/player.cpp	/^	bool player::has_thermal_vision() const {$/;"	f	class:mods::player
has_thermite	mods/player.cpp	/^	bool player::has_thermite() {$/;"	f	class:mods::player
has_tree	mods/npc.cpp	/^	bool npc::has_tree()  {$/;"	f	class:mods::npc
has_weapon_capability	mods/player.cpp	/^	bool player::has_weapon_capability(uint8_t type) {$/;"	f	class:mods::player
hcontrol_build_house	house.cpp	/^void hcontrol_build_house(char_data *ch, char *arg) {$/;"	f
hcontrol_destroy_house	house.cpp	/^void hcontrol_destroy_house(char_data *ch, char *arg) {$/;"	f
hcontrol_list_houses	house.cpp	/^void hcontrol_list_houses(char_data *ch) {$/;"	f
hcontrol_pay_house	house.cpp	/^void hcontrol_pay_house(char_data *ch, char *arg) {$/;"	f
head	db.h	/^	struct reset_q_element *head;$/;"	m	struct:reset_q_type	typeref:struct:reset_q_type::reset_q_element
header_block_type	mail.h	/^typedef struct header_block_type_d header_block_type;$/;"	t	typeref:struct:header_block_type_d
header_block_type_d	mail.h	/^struct header_block_type_d {$/;"	s
header_data	mail.h	/^	struct header_data_type header_data;	\/* other header data		*\/$/;"	m	struct:header_block_type_d	typeref:struct:header_block_type_d::header_data_type
header_data_type	mail.h	/^struct header_data_type {$/;"	s
heading	boards.h	/^	char	*heading;     \/* pointer to message's heading *\/$/;"	m	struct:board_msginfo
heading_len	boards.h	/^	int	heading_len;  \/* size of header (for file write) *\/$/;"	m	struct:board_msginfo
headshot	mods/values.hpp	/^			static inline void headshot(T& p){$/;"	f	namespace:mods::values::msg
headshot_bonus	mods/weapon.hpp	/^			int headshot_bonus;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
heartbeat	comm.cpp	/^void heartbeat(int pulse) {$/;"	f
heartbeat	mods/date-time.cpp	/^	void heartbeat(){$/;"	f	namespace:mods::date_time
heartbeat_counter	mods/date-time.cpp	/^	static uint64_t heartbeat_counter;$/;"	m	namespace:mods::date_time	file:
height	mods/overhead_map.hpp	/^	constexpr static uint8_t height = 16;$/;"	m	namespace:mods::overhead_map
height	mods/player.hpp	/^		ubyte& height(){$/;"	f	struct:mods::player
hell	mods/hell.cpp	/^namespace mods::hell {$/;"	n	class:mods	file:
hell	mods/hell.hpp	/^namespace mods::hell {$/;"	n	class:mods
help	db.cpp	/^char *help = NULL;		\/* help screen			 *\/$/;"	v
help	mods/help.cpp	/^namespace mods::help {$/;"	n	class:mods	file:
help	mods/help.hpp	/^namespace mods::help {$/;"	n	class:mods
help_index_element	db.h	/^struct help_index_element {$/;"	s
help_table	db.cpp	/^struct help_index_element *help_table = 0;	\/* the help table	 *\/$/;"	v	typeref:struct:help_index_element
hide	act.social.cpp	/^	int hide;$/;"	m	struct:social_messg	file:
histfile_opcode_t	mods/player.cpp	/^	enum histfile_opcode_t {$/;"	g	namespace:mods	file:
histfile_type_t	mods/player.cpp	/^enum histfile_type_t {$/;"	g	file:
hit	fight.cpp	/^void hit(char_data *ch, char_data *victim, int type) {$/;"	f
hit	mods/js.cpp	/^		static duk_ret_t hit(duk_context *ctx) {$/;"	f	namespace:mods::js
hit	mods/values.hpp	/^			static inline void hit(T& p){$/;"	f	namespace:mods::values::msg
hit_gain	limits.cpp	/^int hit_gain(char_data *ch) {$/;"	f
hitroll	mods/player.hpp	/^		sbyte& hitroll() {$/;"	f	struct:mods::player
hits_target	mods/weapon.cpp	/^	bool hits_target(player_ptr_t& player, obj_ptr_t& weapon, player_ptr_t& target, uint16_t* distance){$/;"	f	namespace:mods::weapon
holds_ammo	structs.h	/^		bool holds_ammo;$/;"	m	struct:obj_flag_data
holler_move_cost	config.cpp	/^int holler_move_cost = 20;$/;"	v
hometown	mods/player.hpp	/^		sh_int& hometown(){$/;"	f	struct:mods::player
host	mods/player.cpp	/^	std::string player::host() const {$/;"	f	class:mods::player
hour	mods/date-time.cpp	/^	static uint8_t hour;$/;"	m	namespace:mods::date_time	file:
house_control	house.cpp	/^struct house_control_rec house_control[MAX_HOUSES];$/;"	v	typeref:struct:house_control_rec
house_control_rec	house.h	/^struct house_control_rec {$/;"	s
how_good	spec_procs.cpp	/^const char *how_good(int percent) {$/;"	f
hp	mods/player.hpp	/^		sh_int& hp() {$/;"	f	struct:mods::player
hsort	db.cpp	/^int hsort(const void *a, const void *b) {$/;"	f
hunt_victim	graph.cpp	/^void hunt_victim(char_data *ch) {$/;"	f
hunting	mods/player.hpp	/^		char_data* hunting(){$/;"	f	struct:mods::player
hupsig	comm.cpp	/^RETSIGTYPE hupsig(int sig) {$/;"	f
id	db.h	/^	long id;$/;"	m	struct:player_index_element
id	mods/behaviour_tree_node.hpp	/^			uint64_t id;\\$/;"	m	struct:mods::behaviour_tree_node::__anon2
idle_max_level	config.cpp	/^int idle_max_level = LVL_GOD;$/;"	v
idle_rent_time	config.cpp	/^int idle_rent_time = 48;$/;"	v
idle_void	config.cpp	/^int idle_void = 8;$/;"	v
if_flag	db.h	/^	bool if_flag;	\/* if TRUE: exe only if preceding exe'd *\/$/;"	m	struct:reset_com
immlist	db.cpp	/^char *immlist = NULL;		\/* list of peon gods		 *\/$/;"	v
immort_level_ok	config.cpp	/^int immort_level_ok = 0;$/;"	v
immort_start_room	config.cpp	/^room_vnum immort_start_room = 0;$/;"	v
immortal	mods/immortal.cpp	/^namespace mods::immortal {$/;"	n	class:mods	file:
immortal	mods/immortal.hpp	/^namespace mods::immortal {$/;"	n	class:mods
imotd	db.cpp	/^char *imotd = NULL;		\/* message of the day - immorts *\/$/;"	v
implementor_mode	mods/player.cpp	/^	bool player::implementor_mode() const{$/;"	f	class:mods::player
implementors	mods/acl_list.cpp	/^		static player_acl_list_t implementors;$/;"	m	namespace:mods::acl_list::list_container	file:
import	structs.cpp	/^		void char_data::import(const char_data* o){$/;"	f	class:char_data
import	structs.cpp	/^		void mob_special_data::import(const mob_special_data& other){$/;"	f	class:mob_special_data
import_room	mods/builder.cpp	/^	int import_room(struct room_data* room) {$/;"	f	namespace:mods::builder
in_addr	sysdep.h	/^struct in_addr {$/;"	s
in_obj	structs.h	/^		obj_data *in_obj;       \/* In what object NULL when none    *\/$/;"	m	struct:obj_data
in_room	mods/js.cpp	/^		static duk_ret_t in_room(duk_context *ctx) {$/;"	f	namespace:mods::js
in_room	shop.h	/^	room_vnum *in_room;		\/* Where is the shop?			*\/$/;"	m	struct:shop_data
in_room	structs.h	/^		room_rnum in_room;		\/* In what room -1 when conta\/carr	*\/$/;"	m	struct:obj_data
include	mods/js.hpp	/^				include(duk_context *ctx,std::string_view directory,std::string_view file)$/;"	f	struct:mods::js::include
include	mods/js.hpp	/^				include(duk_context *ctx,std::string_view file)$/;"	f	struct:mods::js::include
include	mods/js.hpp	/^		struct include {$/;"	s	namespace:mods::js
include_file	mods/js.cpp	/^		bool include::include_file() {$/;"	f	class:mods::js::include
increment_bad_password_count	mods/player.cpp	/^	void player::increment_bad_password_count(){$/;"	f	class:mods::player
increment_hour	mods/date-time.cpp	/^	void increment_hour() {$/;"	f	namespace:mods::date_time
increment_yaml_transaction_id	mods/object-utils.hpp	/^	static inline void increment_yaml_transaction_id(){$/;"	f	namespace:mods::object_utils
index_boot	db.cpp	/^void index_boot(int mode) {$/;"	f
index_boot_hlp	mods/hell.hpp	/^	constexpr inline bool index_boot_hlp = true;$/;"	m	namespace:mods::hell
index_mail	mail.cpp	/^void index_mail(long id_to_index, long pos) {$/;"	f
info	db.cpp	/^char *info = NULL;		\/* info page			 *\/$/;"	v
init	globals.cpp	/^		void init(int argc,char** argv) {$/;"	f	namespace:mods::globals
init	mods/debug.hpp	/^	static inline void init(bool tics){ debug_state = std::make_unique<state>(tics); }$/;"	f	namespace:mods::debug
init	mods/object.cpp	/^	void object::init(){$/;"	f	class:mods::object
init	mods/player.cpp	/^	void player::init(){$/;"	f	class:mods::player
init	mods/rand.hpp	/^	static void init() {$/;"	f	namespace:mods::rand
init	shop.cpp	/^void shop_data<TOrmType,T,R>::init(){$/;"	f	class:shop_data
init	structs.cpp	/^		void char_data::init(){$/;"	f	class:char_data
init	structs.cpp	/^		void mob_special_data::init(){$/;"	f	class:mob_special_data
init	structs.cpp	/^		void room_data::init(){$/;"	f	class:room_data
init	structs.cpp	/^void obj_data::init(){$/;"	f	class:obj_data
init	structs.cpp	/^void obj_flag_data::init(){$/;"	f	class:obj_flag_data
init_boards	boards.cpp	/^void init_boards(void) {$/;"	f
init_char	db.cpp	/^void init_char(player_ptr_t player) {$/;"	f
init_game	comm.cpp	/^void init_game(ush_int port) {$/;"	f
init_player	globals.cpp	/^		void init_player(char_data* ch) {$/;"	f	namespace:mods::globals
init_player_levels	mods/skills.cpp	/^	void init_player_levels(player_ptr_t& player){$/;"	f	namespace:mods::skills
init_player_levels	mods/skills.cpp	/^	void init_player_levels(std::string_view player_name){$/;"	f	namespace:mods::skills
init_socket	comm.cpp	/^socket_t init_socket(ush_int port) {$/;"	f
init_spell_levels	class.cpp	/^void init_spell_levels(void) {$/;"	f
init_spell_levels	mods/hell.hpp	/^	constexpr inline bool init_spell_levels = false;$/;"	m	namespace:mods::hell
initialize_all	mods/date-time.cpp	/^	void initialize_all(uint8_t month,uint8_t day,uint8_t year,uint8_t hour,uint8_t moon_phase_index) {$/;"	f	namespace:mods::date_time
initialize_builder	mods/builder.cpp	/^	void initialize_builder(player_ptr_t& player){$/;"	f	namespace:mods::builder
initialize_date	mods/date-time.cpp	/^	void initialize_date(uint8_t month,uint8_t day,uint8_t year) {$/;"	f	namespace:mods::date_time
initialize_player	mods/player-scaffolding.cpp	/^	int player_scaffolding::initialize_player(player_ptr_t player,int to_room){$/;"	f	class:mods::player_scaffolding
initialize_row	mods/db.cpp	/^aligned_int_t initialize_row($/;"	f	namespace:mods::db
initialize_table_schema	mods/db.hpp	/^static inline int_status_t initialize_table_schema(std::string table){$/;"	f
initialized	mods/rand.hpp	/^	static bool initialized = false;$/;"	m	namespace:mods::rand
initiator	mods/object-utils.hpp	/^		std::string initiator;$/;"	m	struct:mods::object_utils::YamlFeedExceptionInfo
injure	mods/injure.cpp	/^namespace mods::injure {$/;"	n	class:mods	file:
injure	mods/injure.hpp	/^namespace mods::injure {$/;"	n	class:mods
injure	mods/projectile.cpp	/^namespace mods::injure {$/;"	n	class:mods	file:
injure_player	mods/injure.cpp	/^	void injure_player(player_ptr_t& person){$/;"	f	namespace:mods::injure
inner_join	mods/sql.hpp	/^			compositor<T>& inner_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
insert	mods/sql.hpp	/^			compositor<T>& insert() {$/;"	f	struct:mods::sql::compositor
install_shop	db.cpp	/^int16_t install_shop(shop_ptr_t& shop){$/;"	f
instantiate_object_by_index	mods/builder.cpp	/^	std::optional<obj_data*> instantiate_object_by_index(int index) {$/;"	f	namespace:mods::builder
instantiate_object_by_vnum	mods/builder.cpp	/^	std::optional<obj_data*> instantiate_object_by_vnum(int vnum) {$/;"	f	namespace:mods::builder
instantiate_object_vector	mods/builder_util.hpp	/^	void instantiate_object_vector($/;"	f	namespace:mods::builder_util
int_app	constants.cpp	/^cpp_extern const struct int_app_type int_app[] = {$/;"	v	typeref:struct:int_app_type
int_app	constants.hpp	/^cpp_extern const struct int_app_type int_app[] = {$/;"	v	typeref:struct:int_app_type
int_types	mods/values.cpp	/^		static const std::vector<std::string> int_types = {$/;"	m	namespace:mods::values	file:
interpret	mods/drone.cpp	/^	 bool drone::interpret(char_data *owner,const std::string& argument) {$/;"	f	class:mods::drone
interpret_espec	db.cpp	/^void interpret_espec(const char *keyword, const char *value, int i, int nr) {$/;"	f
into	mods/sql.hpp	/^			compositor<T>& into(str_object table) {$/;"	f	struct:mods::sql::compositor
invalid_align	handler.cpp	/^int invalid_align(char_data *ch, struct obj_data *obj) {$/;"	f
invalid_class	class.cpp	/^int invalid_class(char_data *ch, struct obj_data *obj) {$/;"	f
invalid_list	ban.cpp	/^char *invalid_list[MAX_INVALID_NAMES];$/;"	v
inventory	mods/player.cpp	/^namespace mods::orm::inventory {$/;"	n	class:mods::orm	file:
invoke	mods/catch.hpp	/^			virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase
irl	mods/date-time.cpp	/^	namespace irl {$/;"	n	namespace:mods::date_time	file:
irl	mods/date-time.hpp	/^	namespace irl {$/;"	n	namespace:mods::date_time
is	mods/player.hpp	/^		bool is(char_data* ch) const { return ch == m_char_data; }$/;"	f	struct:mods::player
is	mods/player.hpp	/^		bool is(player_ptr_t p) const { return m_char_data == p->cd(); }$/;"	f	struct:mods::player
isBinaryExpression	mods/catch.hpp	/^			virtual bool isBinaryExpression() const {$/;"	f	struct:Catch::DecomposedExpression
isFalseTest	mods/catch.hpp	/^	inline bool isFalseTest(int flags)                {$/;"	f	namespace:Catch
isJustInfo	mods/catch.hpp	/^	inline bool isJustInfo(int flags) {$/;"	f	namespace:Catch
isOk	mods/catch.hpp	/^	inline bool isOk(ResultWas::OfType resultType) {$/;"	f	namespace:Catch
isTrue	mods/catch.hpp	/^	inline bool isTrue(bool value) {$/;"	f	namespace:Catch
is_abbrev	interpreter.cpp	/^int is_abbrev(const char *arg1, const char *arg2) {$/;"	f
is_ammo	structs.h	/^		bool is_ammo;$/;"	m	struct:obj_flag_data
is_blocked	mods/player.cpp	/^	bool player::is_blocked(){ return m_blocked_until != 0; }$/;"	f	class:mods::player
is_breach_charge	mods/object-utils.hpp	/^	static inline bool is_breach_charge(T& obj){$/;"	f	namespace:mods::object_utils
is_camera	mods/object-utils.hpp	/^	static inline bool is_camera(T& obj){$/;"	f	namespace:mods::object_utils
is_cancel_command	mods/player-utils.hpp	/^		inline bool is_cancel_command(const std::string& arg){$/;"	f	namespace:mods::player_utils
is_cancel_command	mods/player-utils.hpp	/^		inline bool is_cancel_command(const std::string_view& arg){$/;"	f	namespace:mods::player_utils
is_cancel_command	mods/player-utils.hpp	/^	static inline bool is_cancel_command(T& arg){$/;"	f	namespace:mods::player_utils
is_capable_of_all	mods/item.cpp	/^		bool is_capable_of_all(player_ptr_t& player, obj_ptr_t& object, cap_list_t& actions){$/;"	f	namespace:mods::item
is_capable_of_any	mods/item.cpp	/^		bool is_capable_of_any(player_ptr_t& player, obj_ptr_t& object, cap_list_t& actions){$/;"	f	namespace:mods::item
is_capable_of_single	mods/item.cpp	/^		bool is_capable_of_single(player_ptr_t& player, obj_ptr_t& object, capability_t action){$/;"	f	namespace:mods::item
is_claymore	mods/object-utils.hpp	/^	static inline bool is_claymore(T& obj){$/;"	f	namespace:mods::object_utils
is_dark	mods/rooms.hpp	/^	inline bool is_dark(room_data& room) {$/;"	f	namespace:mods::rooms
is_dark	mods/rooms.hpp	/^	static inline bool is_dark(room_rnum room) {$/;"	f	namespace:mods::rooms
is_dir_breachable	mods/doors.hpp	/^	static inline bool is_dir_breachable(const room_rnum  room, int direction){$/;"	f	namespace:mods::doors
is_dir_electrified	mods/doors.hpp	/^	static inline bool is_dir_electrified(const room_rnum room, int direction){$/;"	f	namespace:mods::doors
is_dir_thermite_breachable	mods/doors.hpp	/^	static inline bool is_dir_thermite_breachable(const room_rnum  room, int direction){$/;"	f	namespace:mods::doors
is_directory	mods/filesystem.hpp	/^	static inline bool is_directory(const std::string& path){$/;"	f	namespace:mods::filesystem
is_empty	db.cpp	/^int is_empty(zone_rnum zone_nr) {$/;"	f
is_executing_js	mods/player.cpp	/^	bool player::is_executing_js() const {$/;"	f	class:mods::player
is_fighting	mods/player.hpp	/^		bool is_fighting(char_data* ch){$/;"	f	struct:mods::player
is_fighting	mods/player.hpp	/^		bool is_fighting(player_ptr_t p){$/;"	f	struct:mods::player
is_file	mods/filesystem.hpp	/^	static inline bool is_file(const std::string& path){$/;"	f	namespace:mods::filesystem
is_installed	mods/object-utils.hpp	/^		bool is_installed(T& obj){$/;"	f	namespace:mods::object_utils
is_installing	mods/object-utils.hpp	/^		bool is_installing(T& obj){$/;"	f	namespace:mods::object_utils
is_installing	mods/player-utils.hpp	/^		static inline bool is_installing(T& player){$/;"	f	namespace:mods::player_utils
is_int	mods/values.cpp	/^		bool is_int(std::string key){$/;"	f	namespace:mods::values
is_lower_match	mods/util.hpp	/^	static inline bool is_lower_match(std::string_view str1,std::string_view str2){$/;"	f	namespace:mods::util
is_night_vision_camera	mods/object-utils.hpp	/^	inline bool is_night_vision_camera(uuid_t obj_uuid){$/;"	f	namespace:mods::object_utils
is_night_vision_camera	mods/object-utils.hpp	/^	inline bool is_night_vision_camera(uuid_t& obj_uuid){$/;"	f	namespace:mods::object_utils
is_night_vision_camera	mods/object-utils.hpp	/^	static inline bool is_night_vision_camera(T obj){$/;"	f	namespace:mods::object_utils
is_night_vision_camera	mods/object-utils.hpp	/^	static inline bool is_night_vision_camera(T& obj){$/;"	f	namespace:mods::object_utils
is_nobody	mods/player.hpp	/^		bool is_nobody() const { return m_char_data == nullptr; }$/;"	f	struct:mods::player
is_npc	mods/player.hpp	/^		bool is_npc() const {$/;"	f	struct:mods::player
is_number	interpreter.cpp	/^int is_number(const char *str) {$/;"	f
is_ok	shop.cpp	/^int is_ok(char_data *keeper, char_data *ch, int shop_nr) {$/;"	f
is_ok_char	shop.cpp	/^int is_ok_char(char_data *keeper, char_data *ch, int shop_nr) {$/;"	f
is_on_fire	mods/rooms.hpp	/^		static inline bool is_on_fire(TRoom room) {$/;"	f	namespace:mods::rooms
is_open	mods/doors.hpp	/^	static inline bool is_open(const room_rnum  room, int direction){$/;"	f	namespace:mods::doors
is_open	shop.cpp	/^int is_open(char_data *keeper, int shop_nr, int msg) {$/;"	f
is_owner	mods/object-utils.hpp	/^		bool is_owner(T& obj, PlayerT& player){$/;"	f	namespace:mods::object_utils
is_peaceful	mods/rooms.hpp	/^	static inline bool is_peaceful(room_rnum room){$/;"	f	namespace:mods::rooms
is_scanned	mods/player-utils.hpp	/^	static inline bool is_scanned(T& player){$/;"	f	namespace:mods::player_utils
is_smoked	mods/rooms.hpp	/^		static inline bool is_smoked(TRoom room) {$/;"	f	namespace:mods::rooms
is_string	mods/values.cpp	/^		bool is_string(std::string key){$/;"	f	namespace:mods::values
is_tell_ok	act.comm.cpp	/^int is_tell_ok(char_data *ch, char_data *vict) {$/;"	f
is_thermal_camera	mods/object-utils.hpp	/^	inline bool is_thermal_camera(uuid_t obj_uuid){$/;"	f	namespace:mods::object_utils
is_thermal_camera	mods/object-utils.hpp	/^	inline bool is_thermal_camera(uuid_t& obj_uuid){$/;"	f	namespace:mods::object_utils
is_thermal_camera	mods/object-utils.hpp	/^	static inline bool is_thermal_camera(T obj){$/;"	f	namespace:mods::object_utils
is_thermal_camera	mods/object-utils.hpp	/^	static inline bool is_thermal_camera(T& obj){$/;"	f	namespace:mods::object_utils
is_trash	castle.cpp	/^int is_trash(struct obj_data *i) {$/;"	f
is_uint16	mods/values.cpp	/^		bool is_uint16(std::string key){$/;"	f	namespace:mods::values
is_uint8	mods/values.cpp	/^		bool is_uint8(std::string key){$/;"	f	namespace:mods::values
is_using_pluck_filter	mods/lmdb.cpp	/^		bool _db_handle::is_using_pluck_filter() const { $/;"	f	class:mods::lmdb::_db_handle
is_valid_name	login.cpp	/^	bool is_valid_name(std::string_view name){$/;"	f	namespace:login
is_weapon_loaded	mods/player.cpp	/^	bool player::is_weapon_loaded() {$/;"	f	class:mods::player
isascii	sysdep.h	343;"	d
isbanned	ban.cpp	/^int isbanned(const char *hostname) {$/;"	f
isbanned	mods/ban_system.hpp	/^		bool isbanned(const std::string &m){ \/** FIXME *\/ return false; }$/;"	f	namespace:mods::ban_system
isname	handler.cpp	/^int isname(const char *str, const char *namelist) {$/;"	f
item	mods/item.cpp	/^namespace mods::item {$/;"	n	class:mods	file:
item	mods/item.hpp	/^namespace mods::item {$/;"	n	class:mods
item_number	structs.h	/^		obj_vnum item_number;	\/* Where in data-type			*\/$/;"	m	struct:obj_data
item_number	structs.h	/^		obj_vnum item_number;$/;"	m	struct:obj_file_elem
item_types	constants.cpp	/^const char *item_types[] = {$/;"	v
item_types	constants.hpp	/^const char *item_types[] = {$/;"	v
iteration	mods/deferred.cpp	/^	void deferred::iteration() {$/;"	f	class:mods::deferred
itoa	mods/util.cpp	/^	std::string itoa(int number) {$/;"	f	namespace:mods::util
janitor	spec_assign.cpp	/^SPECIAL(janitor);$/;"	v
janitor	spec_procs.cpp	/^SPECIAL(janitor);$/;"	v
jerry	castle.cpp	/^SPECIAL(jerry);$/;"	v
js	fight.cpp	/^namespace mods::js {$/;"	n	class:mods	file:
js	interpreter.cpp	/^namespace mods::js { $/;"	n	class:mods	file:
js	mods/js.cpp	/^	namespace js {$/;"	n	namespace:mods	file:
js	mods/js.hpp	/^	namespace js {$/;"	n	namespace:mods
js_object	mods/player.cpp	/^	std::string player::js_object() {$/;"	f	class:mods::player
jx	mods/jx.hpp	/^namespace mods::jx {$/;"	n	class:mods
keeper	shop.h	/^	mob_vnum	 keeper;	\/* The mobile who owns the shop (rnum)	*\/$/;"	m	struct:shop_data
key	structs.h	/^		obj_vnum key;		\/* Key's number (-1 for no key)		*\/$/;"	m	struct:room_direction_data
key_exists	mods/db.cpp	/^bool key_exists(std::string key){$/;"	f
keyval_first	mods/util-map.hpp	/^			Tkey keyval_first(std::map<Tkey,Tval>& m,const Tval value,Tkey default_value) {$/;"	f	namespace:mods::util::maps
keyword	db.h	/^	char	*keyword;$/;"	m	struct:help_index_element
keyword	mods/extra_desc_data.hpp	/^		mods::string keyword;$/;"	m	struct:mods::extra_desc_data
keyword	structs.h	/^		mods::string keyword;		\/* for open\/close			*\/$/;"	m	struct:room_direction_data
keyword	structs.h	/^		mods::string keyword;                 \/* Keyword in look\/examine          *\/$/;"	m	struct:extra_descr_data
keywords	shop.h	/^	char *keywords;$/;"	m	struct:shop_buy_data
king_welmar	castle.cpp	/^SPECIAL(king_welmar);$/;"	v
knockback_room	mods/doors.hpp	/^	static inline void knockback_room(const room_rnum room,int door){$/;"	f	namespace:mods::doors
last_payment	house.h	/^	time_t last_payment;		\/* date of last house payment   *\/$/;"	m	struct:house_control_rec
lastsort	shop.h	/^	int	 lastsort;		\/* How many items are sorted in inven?	*\/$/;"	m	struct:shop_data
lax_generator	mods/rand.hpp	/^	static std::default_random_engine lax_generator;$/;"	m	namespace:mods::rand
leave_quest	mods/quests.cpp	/^		void leave_quest(char_data* ch,int quest_id) {$/;"	f	namespace:mods::quests
left_join	mods/sql.hpp	/^			compositor<T>& left_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
left_outer_join	mods/sql.hpp	/^			compositor<T>& left_outer_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
len	shop.h	/^	int len;$/;"	m	struct:stack_data
length	modify.cpp	/^int length[] = {$/;"	v
length	mods/string.cpp	/^	unsigned int string::length() const {$/;"	f	class:mods::string
lense_type_t	structs.h	/^enum lense_type_t {$/;"	g
level	act.wizard.cpp	/^	const char level;$/;"	m	struct:set_struct	file:
level	boards.h	/^	int	level;        \/* level of poster *\/$/;"	m	struct:board_msginfo
level	mods/player.hpp	/^		byte& level(){$/;"	f	struct:mods::player
level_can_shout	config.cpp	/^int level_can_shout = 1;$/;"	v
level_exp	class.cpp	/^int level_exp(int chclass, int level) {$/;"	f
lifespan	db.h	/^	int	lifespan;           \/* how long between resets (minutes)  *\/$/;"	m	struct:zone_data
light	structs.h	/^		byte light;                  \/* Number of lightsources in room     *\/$/;"	v
line	db.h	/^	int line;		\/* line number this command appears on  *\/$/;"	m	struct:reset_com
line	mods/catch.hpp	/^		std::size_t line;$/;"	m	struct:Catch::SourceLineInfo
lineInfo	mods/catch.hpp	/^		SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo
linked_list_remove	mods/util.hpp	/^		inline void linked_list_remove(T item, T head) {$/;"	f	namespace:mods::util
list	mods/skills.hpp	/^		static std::vector<std::tuple<std::string,std::vector<proficiencies::proficiency_t>>> list = {$/;"	m	namespace:mods::skills::proficiencies
list_all_shops	shop.cpp	/^void list_all_shops(char_data *ch) {$/;"	f
list_char_to_char	act.informative.cpp	/^void list_char_to_char(char_data *ch) {$/;"	f
list_container	mods/acl_list.cpp	/^	namespace list_container{$/;"	n	namespace:mods::acl_list	file:
list_detailed_shop	shop.cpp	/^void list_detailed_shop(char_data *ch, int shop_nr) {$/;"	f
list_line	mods/builder_util.hpp	/^		void list_line(TPlayer& player, const std::string& key, ObjectType& value){$/;"	f	namespace:mods::builder_util
list_obj_to_char	act.informative.cpp	/^void list_obj_to_char(struct obj_data *list, char_data *ch, int mode, int show) {$/;"	f
list_object	shop.cpp	/^char *list_object(struct obj_data *obj, int cnt, int aindex, int shop_nr, char_data *keeper, char_data *ch) {$/;"	f
list_object_vector	mods/builder_util.hpp	/^	void list_object_vector($/;"	f	namespace:mods::builder_util
list_one_char	act.informative.cpp	/^void list_one_char(char_data *i, char_data *ch) {$/;"	f
list_quests	mods/quests.cpp	/^		static duk_ret_t list_quests(duk_context *ctx) {$/;"	f	namespace:mods::quests
list_quests	mods/quests.cpp	/^		std::vector<std::string> list_quests(room_rnum room_id) {$/;"	f	namespace:mods::quests
list_rounds	mods/weapon.cpp	/^	void list_rounds(player_ptr_t& player,obj_ptr_t& obj){$/;"	f	namespace:mods::weapon
list_rounds	mods/weapon.hpp	/^	static inline void list_rounds(TPlayer& player,TObject& obj){$/;"	f	namespace:mods::weapon
list_shop_items	mods/shop.hpp	/^	static inline void list_shop_items(player_ptr_t& player,TShopMap& shop_map){$/;"	f	namespace:mods::shop
list_skills	spec_procs.cpp	/^void list_skills(char_data *ch) {$/;"	f
list_start	mail.h	/^	position_list_type *list_start;	\/* list of mail positions	*\/$/;"	m	struct:mail_index_type_d
list_to_char	shop.cpp	/^void shop_data<mods::orm::shop,mods::orm::shop_rooms,mods::orm::shop_objects>::list_to_char(player_ptr_t& player){$/;"	f	class:shop_data
list_top	act.social.cpp	/^static int list_top = -1;$/;"	v	file:
listeners	mods/events.cpp	/^	static listener_collection_t listeners;$/;"	m	namespace:mods::events	file:
lmdb	globals.hpp	/^	namespace lmdb { $/;"	n	namespace:mods
lmdb	mods/db.hpp	/^namespace mods::lmdb {$/;"	n	class:mods
lmdb	mods/lmdb.cpp	/^namespace mods::lmdb {$/;"	n	class:mods	file:
lmdb	mods/lmdb.hpp	/^namespace mods::lmdb {$/;"	n	class:mods
lmdb	mods/player.cpp	/^namespace mods::orm::inventory::lmdb {$/;"	n	class:mods::orm::inventory	file:
lmdb_commit	mods/db.cpp	/^void lmdb_commit(){$/;"	f	namespace:mods::db
lmdb_debug	mods/lmdb.cpp	/^	void lmdb_debug(std::string f){ std::cerr << "[lmdb_debug]:'" << f << "'\\n"; }$/;"	f	namespace:mods::lmdb
lmdb_debug	mods/lmdb.cpp	118;"	d	file:
lmdb_del	mods/db.cpp	/^void lmdb_del(std::string key){$/;"	f	namespace:mods::db
lmdb_exists	mods/db.cpp	/^bool lmdb_exists(std::string key) {$/;"	f	namespace:mods::db
lmdb_export_char	mods/db.cpp	/^void lmdb_export_char(player_ptr_t player_ptr, mutable_map_t &values){$/;"	f	namespace:mods::db
lmdb_get	mods/db.cpp	/^std::string lmdb_get(std::string_view key){$/;"	f	namespace:mods::db
lmdb_ndel	mods/db.cpp	/^void lmdb_ndel(void* key,std::size_t key_size){$/;"	f	namespace:mods::db
lmdb_nget	mods/db.cpp	/^int lmdb_nget(void* key,std::size_t k_size,std::string& value){$/;"	f	namespace:mods::db
lmdb_nget_void	mods/db.cpp	/^int lmdb_nget_void(void* key,std::size_t k_size,void* value){$/;"	f	namespace:mods::db
lmdb_nput	mods/db.cpp	/^int lmdb_nput(void* key,std::size_t key_size,$/;"	f	namespace:mods::db
lmdb_put	mods/db.cpp	/^void lmdb_put(std::string key,std::string value){$/;"	f	namespace:mods::db
lmdb_renew	mods/db.cpp	/^void lmdb_renew() {$/;"	f	namespace:mods::db
lmdb_write_values	mods/db.cpp	/^tuple_status_t lmdb_write_values($/;"	f	namespace:mods::db
load_all	mods/world-configuration.cpp	/^	rooms_t load_all() {$/;"	f	namespace:mods::world_conf
load_banned	ban.cpp	/^void load_banned(void) {$/;"	f
load_banned	mods/hell.hpp	/^	constexpr inline bool load_banned = false;$/;"	m	namespace:mods::hell
load_base_functions	mods/js.cpp	/^		void load_base_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_c_functions	mods/js.cpp	/^		void load_c_functions() {$/;"	f	namespace:mods::js
load_c_functions	mods/js.cpp	/^		void load_c_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_c_functions	mods/quests.cpp	/^		void load_c_functions(duk_context *ctx) {$/;"	f	namespace:mods::quests
load_c_require_functions	mods/js.cpp	/^		void load_c_require_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_c_test_functions	mods/js.cpp	/^		void load_c_test_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_char_pkid	db.cpp	/^	int16_t load_char_pkid(player_ptr_t& player){$/;"	f	namespace:db
load_char_prefs	db.cpp	/^	int16_t load_char_prefs(player_ptr_t& player){$/;"	f	namespace:db
load_from_lmdb	mods/values.cpp	/^		void load_from_lmdb(std::string in_key){$/;"	f	namespace:mods::values
load_help	db.cpp	/^void load_help(FILE *fl) {$/;"	f
load_into_inventory	config.cpp	/^int load_into_inventory = NO;$/;"	v
load_library	mods/js.cpp	/^		int load_library(duk_context *ctx,std::string_view file) {$/;"	f	namespace:mods::js
load_messages	fight.cpp	/^void load_messages(void) {$/;"	f
load_messages	mods/hell.hpp	/^	constexpr inline bool load_messages = false;$/;"	m	namespace:mods::hell
load_mods_player_functions	mods/js.cpp	/^		void load_mods_player_functions(duk_context *ctx) {$/;"	f	namespace:mods::js
load_player_levels	mods/skills.cpp	/^	void load_player_levels(player_ptr_t& player){$/;"	f	namespace:mods::skills
load_quest_code	mods/quests.cpp	/^		void load_quest_code(char_data* ch) {$/;"	f	namespace:mods::quests
load_record	mods/db.cpp	/^int load_record(const std::string& table, aligned_int_t pk, mutable_map_t& values){$/;"	f	namespace:mods::db
load_record	mods/db.cpp	/^int load_record(const std::string& table, const std::string& pk, mutable_map_t& values){$/;"	f	namespace:mods::db
load_record_by_meta	mods/db.cpp	/^int load_record_by_meta(const std::string& table, mutable_map_t* values,mutable_map_t& out_record){$/;"	f	namespace:mods::db
load_trees	mods/behaviour_tree_impl.cpp	/^	void load_trees(){$/;"	f	namespace:mods::behaviour_tree_impl
load_zones	db.cpp	/^void load_zones(FILE *fl, char *zonename) {$/;"	f
location	structs.h	/^		byte location;      \/* Which ability to change (APPLY_XXX) *\/$/;"	m	struct:obj_affected_type
location	structs.h	/^		sh_int location;$/;"	m	struct:obj_file_elem
location_data	structs.h	/^		location_data_t location_data(){ return m_location_data; }$/;"	f	struct:obj_data
log	utils.cpp	/^void log(const char* format,...) {$/;"	f
log	utils.cpp	/^void log(mods::string n) {$/;"	f
log_death_trap	utils.cpp	/^void log_death_trap(char_data *ch) {$/;"	f
log_js_error	mods/js.cpp	/^		void log_js_error(std::string_view error) {$/;"	f	namespace:mods::js
log_zone_error	db.cpp	/^void log_zone_error(zone_rnum zone, int cmd_no, const char *message) {$/;"	f
logfile	comm.cpp	/^FILE *logfile = NULL;		\/* Where to send the log messages. *\/$/;"	v
login	db.cpp	/^bool login(std::string_view user_name,std::string_view password){$/;"	f
login	login.cpp	/^namespace login {$/;"	n	file:
login	login.hpp	/^namespace login {$/;"	n
logstrerror	comm.cpp	/^void logstrerror(std::string_view prefix,int _errno){$/;"	f
logtypes	act.wizard.cpp	/^const char *logtypes[] = {$/;"	v
long_descr	mods/player.hpp	/^		mods::string& long_descr(){$/;"	f	struct:mods::player
look_at_char	act.informative.cpp	/^void look_at_char(char_data *i, char_data *ch) {$/;"	f
look_at_room	act.informative.cpp	/^void look_at_room(char_data *ch, int ignore_brief) {$/;"	f
look_at_target	act.informative.cpp	/^void look_at_target(char_data *ch, char *arg) {$/;"	f
look_in_direction	act.informative.cpp	/^void look_in_direction(char_data *ch, int dir) {$/;"	f
look_in_obj	act.informative.cpp	/^void look_in_obj(char_data *ch, char *arg) {$/;"	f
loops	mods/loops.cpp	/^namespace mods::loops {$/;"	n	class:mods	file:
loops	mods/loops.hpp	/^namespace mods::loops {$/;"	n	class:mods
los_find	mods/scan.cpp	/^	find_results_t los_find(chptr hunter,chptr hunted){$/;"	f	namespace:mods::scan
los_list_by_room	mods/scan.cpp	/^	void los_list_by_room(room_rnum& in_room,room_list_t & room_list,unsigned depth){$/;"	f	namespace:mods::scan
los_list_rooms	mods/scan.cpp	/^	void los_list_rooms(chptr player_hunter,room_list_t & room_list,unsigned depth){$/;"	f	namespace:mods::scan
los_scan	mods/scan.cpp	/^	void los_scan(char_data* ch,int depth,vec_player_data* vec_room_list) {$/;"	f	namespace:mods::scan
los_scan_direction	mods/scan.cpp	/^	void los_scan_direction(char_data* ch,int depth,vec_player_data* vec_room_list,int direction) {$/;"	f	namespace:mods::scan
ls	act.builder.cpp	/^	void ls(player_ptr_t player,std::string_view _path) {$/;"	f	namespace:mods::fs
m	random.cpp	45;"	d	file:
m_affected_by	mods/player.hpp	/^		std::vector<affected_type> m_affected_by;$/;"	m	struct:mods::player
m_affects	mods/affects.hpp	/^			TAffectsMap m_affects;$/;"	m	struct:mods::affects::dissolver
m_affects	mods/player.hpp	/^		affect_dissolver_t m_affects;$/;"	m	struct:mods::player
m_allocate	mods/string.cpp	/^	void string::m_allocate(){$/;"	f	class:mods::string
m_assertionInfo	mods/catch.hpp	/^			AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder
m_attacking_with	mods/player.hpp	/^		obj_ptr_t m_attacking_with;$/;"	m	struct:mods::player
m_authenticated	mods/player.hpp	/^		bool m_authenticated;$/;"	m	struct:mods::player
m_block_data	mods/player.hpp	/^		std::unordered_map<uint32_t,uuid_t> m_block_data;$/;"	m	struct:mods::player
m_block_event	mods/player.hpp	/^		event_queue_iterator m_block_event;$/;"	m	struct:mods::player
m_blocked_until	mods/player.hpp	/^		uint32_t m_blocked_until;$/;"	m	struct:mods::player
m_bui_mode	mods/player.hpp	/^		bool m_bui_mode;$/;"	m	struct:mods::player
m_builder_data	mods/builder.hpp	/^		std::shared_ptr<builder_data_t> m_builder_data;$/;"	m	struct:mods::builder::sandbox_data_t
m_builder_data	mods/player.hpp	/^		std::shared_ptr<builder_data_t> m_builder_data;$/;"	m	struct:mods::player
m_cachedToString	mods/catch.hpp	/^					mutable std::string m_cachedToString;$/;"	m	class:Catch::Matchers::Impl::MatcherUntypedBase
m_callbacks	mods/affects.hpp	/^			std::map<TAffects,std::function<void(TEntityId,TAffects,uint32_t)>> m_callbacks;$/;"	m	struct:mods::affects::dissolver
m_camera	mods/player.hpp	/^		std::shared_ptr<mods::camera> m_camera;$/;"	m	struct:mods::player
m_camera_viewing	mods/player.hpp	/^		bool m_camera_viewing;$/;"	m	struct:mods::player
m_capabilities	structs.h	/^		capability_list_t m_capabilities;$/;"	m	struct:obj_data
m_capture_output	mods/player.hpp	/^		bool         m_capture_output;$/;"	m	struct:mods::player
m_captured_output	mods/player.hpp	/^		std::string  m_captured_output;$/;"	m	struct:mods::player
m_char_data	mods/ai_state.hpp	/^			char_data* m_char_data;$/;"	m	class:mods::ai_state
m_char_data	mods/drone.hpp	/^			char_data* m_char_data;$/;"	m	class:mods::drone
m_char_data	mods/player.hpp	/^		char_data*   m_char_data;$/;"	m	struct:mods::player
m_children	mods/behaviour_tree_node.hpp	/^			children_t  m_children;$/;"	m	struct:mods::behaviour_tree_node
m_chunk_affect	mods/deferred.hpp	/^			std::vector<chunk_affect_t> m_chunk_affect;$/;"	m	class:mods::deferred
m_class	mods/player.hpp	/^		player_class_t m_class;$/;"	m	struct:mods::player
m_class_capability	mods/player.hpp	/^		class_capability_t m_class_capability;$/;"	m	struct:mods::player
m_class_info	mods/player.hpp	/^		class_info_t m_class_info;$/;"	m	struct:mods::player
m_class_medic	mods/player.hpp	/^		std::shared_ptr<mods::classes::medic> m_class_medic;$/;"	m	struct:mods::player
m_class_sentinel	mods/player.hpp	/^		std::shared_ptr<mods::classes::sentinel> m_class_sentinel;$/;"	m	struct:mods::player
m_class_sniper	mods/player.hpp	/^		std::shared_ptr<mods::classes::sniper> m_class_sniper;$/;"	m	struct:mods::player
m_clear_status	mods/lmdb.hpp	/^		void m_clear_status(){$/;"	f	struct:mods::lmdb::_db_handle
m_closed	mods/lmdb.hpp	/^		bool m_closed;$/;"	m	struct:mods::lmdb::_db_handle
m_contents	structs.h	/^		std::deque<std::shared_ptr<obj_data>> m_contents;$/;"	v
m_context	mods/js.hpp	/^				duk_context* m_context;$/;"	m	struct:mods::js::include
m_count	mods/catch.hpp	/^		std::size_t m_count;$/;"	m	struct:Catch::pluralise
m_cptr	mods/string.hpp	/^			char* m_cptr;$/;"	m	struct:mods::string
m_current_join	mods/sql.hpp	/^			std::string m_current_join;$/;"	m	struct:mods::sql::compositor
m_current_level	mods/jx.hpp	/^			uint32_t m_current_level;$/;"	m	struct:mods::jx::compositor
m_current_page	mods/player.hpp	/^		unsigned int m_current_page;$/;"	m	struct:mods::player
m_current_page_fragment	mods/player.hpp	/^		std::string  m_current_page_fragment;$/;"	m	struct:mods::player
m_data	mods/catch.hpp	/^			AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder
m_db_id	mods/player.hpp	/^		aligned_int_t m_db_id;$/;"	m	struct:mods::player
m_db_id	structs.h	/^		uint64_t m_db_id;$/;"	m	struct:obj_data
m_dbi	mods/lmdb.hpp	/^		MDB_dbi	m_dbi;$/;"	m	struct:mods::lmdb::_db_handle
m_dbi_opened	mods/lmdb.hpp	/^		bool m_dbi_opened;$/;"	m	struct:mods::lmdb::_db_handle
m_deallocate	mods/string.cpp	/^	void string::m_deallocate(){$/;"	f	class:mods::string
m_debug	mods/string.cpp	4;"	d	file:
m_desc	mods/player.hpp	/^		std::shared_ptr<mods::descriptor_data> m_desc;$/;"	m	struct:mods::player
m_destroy_queue	mods/affects.hpp	/^			std::vector<TAffects> m_destroy_queue;$/;"	m	struct:mods::affects::dissolver
m_dir	mods/js.hpp	/^				std::string m_dir;$/;"	m	struct:mods::js::include
m_dir	mods/lmdb.hpp	/^		std::string m_dir;$/;"	m	struct:mods::lmdb::_db_handle
m_directions	structs.h	/^		std::vector<uint8_t> m_directions;$/;"	v
m_do_paging	mods/player.hpp	/^		bool         m_do_paging;$/;"	m	struct:mods::player
m_env	mods/lmdb.hpp	/^		MDB_env*	m_env;$/;"	m	struct:mods::lmdb::_db_handle
m_env	mods/lmdb.hpp	/^		MDB_env* m_env;$/;"	m	struct:mods::lmdb::transaction_t
m_equipment	mods/player.hpp	/^		std::array<obj_ptr_t,NUM_WEARS> m_equipment;$/;"	m	struct:mods::player
m_errors	mods/player-scaffolding.hpp	/^			std::vector<std::string> m_errors;$/;"	m	struct:mods::player_scaffolding
m_ex_descriptions	structs.h	/^		std::vector<mods::extra_desc_data> m_ex_descriptions;$/;"	v
m_executing_js	mods/player.hpp	/^		bool         m_executing_js;$/;"	m	struct:mods::player
m_feed_file	structs.h	/^		std::string m_feed_file;$/;"	m	struct:obj_data
m_file	mods/js.hpp	/^				std::string m_file;$/;"	m	struct:mods::js::include
m_flags	mods/lmdb.hpp	/^		uint64_t m_flags;$/;"	m	struct:mods::lmdb::_db_handle
m_flags	mods/player.hpp	/^		std::array<aligned_int_t,mods::flags::chunk_type_t::LAST + 1> m_flags;$/;"	m	struct:mods::player
m_god_mode	mods/player.hpp	/^		bool m_god_mode;$/;"	m	struct:mods::player
m_good	mods/lmdb.hpp	/^		bool m_good;$/;"	m	struct:mods::lmdb::_db_handle
m_has_affects	mods/affects.hpp	/^			bool m_has_affects;$/;"	m	struct:mods::affects::dissolver
m_has_block_event	mods/player.hpp	/^		bool m_has_block_event;$/;"	m	struct:mods::player
m_histfile_fp	mods/player.hpp	/^		FILE* m_histfile_fp;$/;"	m	struct:mods::player
m_histfile_index	mods/player.hpp	/^		uint32_t m_histfile_index;$/;"	m	struct:mods::player
m_histfile_on	mods/player.hpp	/^		bool m_histfile_on;$/;"	m	struct:mods::player
m_id	db.h	/^		int64_t m_id;$/;"	m	struct:zone_data
m_imp_mode	mods/player.hpp	/^		bool m_imp_mode;$/;"	m	struct:mods::player
m_in_room	mods/camera.hpp	/^			int m_in_room;$/;"	m	class:mods::camera
m_include_success	mods/js.hpp	/^				bool m_include_success;$/;"	m	struct:mods::js::include
m_increment	mods/affects.hpp	/^			std::set<TAffects> m_increment;$/;"	m	struct:mods::affects::dissolver
m_info	mods/catch.hpp	/^			AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult
m_iterations	mods/deferred.hpp	/^			uint64_t m_iterations;$/;"	m	class:mods::deferred
m_joins	mods/sql.hpp	/^			std::vector<std::string> m_joins;$/;"	m	struct:mods::sql::compositor
m_jx	mods/jx.hpp	/^			std::string m_jx;$/;"	m	struct:mods::jx::compositor
m_keeper	shop.h	/^	std::shared_ptr<mods::npc> m_keeper;$/;"	m	struct:shop_data
m_label	mods/catch.hpp	/^		std::string m_label;$/;"	m	struct:Catch::pluralise
m_lense_type	mods/player.hpp	/^		lense_type_t m_lense_type;$/;"	m	struct:mods::player
m_levels	mods/jx.hpp	/^			std::map<uint32_t,uint32_t> m_levels;$/;"	m	struct:mods::jx::compositor
m_lineInfo	mods/catch.hpp	/^			SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException
m_loaded	shop.h	/^	bool m_loaded;$/;"	m	struct:shop_data
m_location_data	structs.h	/^		location_data_t m_location_data;$/;"	m	struct:obj_data
m_logic	mods/behaviour_tree_node.hpp	/^			callback_t  m_logic;$/;"	m	struct:mods::behaviour_tree_node
m_mallocd	mods/string.hpp	/^			bool m_mallocd;$/;"	m	struct:mods::string
m_matchers	mods/catch.hpp	/^				std::vector<MatcherBase<ArgT> const*> m_matchers;$/;"	m	struct:Catch::Matchers::Impl::MatchAllOf
m_matchers	mods/catch.hpp	/^				std::vector<MatcherBase<ArgT> const*> m_matchers;$/;"	m	struct:Catch::Matchers::Impl::MatchAnyOf
m_max_amount	mods/affects.hpp	/^			std::map<TAffects,uint32_t> m_max_amount;$/;"	m	struct:mods::affects::dissolver
m_method	mods/catch.hpp	/^			void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase
m_misc_pref	mods/player.hpp	/^		std::array<bool,misc_pref_enum_t::SIZE> m_misc_pref;$/;"	m	struct:mods::player
m_mode	mods/lmdb.hpp	/^		uint16_t m_mode;$/;"	m	struct:mods::lmdb::_db_handle
m_name	mods/builder.hpp	/^		std::string m_name;$/;"	m	struct:mods::builder::sandbox_data_t
m_name	mods/chat.hpp	/^			std::string m_name;$/;"	m	struct:mods::mods::chat::channel
m_name	mods/lmdb.hpp	/^		std::string m_name;$/;"	m	struct:mods::lmdb::_db_handle
m_name	mods/player.hpp	/^		std::string	m_name;$/;"	m	struct:mods::player
m_node	mods/behaviour_tree.hpp	/^		node m_node;$/;"	m	struct:mods::behaviour_tree
m_node_type	mods/behaviour_tree_node.hpp	/^			node_type_t m_node_type;$/;"	m	struct:mods::behaviour_tree_node
m_object_uuid	mods/camera.hpp	/^			uuid_t m_object_uuid;$/;"	m	class:mods::camera
m_objects	shop.h	/^	std::vector<db_id_t> m_objects;$/;"	m	struct:shop_data
m_orm	shop.h	/^	shop_data_orm_type_t m_orm;$/;"	m	struct:shop_data
m_overhead_map_height	mods/player.hpp	/^		uint8_t m_overhead_map_height;$/;"	m	struct:mods::player
m_overhead_map_width	mods/player.hpp	/^		uint8_t m_overhead_map_width;$/;"	m	struct:mods::player
m_owner	structs.h	/^		uuid_t m_owner;$/;"	m	struct:obj_data
m_p	mods/catch.hpp	/^			T* m_p;$/;"	m	class:Catch::Ptr
m_page	mods/player.hpp	/^		unsigned int m_page;$/;"	m	struct:mods::player
m_pages	mods/player.hpp	/^		std::vector<std::string> m_pages;$/;"	m	struct:mods::player
m_parts	mods/jx.hpp	/^			std::vector<std::string> m_parts;$/;"	m	struct:mods::jx::compositor
m_password	mods/player.hpp	/^		std::string m_password;$/;"	m	struct:mods::player
m_player	mods/builder.hpp	/^		player_ptr_t m_player;$/;"	m	struct:mods::builder::sandbox_data_t
m_player	mods/camera.hpp	/^			uuid_t m_player;$/;"	m	class:mods::camera
m_player_ptr	mods/npc.hpp	/^			std::shared_ptr<mods::player> m_player_ptr;$/;"	m	struct:mods::npc
m_player_specials	mods/player.hpp	/^		std::shared_ptr<player_special_data> m_player_specials;$/;"	m	struct:mods::player
m_players	mods/player-scaffolding.hpp	/^			std::vector<player_ptr_t> m_players;$/;"	m	struct:mods::player_scaffolding
m_pluck	mods/lmdb.hpp	/^		std::vector<std::string> m_pluck;$/;"	m	struct:mods::lmdb::_db_handle
m_private	mods/chat.hpp	/^			bool m_private;$/;"	m	struct:mods::mods::chat::channel
m_private_publishers	mods/chat.hpp	/^			std::vector<std::string> m_private_publishers;$/;"	m	struct:mods::mods::chat::channel
m_processed	mods/affects.hpp	/^			std::size_t m_processed;$/;"	m	struct:mods::affects::dissolver
m_q	mods/cron.hpp	/^			std::queue<std::function<void()>> m_q;$/;"	m	class:mods::cron
m_q	mods/deferred.hpp	/^			lambda_queue_t m_q;$/;"	m	class:mods::deferred
m_query	mods/sql.hpp	/^			std::array<std::string, query_parts> m_query;$/;"	m	struct:mods::sql::compositor
m_quitting	mods/player.hpp	/^		bool m_quitting;$/;"	m	struct:mods::player
m_rc	mods/catch.hpp	/^		mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl
m_realloc	mods/string.cpp	/^	void string::m_realloc(){$/;"	f	class:mods::string
m_resultData	mods/catch.hpp	/^			AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult
m_returning	mods/sql.hpp	/^			std::string m_returning;$/;"	m	struct:mods::sql::compositor
m_set_time	mods/player.cpp	/^	void player::m_set_time(){$/;"	f	class:mods::player
m_shared_ptr	mods/object.hpp	/^			std::shared_ptr<obj_data> m_shared_ptr;$/;"	m	struct:mods::object
m_shared_ptr	mods/player.hpp	/^		std::shared_ptr<char_data> m_shared_ptr;$/;"	m	struct:mods::player
m_shouldDebugBreak	mods/catch.hpp	/^			bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder
m_shouldThrow	mods/catch.hpp	/^			bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder
m_show_tics	mods/debug.hpp	/^			bool m_show_tics;$/;"	m	struct:mods::debug::state
m_size	mods/string.hpp	/^			std::size_t m_size;$/;"	m	struct:mods::string
m_skills	mods/player.hpp	/^		std::map<int,uint16_t> m_skills;$/;"	m	struct:mods::player
m_sql	mods/sql.hpp	/^			std::string m_sql;$/;"	m	struct:mods::sql::compositor
m_state	mods/ai_state.hpp	/^			uint8_t m_state;$/;"	m	class:mods::ai_state
m_status	mods/lmdb.hpp	/^		status_type_t m_status;$/;"	m	struct:mods::lmdb::_db_handle
m_str	mods/string.hpp	/^			std::string m_str;$/;"	m	struct:mods::string
m_str_table	mods/lmdb.hpp	/^		std::string m_str_table;$/;"	m	struct:mods::lmdb::transaction_t
m_stream	mods/catch.hpp	/^			CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder
m_subscribers	mods/chat.hpp	/^			std::vector<socket_t> m_subscribers;$/;"	m	struct:mods::mods::chat::channel
m_sync_equipment	mods/player.cpp	/^	void player::m_sync_equipment(){$/;"	f	class:mods::player
m_table	mods/lmdb.hpp	/^		table_type_t m_table;$/;"	m	struct:mods::lmdb::transaction_t
m_table	mods/sql.hpp	/^			std::string m_table;$/;"	m	struct:mods::sql::compositor
m_texture_levels	structs.h	/^		std::map<texture_type_t,texture_level_t> m_texture_levels;$/;"	v
m_textures	structs.h	/^		std::set<texture_type_t> m_textures;$/;"	v
m_tick	mods/deferred.hpp	/^			uint64_t m_tick;$/;"	m	class:mods::deferred
m_tick_resolution_map	mods/affects.hpp	/^			std::map<TAffects,uint32_t> m_tick_resolution_map;$/;"	m	struct:mods::affects::dissolver
m_tick_resolution_map_counter	mods/affects.hpp	/^			std::map<TAffects,uint32_t> m_tick_resolution_map_counter;$/;"	m	struct:mods::affects::dissolver
m_ticks_event_type	mods/deferred.hpp	/^			event_queue_t m_ticks_event_type;$/;"	m	class:mods::deferred
m_ticks_per_minute	mods/deferred.hpp	/^			uint32_t m_ticks_per_minute;$/;"	m	class:mods::deferred
m_ticks_per_minute_sample	mods/deferred.hpp	/^			uint32_t m_ticks_per_minute_sample;$/;"	m	class:mods::deferred
m_time	mods/camera.hpp	/^			uint16_t m_time;$/;"	m	class:mods::camera
m_time	mods/player.hpp	/^		time_type_t	m_time;$/;"	m	struct:mods::player
m_time_tracker	mods/deferred.hpp	/^			time_t m_time_tracker;$/;"	m	class:mods::deferred
m_transaction_good	mods/lmdb.hpp	/^		bool m_transaction_good;$/;"	m	struct:mods::lmdb::_db_handle
m_transaction_open	mods/lmdb.hpp	/^		bool m_transaction_open;$/;"	m	struct:mods::lmdb::_db_handle
m_tree_name	mods/behaviour_tree.hpp	/^		std::string m_tree_name;$/;"	m	struct:mods::behaviour_tree
m_tres	mods/cron.hpp	/^			uint64_t m_tres;$/;"	m	class:mods::cron
m_tres	mods/deferred.hpp	/^			uint64_t m_tres;$/;"	m	class:mods::deferred
m_txn	mods/lmdb.hpp	/^		MDB_txn*	m_txn;$/;"	m	struct:mods::lmdb::_db_handle
m_txn_ptr	mods/sql.hpp	/^			T* m_txn_ptr;$/;"	m	struct:mods::sql::compositor
m_type	mods/lmdb.hpp	/^		transact_type_t m_type;$/;"	m	struct:mods::lmdb::transaction_t
m_type	mods/object.hpp	/^			std::vector<object_type_enum_t> m_type;$/;"	m	struct:mods::object
m_type	mods/player.hpp	/^		player_type_enum_t m_type;$/;"	m	struct:mods::player
m_ucname	mods/player.hpp	/^		std::string m_ucname;$/;"	m	struct:mods::player
m_underlyingMatcher	mods/catch.hpp	/^				MatcherBase<ArgT> const& m_underlyingMatcher;$/;"	m	struct:Catch::Matchers::Impl::MatchNotOf
m_use_pluck	mods/lmdb.hpp	/^		bool m_use_pluck;$/;"	m	struct:mods::lmdb::_db_handle
m_verb	mods/chat.hpp	/^			std::string m_verb;$/;"	m	struct:mods::mods::chat::channel
m_weapon_cooldown	mods/player.hpp	/^		std::array<uint16_t,WEAPON_SET_NUM> m_weapon_cooldown;$/;"	m	struct:mods::player
m_weapon_flags	mods/player.hpp	/^		weapon_type_t m_weapon_flags;$/;"	m	struct:mods::player
m_weapon_set	mods/player.hpp	/^		weapon_set   m_weapon_set;$/;"	m	struct:mods::player
m_weapon_type	mods/player.hpp	/^		weapon_type_t m_weapon_type;$/;"	m	struct:mods::player
m_what	mods/catch.hpp	/^			std::string m_what;$/;"	m	class:Catch::NotImplementedException
macroName	mods/catch.hpp	/^		std::string macroName;$/;"	m	struct:Catch::AssertionInfo
macro_impl	mods/macro_impl.cpp	/^namespace mods::macro_impl {$/;"	n	class:mods	file:
macro_impl	mods/macro_impl.hpp	/^namespace mods::macro_impl {$/;"	n	class:mods
maffects_debug	mods/affects.hpp	13;"	d
maffects_debug	mods/affects.hpp	15;"	d
mag_affects	magic.cpp	/^void mag_affects(int level, char_data *ch, char_data *victim,$/;"	f
mag_alter_objs	magic.cpp	/^void mag_alter_objs(int level, char_data *ch, struct obj_data *obj,$/;"	f
mag_areas	magic.cpp	/^void mag_areas(int level, char_data *ch, int spellnum, int savetype) {$/;"	f
mag_assign_spells	mods/hell.hpp	/^	constexpr inline bool mag_assign_spells = false;$/;"	m	namespace:mods::hell
mag_assign_spells	spell_parser.cpp	/^void mag_assign_spells(void) {$/;"	f
mag_creations	magic.cpp	/^void mag_creations(int level, char_data *ch, int spellnum) {$/;"	f
mag_damage	magic.cpp	/^int mag_damage(int level, char_data *ch, char_data *victim,$/;"	f
mag_groups	magic.cpp	/^void mag_groups(int level, char_data *ch, int spellnum, int savetype) {$/;"	f
mag_manacost	spell_parser.cpp	/^int mag_manacost(char_data *ch, int spellnum) {$/;"	f
mag_masses	magic.cpp	/^void mag_masses(int level, char_data *ch, int spellnum, int savetype) {$/;"	f
mag_materials	magic.cpp	/^int mag_materials(char_data *ch, int item0, int item1, int item2,$/;"	f
mag_objectmagic	spell_parser.cpp	/^void mag_objectmagic(char_data *ch, struct obj_data *obj,$/;"	f
mag_points	magic.cpp	/^void mag_points(int level, char_data *ch, char_data *victim,$/;"	f
mag_savingthrow	magic.cpp	/^int mag_savingthrow(char_data *ch, int type, int modifier) {$/;"	f
mag_summon_fail_msgs	magic.cpp	/^const char *mag_summon_fail_msgs[] = {$/;"	v
mag_summon_msgs	magic.cpp	/^const char *mag_summon_msgs[] = {$/;"	v
mag_summons	magic.cpp	/^void mag_summons(int level, char_data *ch, struct obj_data *obj,$/;"	f
mag_unaffects	magic.cpp	/^void mag_unaffects(int level, char_data *ch, char_data *victim,$/;"	f
magazine_t	mods/weapon.hpp	/^	enum magazine_t {$/;"	g	namespace:mods::weapon
magic_user	spec_assign.cpp	/^SPECIAL(magic_user);$/;"	v
magic_user	spec_procs.cpp	/^SPECIAL(magic_user);$/;"	v
mail_index	mail.cpp	/^mail_index_type *mail_index = NULL;	\/* list of recs in the mail file  *\/$/;"	v
mail_index_type	mail.h	/^typedef struct mail_index_type_d mail_index_type;$/;"	t	typeref:struct:mail_index_type_d
mail_index_type_d	mail.h	/^struct mail_index_type_d {$/;"	s
mail_recip_ok	mail.cpp	/^int mail_recip_ok(const char *name) {$/;"	f
mail_time	mail.h	/^	time_t mail_time;		\/* when was the letter mailed?		*\/$/;"	m	struct:header_data_type
main	bsd-snprintf.cpp	/^main(void) {$/;"	f
main	comm.cpp	/^int main(int argc, char **argv) {$/;"	f
makeSafe	mods/catch.hpp	/^			static type makeSafe(bool value) {$/;"	f	class:Catch::SafeBool
make_char	mods/chargen.cpp	/^	std::tuple<bool,std::string> make_char(player_ptr_t player){$/;"	f	namespace:mods::chargen
make_corpse	fight.cpp	/^void make_corpse(char_data *ch) {$/;"	f
make_from	mods/util.cpp	/^	obj_ptr_t make_from(obj_data* o){$/;"	f	namespace:mods::util
make_prompt	comm.cpp	/^char *make_prompt(mods::descriptor_data &d) {$/;"	f
mana	mods/player.hpp	/^		sh_int& mana() {$/;"	f	struct:mods::player
mana_change	spells.h	/^	int mana_change;	\/* Change in mana used by spell from lev to lev *\/$/;"	m	struct:spell_info_type
mana_gain	limits.cpp	/^int mana_gain(char_data *ch) {$/;"	f
mana_max	spells.h	/^	int mana_max;	\/* Max amount of mana used by a spell (lowest lev) *\/$/;"	m	struct:spell_info_type
mana_min	spells.h	/^	int mana_min;	\/* Min amount of mana used by a spell (highest lev) *\/$/;"	m	struct:spell_info_type
map2str	mods/util.hpp	/^	std::string map2str(std::map<TKey,TVal> in_map){$/;"	f	namespace:mods::util
mappings	mods/skills.cpp	/^	static std::map<std::string,int> mappings;$/;"	m	namespace:mods::skills	file:
maps	mods/util-map.hpp	/^		namespace maps {$/;"	n	namespace:mods::util
mark	mods/object-utils.hpp	/^		YAML::Mark mark;$/;"	m	struct:mods::object_utils::YamlFeedExceptionInfo
marksmanship	mods/skills.hpp	/^		static std::vector<proficiency_t> marksmanship = {$/;"	m	namespace:mods::skills::proficiencies
mask	mods/weapon.hpp	/^	struct mask {$/;"	s	namespace:mods::weapon
mask_to_string	mods/doors.hpp	/^	static inline std::string mask_to_string(int i){$/;"	f	namespace:mods::doors
mask_type	mods/weapon.hpp	/^	enum mask_type { SMG = 1, SNIPE = (1 << 2), SHOTGUN = (1 << 3), $/;"	g	namespace:mods::weapon
match_any_of	globals.hpp	/^	static inline bool match_any_of(std::vector<TString> items,TString target){$/;"	f	namespace:txt
match_any_of_lower	globals.hpp	/^	static inline bool match_any_of_lower(std::vector<TString> items,TString target){$/;"	f	namespace:txt
matches_many	mods/help.hpp	/^	static inline bool matches_many(const std::string& items,std::string_view from){$/;"	f	namespace:mods::help
max	mods/util-map.hpp	/^			Tval max(std::map<Tkey,Tval>& m) {$/;"	f	namespace:mods::util::maps
max_amount_reached	mods/affects.hpp	/^			bool max_amount_reached(TAffects affect){$/;"	f	struct:mods::affects::dissolver
max_bad_pws	config.cpp	/^int max_bad_pws = 3;$/;"	v
max_exp_gain	config.cpp	/^int max_exp_gain = 100000;	\/* max gainable per kill *\/$/;"	v
max_exp_loss	config.cpp	/^int max_exp_loss = 500000;	\/* max losable per death *\/$/;"	v
max_filesize	config.cpp	/^int max_filesize = 50000;$/;"	v
max_hp	mods/player.hpp	/^		sh_int& max_hp() {$/;"	f	struct:mods::player
max_mana	mods/player.hpp	/^		sh_int& max_mana() {$/;"	f	struct:mods::player
max_mob	act.builder.cpp	/^	static int max_mob  = -1;$/;"	m	namespace:mods::adhoc	file:
max_move	mods/player.hpp	/^		sh_int& max_move() {$/;"	f	struct:mods::player
max_npc_corpse_time	config.cpp	/^int max_npc_corpse_time = 5;$/;"	v
max_obj_save	config.cpp	/^int max_obj_save = 30;$/;"	v
max_object	act.builder.cpp	/^	static int max_object = -1;$/;"	m	namespace:mods::adhoc	file:
max_pc_corpse_time	config.cpp	/^int max_pc_corpse_time = 10;$/;"	v
max_players	comm.cpp	/^int max_players = 0;		\/* max descriptors available *\/$/;"	v
max_playing	config.cpp	/^int max_playing = 300;$/;"	v
max_range	mods/weapon.hpp	/^			int max_range;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
max_room	act.builder.cpp	/^	static int max_room = -1;$/;"	m	namespace:mods::adhoc	file:
max_zone	act.builder.cpp	/^	static int max_zone = -1;$/;"	m	namespace:mods::adhoc	file:
mayor	spec_assign.cpp	/^SPECIAL(mayor);$/;"	v
mayor	spec_procs.cpp	/^SPECIAL(mayor);$/;"	v
medical	mods/skills.hpp	/^		static std::vector<proficiency_t> medical = {$/;"	m	namespace:mods::skills::proficiencies
member_of_royal_guard	castle.cpp	/^int member_of_royal_guard(char_data *chChar) {$/;"	f
member_of_staff	castle.cpp	/^int member_of_staff(char_data *chChar) {$/;"	f
mentoc_flashbang_debug	mods/flashbang.hpp	28;"	d
mentoc_flashbang_debug	mods/flashbang.hpp	9;"	d
mentoc_pqxx_result_t	mods/string.hpp	12;"	d
mentoc_pqxx_result_t	mods/string.hpp	14;"	d
mentoc_pqxx_result_t	structs.h	34;"	d
mentoc_pqxx_result_t	structs.h	36;"	d
mentoc_prefix_debug	globals.hpp	87;"	d
message	mods/catch.hpp	/^		std::string message;$/;"	m	struct:Catch::AssertionResultData
message_buy	shop.h	/^	mods::string message_buy;		\/* Message when player buys item	*\/$/;"	m	struct:shop_data
message_len	boards.h	/^	int	message_len;  \/* size of message text (for file write) *\/$/;"	m	struct:board_msginfo
message_sell	shop.h	/^	mods::string message_sell;		\/* Message when player sells item	*\/$/;"	m	struct:shop_data
meta_utils	mods/meta_utils.cpp	/^namespace mods::meta_utils {$/;"	n	class:mods	file:
meta_utils	mods/meta_utils.hpp	/^namespace mods::meta_utils {$/;"	n	class:mods
mgdp_debug	globals.cpp	933;"	d	file:
min_level	spells.h	/^	int min_level[NUM_CLASSES];$/;"	m	struct:spell_info_type
min_position	spells.h	/^	byte min_position;	\/* Position for caster	 *\/$/;"	m	struct:spell_info_type
min_rent_cost	config.cpp	/^int min_rent_cost = 100;$/;"	v
min_victim_position	act.social.cpp	/^	int min_victim_position;	\/* Position of victim *\/$/;"	m	struct:social_messg	file:
min_wizlist_lev	config.cpp	/^int min_wizlist_lev = LVL_GOD;$/;"	v
mini_mud	db.cpp	/^int mini_mud = 0;		\/* mini-mud mode?		 *\/$/;"	v
minimum_level	interpreter.h	/^	sh_int minimum_level;$/;"	m	struct:command_info
minimum_position	interpreter.h	/^	byte minimum_position;$/;"	m	struct:command_info
minimum_profiency	mods/skills.hpp	/^			uint16_t minimum_profiency;$/;"	m	struct:mods::skills::proficiencies::proficiency_t
misc_pref_enum_t	mods/player.hpp	/^		enum misc_pref_enum_t {$/;"	g	struct:mods::player
missed	mods/values.hpp	/^			static inline void missed(T& p){$/;"	f	namespace:mods::values::msg
missing_cash1	shop.h	/^	mods::string missing_cash1;		\/* Message if keeper hasn't got cash	*\/$/;"	m	struct:shop_data
missing_cash2	shop.h	/^	mods::string missing_cash2;		\/* Message if player hasn't got cash	*\/$/;"	m	struct:shop_data
mloops_debug	mods/loops.cpp	4;"	d	file:
mob_act_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,19> mob_act_flags = { {$/;"	m	namespace:mods::builder	file:
mob_chmap	globals.cpp	/^		std::map<char_data*,std::shared_ptr<mods::npc>> mob_chmap;$/;"	m	namespace:mods::globals	file:
mob_death_trigger	mods/js.cpp	/^		static duk_ret_t mob_death_trigger(duk_context *ctx) {$/;"	f	namespace:mods::js
mob_has_tree	mods/behaviour_tree_impl.hpp	/^		constexpr int mob_has_tree = ((1 << 19));$/;"	m	namespace:mods::behaviour_tree_impl
mob_index	db.cpp	/^std::vector<index_data> mob_index;	\/* index table for mobile file	 *\/$/;"	v
mob_list	db.cpp	/^std::deque<std::shared_ptr<mods::npc>> mob_list;$/;"	v
mob_map	globals.cpp	/^		std::map<uuid_t,std::shared_ptr<mods::npc>> mob_map;$/;"	m	namespace:mods::globals	file:
mob_proto	db.cpp	/^std::deque<char_data> mob_proto;	\/* prototypes for mobs		 *\/$/;"	v
mob_rnum	structs.h	/^	typedef IDXTYPE mob_rnum;$/;"	t
mob_specials	mods/npc.cpp	/^	mob_special_data& npc::mob_specials(){$/;"	f	class:mods::npc
mob_uuid	globals.cpp	/^		uuid_t mob_uuid() {$/;"	f	namespace:mods::globals
mob_vnum	structs.h	/^	typedef IDXTYPE mob_vnum;$/;"	t
mobile_activity	globals.cpp	/^		int mobile_activity(char_data* ch) {$/;"	f	namespace:mods::globals
mobile_activity	mobact.cpp	/^void mobile_activity(void) {$/;"	f
mobile_activity	mods/js.cpp	/^		static duk_ret_t mobile_activity(duk_context *ctx){$/;"	f	namespace:mods::js
mode	house.h	/^	int mode;			\/* mode of ownership		*\/$/;"	m	struct:house_control_rec
modifier	structs.h	/^		int16_t modifier;     \/* How much it changes by              *\/$/;"	m	struct:obj_affected_type
modify_affected_flags	mods/js.cpp	/^		static duk_ret_t modify_affected_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
modify_plr_flags	mods/js.cpp	/^		static duk_ret_t modify_plr_flags(duk_context *ctx) {$/;"	f	namespace:mods::js
mods	globals.cpp	/^namespace mods {$/;"	n	file:
mods	globals.hpp	/^namespace mods {$/;"	n
mods	handler.h	/^namespace mods {$/;"	n
mods	mods/affects.hpp	/^namespace mods {$/;"	n
mods	mods/ai_state.cpp	/^namespace mods {$/;"	n	file:
mods	mods/ai_state.hpp	/^namespace mods {$/;"	n
mods	mods/ban_system.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree_impl.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree_node.hpp	/^namespace mods {$/;"	n
mods	mods/behaviour_tree_status.hpp	/^namespace mods {$/;"	n
mods	mods/builder.cpp	/^namespace mods {  struct player; };$/;"	n	file:
mods	mods/builder.cpp	/^namespace mods { struct extra_desc_data; }; $/;"	n	file:
mods	mods/camera.cpp	/^namespace mods {$/;"	n	file:
mods	mods/camera.hpp	/^namespace mods {$/;"	n
mods	mods/cron.hpp	/^namespace mods {$/;"	n
mods	mods/deferred.cpp	/^namespace mods {$/;"	n	file:
mods	mods/deferred.hpp	/^namespace mods {$/;"	n
mods	mods/drone.cpp	/^namespace mods {$/;"	n	file:
mods	mods/drone.hpp	/^namespace mods {$/;"	n
mods	mods/extra_desc_data.cpp	/^namespace mods {$/;"	n	file:
mods	mods/extra_desc_data.hpp	/^namespace mods {$/;"	n
mods	mods/js.cpp	/^namespace mods {$/;"	n	file:
mods	mods/js.hpp	/^namespace mods {$/;"	n
mods	mods/npc.cpp	/^namespace mods {$/;"	n	file:
mods	mods/npc.hpp	/^namespace mods {$/;"	n
mods	mods/object.cpp	/^namespace mods {$/;"	n	file:
mods	mods/object.hpp	/^namespace mods {$/;"	n
mods	mods/player-scaffolding.cpp	/^namespace mods {$/;"	n	file:
mods	mods/player-scaffolding.hpp	/^namespace mods {$/;"	n
mods	mods/player.cpp	/^namespace mods {$/;"	n	file:
mods	mods/player.hpp	/^namespace mods {$/;"	n
mods	mods/prefs.cpp	/^namespace mods {$/;"	n	file:
mods	mods/prefs.hpp	/^namespace mods {$/;"	n
mods	mods/projectile.cpp	/^namespace mods {$/;"	n	file:
mods	mods/projectile.hpp	/^namespace mods {$/;"	n
mods	mods/quests.cpp	/^namespace mods {$/;"	n	file:
mods	mods/quests.hpp	/^namespace mods {$/;"	n
mods	mods/randomized-items.cpp	/^namespace mods {$/;"	n	file:
mods	mods/randomized-items.hpp	/^namespace mods {$/;"	n
mods	mods/scan.hpp	/^namespace mods {$/;"	n
mods	mods/string.cpp	/^namespace mods {$/;"	n	file:
mods	mods/string.hpp	/^namespace mods {$/;"	n
mods	mods/util-conf.hpp	/^namespace mods {$/;"	n
mods	mods/util-map.hpp	/^namespace mods {$/;"	n
mods	mods/yaml.hpp	/^namespace mods {$/;"	n
mods	structs.cpp	/^		namespace mods{$/;"	n	file:
mods	structs.cpp	/^namespace mods {$/;"	n	file:
mods	structs.h	/^namespace mods {$/;"	n
mods	utils.h	/^namespace mods{$/;"	n
money_desc	handler.cpp	/^const char *money_desc(int amount) {$/;"	f
month	mods/date-time.cpp	/^	static uint8_t month;$/;"	m	namespace:mods::date_time	file:
month_name	constants.cpp	/^const char *month_name[] = {$/;"	v
month_name	constants.hpp	/^const char *month_name[] = {$/;"	v
moon	mods/date-time.cpp	/^	static moon_phase_t moon;$/;"	m	namespace:mods::date_time	file:
moon_phase	mods/date-time.hpp	/^	enum moon_phase {$/;"	g	namespace:mods::date_time
mortal_start_room	config.cpp	/^room_vnum mortal_start_room = 0;$/;"	v
motd	db.cpp	/^std::string motd = "Welcome to siege mud.";		\/* message of the day - mortals *\/$/;"	v
move	mods/player.hpp	/^		sh_int& move() {$/;"	f	struct:mods::player
move_gain	limits.cpp	/^int move_gain(char_data *ch) {$/;"	f
movement_loss	constants.cpp	/^int movement_loss[] = {$/;"	v
movement_loss	constants.hpp	/^int movement_loss[] =$/;"	v
mp	mods/player.hpp	/^		int& mp() { return this->gold(); }$/;"	f	struct:mods::player
mpub_aggro	mods/ai_state.hpp	/^			int32_t mpub_aggro;$/;"	m	class:mods::ai_state
mpub_dead	mods/ai_state.hpp	/^			uint32_t mpub_dead;$/;"	m	class:mods::ai_state
mpub_intelligence	mods/ai_state.hpp	/^			int32_t mpub_intelligence;$/;"	m	class:mods::ai_state
mpub_lenient	mods/ai_state.hpp	/^			int32_t mpub_lenient;$/;"	m	class:mods::ai_state
mpub_stunned	mods/ai_state.hpp	/^			uint32_t mpub_stunned;$/;"	m	class:mods::ai_state
mpub_suspicious	mods/ai_state.hpp	/^			int32_t mpub_suspicious;$/;"	m	class:mods::ai_state
mra_debug	mods/rooms.hpp	10;"	d
mra_debug	mods/rooms.hpp	12;"	d
msg	mods/object-utils.hpp	/^		std::string msg;$/;"	m	struct:mods::object_utils::YamlFeedExceptionInfo
msg	mods/values.hpp	/^		namespace msg {$/;"	n	namespace:mods::values
msg_index	boards.cpp	/^struct board_msginfo msg_index[NUM_OF_BOARDS][MAX_BOARD_MESSAGES];$/;"	v	typeref:struct:board_msginfo
msg_storage	boards.cpp	/^char *msg_storage[INDEX_SIZE];$/;"	v
msg_storage_taken	boards.cpp	/^int msg_storage_taken[INDEX_SIZE];$/;"	v
mud_time_passed	utils.cpp	/^struct time_info_data *mud_time_passed(time_t t2, time_t t1) {$/;"	f
mud_time_to_secs	utils.cpp	/^time_t mud_time_to_secs(struct time_info_data *now) {$/;"	f
mudlog	utils.cpp	/^void mudlog(int type, int level, int file, const char *str, ...) {$/;"	f
muzzle_velocity	mods/weapon.hpp	/^			int muzzle_velocity;	\/\/ Feet per second$/;"	m	struct:mods::weapon::yaml::rifle_description_t
my_signal	comm.cpp	/^sigfunc *my_signal(int signo, sigfunc *func) {$/;"	f
my_signal	comm.cpp	2112;"	d	file:
name	db.h	/^	char	*name;		    \/* name of this zone                  *\/$/;"	m	struct:zone_data
name	db.h	/^	char	name[MAX_NAME_LENGTH+1];$/;"	m	struct:ban_list_element
name	db.h	/^	mods::string name;$/;"	m	struct:player_index_element
name	mods/behaviour_tree.hpp	/^		std::string_view name() const { return m_tree_name; }$/;"	f	struct:mods::behaviour_tree
name	mods/builder.cpp	/^	std::string_view sandbox_data_t::name() const {$/;"	f	class:mods::builder::sandbox_data_t
name	mods/catch.hpp	/^		const char* name;$/;"	m	struct:Catch::NameAndDesc
name	mods/drone.hpp	/^			const char* name() {$/;"	f	class:mods::drone
name	mods/player.cpp	/^	std::string& player::name(){ return m_name; }$/;"	f	class:mods::player
name	mods/skills.hpp	/^			mods::string name;$/;"	m	struct:mods::skills::proficiencies::proficiency_t
name	spells.h	/^	const char *name;	\/* Input size not limited. Originates from string constants. *\/$/;"	m	struct:spell_info_type
name	structs.h	/^		mods::string	name;                  \/* Rooms name 'You are ...'           *\/$/;"	v
name	structs.h	/^		mods::string name;                    \/* Title of object :get etc.        *\/$/;"	m	struct:obj_data
name_from_drinkcon	act.item.cpp	/^void name_from_drinkcon(struct obj_data *obj) {$/;"	f
name_to_drinkcon	act.item.cpp	/^void name_to_drinkcon(struct obj_data *obj, int type) {$/;"	f
nameserver_is_slow	config.cpp	/^int nameserver_is_slow = NO;$/;"	v
namify	mods/prefs.cpp	/^	std::string prefs::namify(const std::string& key,char_data* c) {$/;"	f	class:mods::prefs
nanny	interpreter.cpp	/^void nanny(player_ptr_t p, char * in_arg) {$/;"	f
ndel	mods/lmdb.cpp	/^	void _db_handle::ndel(void* key,std::size_t key_size){$/;"	f	class:mods::lmdb::_db_handle
needs_dissolve	mods/affects.cpp	/^	static std::set<player_ptr_t> needs_dissolve;$/;"	m	namespace:mods::affects	file:
needs_dissolve	mods/rooms.hpp	/^		static std::map<entity_type_t,dissolver_t> needs_dissolve;$/;"	m	namespace:mods::rooms::affects
negate	mods/catch.hpp	/^		void negate(bool parenthesize) {$/;"	f	struct:Catch::AssertionResultData
negated	mods/catch.hpp	/^		bool negated;$/;"	m	struct:Catch::AssertionResultData
net_cost_per_diem	structs.h	/^		int	net_cost_per_diem;$/;"	m	struct:rent_info
new_context	mods/js.cpp	/^		duk_context* new_context() {$/;"	f	namespace:mods::js
new_descriptor	comm.cpp	/^int new_descriptor(socket_t s) {$/;"	f
new_emp_grenade_object	mods/weapon.cpp	/^	obj_data_ptr_t new_emp_grenade_object(){$/;"	f	namespace:mods::weapon
new_flashbang_grenade_object	mods/weapon.cpp	/^	obj_data_ptr_t new_flashbang_grenade_object(){$/;"	f	namespace:mods::weapon
new_frag_grenade_object	mods/weapon.cpp	/^	obj_data_ptr_t new_frag_grenade_object(){$/;"	f	namespace:mods::weapon
new_incendiary_grenade_object	mods/weapon.cpp	/^	obj_data_ptr_t new_incendiary_grenade_object(){$/;"	f	namespace:mods::weapon
new_npc	mods/builder.cpp	/^	char_data new_npc(){$/;"	f	namespace:mods::builder
new_pistol_object	mods/weapon.cpp	/^	obj_data_ptr_t new_pistol_object(){$/;"	f	namespace:mods::weapon
new_player	comm.cpp	/^player_ptr_t new_player(){$/;"	f
new_record	mods/db.cpp	/^tuple_status_t new_record(const std::string& table,mutable_map_t* values){$/;"	f	namespace:mods::db
new_room	mods/builder.cpp	/^	room_data new_room(player_ptr_t player,int direction) {$/;"	f	namespace:mods::builder
new_sandbox	mods/builder.cpp	/^	int8_t sandbox_data_t::new_sandbox($/;"	f	class:mods::builder::sandbox_data_t
new_smoke_grenade_object	mods/weapon.cpp	/^	obj_data_ptr_t new_smoke_grenade_object(){$/;"	f	namespace:mods::weapon
new_sniper_rifle_object	mods/weapon.cpp	/^	obj_data_ptr_t new_sniper_rifle_object(){$/;"	f	namespace:mods::weapon
new_txn	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::new_txn(){$/;"	f	class:mods::lmdb::_db_handle
news	db.cpp	/^char *news = NULL;		\/* mud news			 *\/$/;"	v
news	spell_parser.cpp	/^	const char *news;$/;"	m	struct:syllable	file:
next	db.h	/^	reset_q_element *next;$/;"	m	struct:reset_q_element
next	db.h	/^	struct ban_list_element *next;$/;"	m	struct:ban_list_element	typeref:struct:ban_list_element::ban_list_element
next	graph.cpp	/^	struct bfs_queue_struct *next;$/;"	m	struct:bfs_queue_struct	typeref:struct:bfs_queue_struct::bfs_queue_struct	file:
next	interpreter.h	/^	struct alias_data *next;$/;"	m	struct:alias_data	typeref:struct:alias_data::alias_data
next	mail.h	/^	struct mail_index_type_d *next;	\/* link to next one		*\/$/;"	m	struct:mail_index_type_d	typeref:struct:mail_index_type_d::mail_index_type_d
next	mail.h	/^	struct position_list_type_d *next;$/;"	m	struct:position_list_type_d	typeref:struct:position_list_type_d::position_list_type_d
next	structs.h	/^		obj_data *next;         \/* For the object list              *\/$/;"	m	struct:obj_data
next_block	mail.h	/^	long	next_block;		\/* if header block, link to next block	*\/$/;"	m	struct:header_data_type
next_combat_list	fight.cpp	/^char_data *next_combat_list = NULL;$/;"	v
next_content	structs.h	/^		obj_data *next_content; \/* For 'contains' lists             *\/$/;"	m	struct:obj_data
next_event_tick	mods/deferred.hpp	/^		uint64_t next_event_tick;$/;"	m	struct:mods::chunk_affect_t
next_mob	act.builder.cpp	/^	static inline int next_mob(){$/;"	f	namespace:mods::adhoc
next_mob_number	act.builder.cpp	/^int next_mob_number(){$/;"	f
next_obj_number	act.builder.cpp	/^int next_obj_number(){$/;"	f
next_object	act.builder.cpp	/^	static inline int next_object(){$/;"	f	namespace:mods::adhoc
next_page	modify.cpp	/^char *next_page(char *str) {$/;"	f
next_room	act.builder.cpp	/^	static inline int next_room(){$/;"	f	namespace:mods::adhoc
next_room_number	act.builder.cpp	/^int next_room_number(){ $/;"	f
next_room_pavement_transaction_id	mods/builder.cpp	/^int next_room_pavement_transaction_id(){$/;"	f
next_room_vnum	mods/builder.cpp	/^int next_room_vnum(){$/;"	f
next_zone	act.builder.cpp	/^	static inline int next_zone(){$/;"	f	namespace:mods::adhoc
next_zone_number	act.builder.cpp	/^int next_zone_number() {$/;"	f
next_zone_vnum	mods/builder.cpp	/^int next_zone_vnum(){$/;"	f
nget	mods/lmdb.cpp	/^	int _db_handle::nget(void* key,std::size_t k_size,std::string& in_value){$/;"	f	class:mods::lmdb::_db_handle
nget	mods/lmdb.cpp	/^	int _db_handle::nget(void* key,std::size_t k_size,void* in_value){$/;"	f	class:mods::lmdb::_db_handle
nitems	structs.h	/^		int	nitems;$/;"	m	struct:rent_info
no_mail	db.cpp	/^int no_mail = 0;		\/* mail disabled?		 *\/$/;"	v
no_rent_check	db.cpp	/^int no_rent_check = 0;		\/* skip rent check on boot?	 *\/$/;"	v
no_specials	comm.cpp	/^int no_specials = 0;		\/* Suppress special routines *\/$/;"	v
no_such_item1	shop.h	/^	mods::string no_such_item1;		\/* Message if keeper hasn't got an item	*\/$/;"	m	struct:shop_data
no_such_item2	shop.h	/^	mods::string no_such_item2;		\/* Message if player hasn't got an item	*\/$/;"	m	struct:shop_data
node_type_t	mods/behaviour_tree_node.hpp	/^		enum node_type_t { DO_NOTHING, SELECTOR, SEQUENCE, LEAF };$/;"	g	struct:mods::behaviour_tree_node
nonblock	comm.cpp	/^void nonblock(socket_t s) {$/;"	f
not_found	act.social.cpp	/^	char *not_found;$/;"	m	struct:social_messg	file:
npc	mods/npc.cpp	/^	npc::npc(const mob_rnum & i){$/;"	f	class:mods::npc
npc	mods/npc.hpp	/^	struct npc : public player{$/;"	s	namespace:mods
npc_can	mods/skills.cpp	/^	bool npc_can(player_ptr_t& player,int e_name){$/;"	f	namespace:mods::skills
npc_class_types	constants.cpp	/^const char *npc_class_types[] = {$/;"	v
npc_class_types	constants.hpp	/^const char *npc_class_types[] = {$/;"	v
npc_steal	spec_procs.cpp	/^void npc_steal(char_data *ch, char_data *victim) {$/;"	f
nput	mods/lmdb.cpp	/^	int _db_handle::nput(void* key,std::size_t key_size,void* value,std::size_t v_size){$/;"	f	class:mods::lmdb::_db_handle
null_time	comm.cpp	/^struct timeval null_time;	\/* zero-valued time structure *\/$/;"	v	typeref:struct:timeval
num_directions	mods/scan.hpp	/^		constexpr unsigned num_directions = 6;$/;"	m	namespace:mods::scan
num_followers_charmed	utils.cpp	/^int num_followers_charmed(char_data *ch) {$/;"	f
num_invalid	ban.cpp	/^int num_invalid = 0;$/;"	v
num_of_guests	house.h	/^	int num_of_guests;		\/* how many guests for house	*\/$/;"	m	struct:house_control_rec
num_of_houses	house.cpp	/^int num_of_houses = 0;$/;"	v
num_of_msgs	boards.cpp	/^int num_of_msgs[NUM_OF_BOARDS];$/;"	v
num_pc_in_room	utils.cpp	/^int num_pc_in_room(room_data *room) {$/;"	f
num_type_t	db.h	/^} num_type_t;$/;"	t	typeref:enum:__anon1
number	db.h	/^	zone_vnum number;	    \/* virtual number of this zone	  *\/$/;"	m	struct:zone_data
number	structs.h	/^		room_vnum number;		\/* Rooms number	(vnum)		      *\/$/;"	v
number_of_times	mods/deferred.hpp	/^		std::size_t number_of_times;$/;"	m	struct:mods::chunk_affect_t
obj	mods/util.hpp	/^		obj_ptr_t obj;$/;"	m	struct:mods::util::objdir_struct
obj_affected_type	structs.h	/^	struct obj_affected_type {$/;"	s
obj_can_see_player	mods/calc_visibility.cpp	/^	bool obj_can_see_player(obj_ptr_t& obj,player_ptr_t& target){$/;"	f	namespace:mods::calc::visibility
obj_data	structs.cpp	/^		obj_data::obj_data(std::string item_type,std::string_view feed_file){$/;"	f	class:obj_data
obj_data	structs.h	/^		obj_data(const obj_data& other){$/;"	f	struct:obj_data
obj_data	structs.h	/^		obj_data(int item_type,std::string_view feed_file) :$/;"	f	struct:obj_data
obj_data	structs.h	/^	struct obj_data {$/;"	s
obj_file_elem	structs.h	/^	struct obj_file_elem {$/;"	s
obj_flag_data	structs.h	/^		obj_flag_data() : type(0), is_ammo(0), holds_ammo(0), type_flag(0),weapon_flags(0),$/;"	f	struct:obj_flag_data
obj_flag_data	structs.h	/^	struct obj_flag_data {$/;"	s
obj_flags	structs.h	/^		obj_flag_data obj_flags;\/* Object information               *\/$/;"	m	struct:obj_data
obj_from_char	handler.cpp	/^void obj_from_char(obj_ptr_t in_object){$/;"	f
obj_from_char	handler.cpp	/^void obj_from_char(struct obj_data *object) {$/;"	f
obj_from_obj	handler.cpp	/^void obj_from_obj(struct obj_data *obj) {$/;"	f
obj_from_room	handler.cpp	/^void obj_from_room(obj_ptr_t in_object) {$/;"	f
obj_from_room	handler.cpp	/^void obj_from_room(struct obj_data *object) {$/;"	f
obj_index	db.cpp	/^std::vector<index_data> obj_index;	\/* index table for object file	 *\/$/;"	v
obj_list	db.cpp	/^std::deque<std::shared_ptr<obj_data>> obj_list;$/;"	v
obj_map	globals.cpp	/^		map_object_list obj_map;$/;"	m	namespace:mods::globals	file:
obj_odmap	globals.cpp	/^		std::map<obj_data*,obj_ptr_t> obj_odmap;$/;"	m	namespace:mods::globals	file:
obj_proto	db.cpp	/^std::deque<obj_data> obj_proto;	\/* prototypes for objs		 *\/$/;"	v
obj_ptr_to_char	handler.cpp	/^void obj_ptr_to_char(obj_ptr_t  object, player_ptr_t player) {$/;"	f
obj_rnum	structs.h	/^	typedef IDXTYPE obj_rnum;$/;"	t
obj_stat_pages	globals.cpp	/^		std::map<obj_vnum,std::string> obj_stat_pages;$/;"	m	namespace:mods::globals	file:
obj_to_char	handler.cpp	/^void obj_to_char(obj_ptr_t  object, player_ptr_t player) {$/;"	f
obj_to_char	handler.cpp	/^void obj_to_char(struct obj_data *object, char_data *ch) {$/;"	f
obj_to_obj	handler.cpp	/^void	obj_to_obj(obj_ptr_t from_object, obj_ptr_t to_object){$/;"	f
obj_to_room	handler.cpp	/^void obj_to_room(obj_ptr_t in_object, room_rnum room) {$/;"	f
obj_to_room	handler.cpp	/^void obj_to_room(struct obj_data *object, room_rnum room) {$/;"	f
obj_uuid	globals.cpp	/^		uuid_t obj_uuid() {$/;"	f	namespace:mods::globals
obj_vnum	structs.h	/^	typedef IDXTYPE obj_vnum;$/;"	t
objdir_struct	mods/util.hpp	/^	struct objdir_struct {$/;"	s	namespace:mods::util
object	mods/object.cpp	/^	object::object(){$/;"	f	class:mods::object
object	mods/object.cpp	/^	object::object(mods::object* ptr) {$/;"	f	class:mods::object
object	mods/object.hpp	/^	struct object {$/;"	s	namespace:mods
object_cost	mods/shop.hpp	/^	static inline int object_cost(obj_data& obj){$/;"	f	namespace:mods::shop
object_end	mods/jx.hpp	/^			compositor& object_end() {$/;"	f	struct:mods::jx::compositor
object_from_room	mods/events.cpp	/^			void object_from_room(uuid_t uuid,room_rnum room){$/;"	f	namespace:mods::events::publish::rooms
object_info	shop.h	/^	TObjectInfo object_info;$/;"	m	struct:shop_data
object_list_new_owner	handler.cpp	/^void object_list_new_owner(struct obj_data *list, char_data *ch) {$/;"	f
object_start	mods/jx.hpp	/^			compositor& object_start(const std::string& key) {$/;"	f	struct:mods::jx::compositor
object_to_room	mods/events.cpp	/^			void object_to_room(uuid_t uuid,room_rnum room){$/;"	f	namespace:mods::events::publish::rooms
object_type_enum_t	mods/object.hpp	/^			enum object_type_enum_t { $/;"	g	struct:mods::object
object_utils	mods/object-utils.cpp	/^namespace mods::object_utils {$/;"	n	class:mods	file:
object_utils	mods/object-utils.hpp	/^namespace mods::object_utils {$/;"	n	class:mods
object_uuid	mods/camera.hpp	/^			uuid_t object_uuid() const { return m_object_uuid; }$/;"	f	class:mods::camera
objects	mods/events.cpp	/^		namespace objects {$/;"	n	namespace:mods::events::publish	file:
objects	mods/events.hpp	/^		namespace objects {$/;"	n	namespace:mods::events::publish
ok_damage_shopkeeper	shop.cpp	/^int ok_damage_shopkeeper(char_data *ch, char_data *victim) {$/;"	f
ok_pick	act.movement.cpp	/^	int ok_pick(char_data *ch, obj_vnum keynum, int pickproof, int scmd) {$/;"	f
ok_shop_room	shop.cpp	/^int ok_shop_room(int shop_nr, room_vnum room) {$/;"	f
olc_bitvector	olc.cpp	/^void olc_bitvector(int *bv, const char **names, char *arg) {$/;"	f
olc_ch	olc.cpp	/^char_data *olc_ch;$/;"	v
olc_commands	olc.cpp	/^const char *olc_commands[] = {$/;"	v
olc_interpreter	olc.cpp	/^void olc_interpreter(void *targ, int mode, char *arg) {$/;"	f
olc_modes	olc.cpp	/^const char *olc_modes[] = {$/;"	v
olc_set_show	olc.cpp	/^void olc_set_show(char_data *ch, int olc_mode, char *arg) {$/;"	f
olc_string	olc.cpp	/^void olc_string(char **string, size_t maxlen, char *arg) {$/;"	f
on	mods/sql.hpp	/^			compositor<T>& on(std::string_view lhs,$/;"	f	struct:mods::sql::compositor
on_affect_change	mods/affects.hpp	/^			void on_affect_change(TAffects affect,callback_t cb){$/;"	f	struct:mods::affects::dissolver
on_room_fire_changed_affect	mods/rooms.cpp	/^		void on_room_fire_changed_affect($/;"	f	namespace:mods::rooms::affects
one_argument	interpreter.cpp	/^char *one_argument(char *argument, char *first_arg) {$/;"	f
one_argument	interpreter.cpp	/^char *one_argument(char *argument, char *first_arg,unsigned int max_char) {$/;"	f
one_word	interpreter.cpp	/^char *one_word(char *argument, char *first_arg) {$/;"	f
opCast	mods/catch.hpp	/^		inline T& opCast(T const& t) {$/;"	f	namespace:Catch::Internal
opCast	mods/catch.hpp	/^		inline std::nullptr_t opCast(std::nullptr_t) {$/;"	f	namespace:Catch::Internal
op_and	mods/sql.hpp	/^			compositor<T>& op_and(str_object lhs,$/;"	f	struct:mods::sql::compositor
op_or	mods/sql.hpp	/^			compositor<T>& op_or(str_object lhs,$/;"	f	struct:mods::sql::compositor
open	mods/lmdb.cpp	/^	bool _db_handle::open(){$/;"	f	class:mods::lmdb::_db_handle
open1	shop.h	/^	int	 open1, open2;		\/* When does the shop open?		*\/$/;"	m	struct:shop_data
open2	shop.h	/^	int	 open1, open2;		\/* When does the shop open?		*\/$/;"	m	struct:shop_data
open_dbi	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::open_dbi(){$/;"	f	class:mods::lmdb::_db_handle
open_logfile	comm.cpp	/^int open_logfile(const char *filename, FILE *stderr_fp) {$/;"	f
operator !	mods/catch.hpp	/^			MatchNotOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator !() const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator !	mods/catch.hpp	/^			bool operator !() const {$/;"	f	class:Catch::Ptr
operator &&	mods/catch.hpp	/^				MatchAllOf<ArgT>& operator && (MatcherBase<ArgT> const& other) {$/;"	f	struct:Catch::Matchers::Impl::MatchAllOf
operator &&	mods/catch.hpp	/^			MatchAllOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator && (MatcherBase const& other) const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator *	mods/catch.hpp	/^			T& operator*() const {$/;"	f	class:Catch::Ptr
operator *	mods/string.hpp	/^		const char* operator*(){ return m_str.c_str(); }$/;"	f	struct:mods::string
operator +	mods/catch.hpp	/^		std::string operator+() {$/;"	f	struct:Catch::StreamEndStop
operator +	mods/catch.hpp	/^	T const& operator + (T const& value, StreamEndStop) {$/;"	f	namespace:Catch
operator ->	mods/catch.hpp	/^			T* operator->() const {$/;"	f	class:Catch::Ptr
operator <<	mods/ai_state.hpp	/^			ai_state& operator<<(const state& m) {$/;"	f	class:mods::ai_state
operator <<	mods/catch.hpp	/^			ResultBuilder& operator << (T const& value) {$/;"	f	class:Catch::ResultBuilder
operator <<	mods/cron.hpp	/^			cron& operator<<(const char* m) {$/;"	f	class:mods::cron
operator <<	mods/cron.hpp	/^			cron& operator<<(const std::string m) {$/;"	f	class:mods::cron
operator <<	mods/cron.hpp	/^			cron& operator<<(int m) {$/;"	f	class:mods::cron
operator <<	mods/drone.hpp	/^			drone& operator<<(const char* m) {$/;"	f	class:mods::drone
operator <<	mods/drone.hpp	/^			drone& operator<<(const std::string m) {$/;"	f	class:mods::drone
operator <<	mods/drone.hpp	/^			drone& operator<<(int m) {$/;"	f	class:mods::drone
operator <<	mods/player.hpp	/^		player& operator<<(const char* m) {$/;"	f	struct:mods::player
operator <<	mods/player.hpp	/^		player& operator<<(const mods::string& m) {$/;"	f	struct:mods::player
operator <<	mods/player.hpp	/^		player& operator<<(const std::string& m) {$/;"	f	struct:mods::player
operator <<	mods/player.hpp	/^		player& operator<<(int m) {$/;"	f	struct:mods::player
operator =	mods/catch.hpp	/^			Ptr& operator = (Ptr const& other) {$/;"	f	class:Catch::Ptr
operator =	mods/catch.hpp	/^			Ptr& operator = (T* p) {$/;"	f	class:Catch::Ptr
operator =	mods/catch.hpp	/^		CopyableStream& operator=(CopyableStream const& other) {$/;"	f	struct:Catch::CopyableStream
operator =	mods/string.cpp	/^	string& string::operator=(char* other){$/;"	f	class:mods::string
operator =	mods/string.cpp	/^	string& string::operator=(const char* other){$/;"	f	class:mods::string
operator =	mods/string.cpp	/^	string& string::operator=(const std::string & other){$/;"	f	class:mods::string
operator =	mods/string.cpp	/^	string& string::operator=(string other){$/;"	f	class:mods::string
operator =	structs.h	/^		obj_data& operator=(obj_data& other){ $/;"	f	struct:obj_data
operator SafeBool::type	mods/catch.hpp	/^			operator SafeBool::type() const {$/;"	f	class:Catch::Ptr
operator bool	mods/string.hpp	/^		operator bool() const { return m_str.length(); }$/;"	f	struct:mods::string
operator char*	mods/string.hpp	/^		operator char*() const { return const_cast<char*>(c_str()); }$/;"	f	struct:mods::string
operator chdata_ptr	mods/player.hpp	/^		operator chdata_ptr() const {$/;"	f	struct:mods::player
operator chdata_ptr	mods/player.hpp	/^		operator chdata_ptr(){ return cd(); }$/;"	f	struct:mods::player
operator const char*	mods/string.hpp	/^		explicit operator const char*() const { return m_str.length() == 0 ? nullptr : m_str.c_str(); }$/;"	f	struct:mods::string
operator std::string	mods/string.hpp	/^		explicit operator std::string() const { return m_str; }$/;"	f	struct:mods::string
operator |	mods/catch.hpp	/^	inline ResultDisposition::Flags operator | (ResultDisposition::Flags lhs, ResultDisposition::Flags rhs) {$/;"	f	namespace:Catch
operator ||	mods/catch.hpp	/^				MatchAnyOf<ArgT>& operator || (MatcherBase<ArgT> const& other) {$/;"	f	struct:Catch::Matchers::Impl::MatchAnyOf
operator ||	mods/catch.hpp	/^			MatchAnyOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator || (MatcherBase const& other) const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator_str	shop.cpp	/^const char *operator_str[] = {$/;"	v
opposite_dir	globals.cpp	/^		int opposite_dir(int dir) {$/;"	f	namespace:mods::globals
optr	globals.cpp	/^obj_ptr_t optr(obj_data* in_obj){$/;"	f
optr_by_uuid	globals.cpp	/^obj_ptr_t optr_by_uuid(uuid_t id){$/;"	f
optr_opt	globals.cpp	/^std::optional<obj_ptr_t> optr_opt(uuid_t obj_uuid){$/;"	f
org	spell_parser.cpp	/^	const char *org;$/;"	m	struct:syllable	file:
orm	shop.h	/^namespace mods::orm {$/;"	n	class:mods
oss	mods/catch.hpp	/^		std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream
other	mods/catch.hpp	/^		SourceLineInfo(SourceLineInfo const& other)          = default;$/;"	m	struct:Catch::SourceLineInfo
others_auto	act.social.cpp	/^	char *others_auto;$/;"	m	struct:social_messg	file:
others_found	act.social.cpp	/^	char *others_found;$/;"	m	struct:social_messg	file:
others_no_arg	act.social.cpp	/^	char *others_no_arg;$/;"	m	struct:social_messg	file:
outofammo	mods/values.hpp	/^			static inline void outofammo(T& p){$/;"	f	namespace:mods::values::msg
overhead	structs.cpp	/^		std::string_view room_data::overhead(const lense_type_t& lense){$/;"	f	class:room_data
overhead_map	mods/overhead_map.cpp	/^namespace mods::overhead_map {$/;"	n	class:mods	file:
overhead_map	mods/overhead_map.hpp	/^namespace mods::overhead_map {$/;"	n	class:mods
owner	house.h	/^	long owner;			\/* idnum of house's owner	*\/$/;"	m	struct:house_control_rec
owner_uuid	mods/camera.hpp	/^			uuid_t owner_uuid() const { return m_player; }$/;"	f	class:mods::camera
pad_room	globals.cpp	/^		void pad_room(int room,char_data* ch,int door){$/;"	f	namespace:mods::globals
page	mods/player.cpp	/^	void player::page(int pg) {$/;"	f	class:mods::player
page_string	modify.cpp	/^void page_string(mods::descriptor_data d, char *str, int keep_internal) {$/;"	f
pager_clear	mods/player.cpp	/^	void player::pager_clear() {$/;"	f	class:mods::player
pager_end	mods/player.cpp	/^	player& player::pager_end() {$/;"	f	class:mods::player
pager_next_page	mods/player.cpp	/^	void player::pager_next_page() {$/;"	f	class:mods::player
pager_start	mods/player.cpp	/^	player& player::pager_start() {$/;"	f	class:mods::player
pages	mods/help.hpp	/^	namespace pages {$/;"	n	namespace:mods::help
paginate_string	modify.cpp	/^void paginate_string(char *str, mods::descriptor_data d) {$/;"	f
paging	mods/player.hpp	/^		bool paging() const {$/;"	f	struct:mods::player
parenthesized	mods/catch.hpp	/^		bool parenthesized;$/;"	m	struct:Catch::AssertionResultData
parse_class	class.cpp	/^player_class_t parse_class(char arg) {$/;"	f
parse_direction	mods/util.cpp	/^	int parse_direction(std::string_view arg, int start_at, int* last_index) {$/;"	f	namespace:mods::util
parse_enhanced_mob	db.cpp	/^void parse_enhanced_mob(FILE *mob_f, int i, int nr) {$/;"	f
parse_espec	db.cpp	/^void parse_espec(char *buf, int i, int nr) {$/;"	f
parse_help	mods/util.cpp	/^	bool parse_help(std::string_view argument){$/;"	f	namespace:mods::util
parse_ip	comm.cpp	/^int parse_ip(const char *addr, struct in_addr *inaddr) {$/;"	f
parse_mobile	db.cpp	/^void parse_mobile(FILE *mob_f, int nr) {$/;"	f
parse_objdir	mods/util.cpp	/^	objdir_t parse_objdir(player_ptr_t& player,std::string_view arg){$/;"	f	namespace:mods::util
parse_object	db.cpp	/^char *parse_object(FILE *obj_f, int nr) {$/;"	f
parse_object	mods/util.cpp	/^	obj_ptr_t parse_object(player_ptr_t& player,std::string_view arg, int start_at, int* last_index) {$/;"	f	namespace:mods::util
parse_object_vec	mods/util.cpp	/^	obj_ptr_t parse_object_vec(player_ptr_t& player,std::vector<std::string>& vec_args){$/;"	f	namespace:mods::util
parse_object_with_capability	mods/util.cpp	/^	obj_ptr_t parse_object_with_capability(player_ptr_t& player,std::string_view arg, int start_at, int* last_index, mods::weapon::type::type_list type, std::vector<int>& types) {$/;"	f	namespace:mods::util
parse_primary_choice	mods/chargen.cpp	/^	std::string_view parse_primary_choice(char choice,int class_type){$/;"	f	namespace:mods::chargen
parse_rarity	mods/yaml.cpp	/^	float parse_rarity(const std::string& rarity_string) {$/;"	f	namespace:mods::yaml
parse_room	db.cpp	/^void parse_room(FILE *fl, int virtual_nr) {$/;"	f
parse_simple_mob	db.cpp	/^void parse_simple_mob(FILE *mob_f, int i, int nr) {$/;"	f
parse_sql_mobiles	db.cpp	/^void parse_sql_mobiles() {$/;"	f
parse_sql_objects	db.cpp	/^int parse_sql_objects() {$/;"	f
parse_sql_player	db.cpp	/^bool parse_sql_player(player_ptr_t player_ptr){$/;"	f
parse_sql_rooms	db.cpp	/^std::tuple<int16_t,std::string> parse_sql_rooms() {$/;"	f
parse_sql_shops	db.cpp	/^int parse_sql_shops() {$/;"	f
parse_sql_zones	db.cpp	/^std::tuple<int16_t,std::string> parse_sql_zones() {$/;"	f
password	mods/auto-login.hpp	/^	static std::string password;$/;"	m	namespace:mods::auto_login
password	mods/player.hpp	/^		std::string password(){$/;"	f	struct:mods::player
path	mods/js-path.hpp	/^namespace mods::js::path { $/;"	n	class:mods::js
pave_open_direction	mods/doors.hpp	/^	static inline void pave_open_direction(room_rnum room, int direction){$/;"	f	namespace:mods::doors
pbr_debug	mods/projectile.cpp	18;"	d	file:
pbr_debug	mods/projectile.cpp	20;"	d	file:
pc_class_types	class.cpp	/^const char *pc_class_types[] = {$/;"	v
pcnpc	act.wizard.cpp	/^	const char pcnpc;$/;"	m	struct:set_struct	file:
people	structs.h	/^		char_data *people;    \/* List of NPC \/ PC in room           *\/$/;"	v
performOptionalSelector	mods/catch.hpp	/^inline id performOptionalSelector(id obj, SEL sel) {$/;"	f
perform_act	comm.cpp	/^void perform_act(const char *orig, char_data *ch, obj_data *obj,$/;"	f
perform_alias	interpreter.cpp	/^int perform_alias(mods::descriptor_data& d, char *orig, size_t maxlen) {$/;"	f
perform_auto_login	comm.cpp	/^void perform_auto_login(player_ptr_t& player){$/;"	f
perform_blast_radius	mods/projectile.cpp	/^		void perform_blast_radius($/;"	f	namespace:mods::projectile
perform_breach	mods/doors.hpp	/^	static inline void perform_breach(uuid_t obj_uuid,uuid_t player_uuid,int direction){$/;"	f	namespace:mods::doors
perform_drop	act.item.cpp	/^int perform_drop(char_data *ch, struct obj_data *obj,$/;"	f
perform_drop_gold	act.item.cpp	/^void perform_drop_gold(char_data *ch, int amount,$/;"	f
perform_dupe_check	interpreter.cpp	/^int64_t perform_dupe_check(player_ptr_t p){$/;"	f
perform_equip_calculations	mods/player.cpp	/^	void player::perform_equip_calculations(int pos,bool equip){$/;"	f	class:mods::player
perform_get_from_container	act.item.cpp	/^void perform_get_from_container(char_data *ch, struct obj_data *obj,$/;"	f
perform_get_from_room	act.item.cpp	/^int perform_get_from_room(char_data *ch, struct obj_data *obj) {$/;"	f
perform_give	act.item.cpp	/^void perform_give(char_data *ch, char_data *vict,$/;"	f
perform_give_gold	act.item.cpp	/^void perform_give_gold(char_data *ch, char_data *vict,$/;"	f
perform_group	act.other.cpp	/^int perform_group(char_data *ch, char_data *vict) {$/;"	f
perform_group_gain	fight.cpp	/^void perform_group_gain(char_data *ch, int base,$/;"	f
perform_immort_invis	act.wizard.cpp	/^void perform_immort_invis(char_data *ch, int level) {$/;"	f
perform_immort_vis	act.wizard.cpp	/^void perform_immort_vis(char_data *ch) {$/;"	f
perform_immort_where	act.informative.cpp	/^void perform_immort_where(char_data *ch, char *arg) {$/;"	f
perform_mag_groups	magic.cpp	/^void perform_mag_groups(int level, char_data *ch,$/;"	f
perform_mortal_where	act.informative.cpp	/^void perform_mortal_where(char_data *ch, char *arg) {$/;"	f
perform_move	act.movement.cpp	/^int perform_move(char_data *ch, int dir, int need_specials_check) {$/;"	f
perform_put	act.item.cpp	/^void perform_put(char_data *ch, struct obj_data *obj,$/;"	f
perform_remove	act.item.cpp	/^void perform_remove(player_ptr_t player, int pos) {$/;"	f
perform_set	act.wizard.cpp	/^int perform_set(char_data *ch, char_data *vict, int mode,$/;"	f
perform_socket_read	comm.cpp	/^ssize_t perform_socket_read(socket_t desc, char *read_point, size_t space_left) {$/;"	f
perform_socket_write	comm.cpp	/^ssize_t perform_socket_write(socket_t desc, const char *txt, size_t length) {$/;"	f
perform_subst	comm.cpp	/^int perform_subst(mods::descriptor_data &t, char *orig, char *subst) {$/;"	f
perform_tell	act.comm.cpp	/^void perform_tell(char_data *ch, char_data *vict, char *arg) {$/;"	f
perform_thermite_breach	mods/doors.hpp	/^	static inline void perform_thermite_breach(uuid_t obj_uuid,uuid_t player_uuid,int direction){$/;"	f	namespace:mods::doors
perform_violence	fight.cpp	/^void perform_violence() {$/;"	f
perform_wear	act.item.cpp	/^void perform_wear(char_data *ch, struct obj_data *obj, int where) {$/;"	f
pet_shops	spec_assign.cpp	/^SPECIAL(pet_shops);$/;"	v
pet_shops	spec_procs.cpp	/^SPECIAL(pet_shops);$/;"	v
peter	castle.cpp	/^SPECIAL(peter);$/;"	v
pfind	mods/pfind.cpp	/^namespace mods::pfind {$/;"	n	class:mods	file:
pfind	mods/pfind.hpp	/^namespace mods::pfind {$/;"	n	class:mods
phase_ring_buffer	mods/date-time.cpp	/^	std::array<moon_phase_t,12> phase_ring_buffer = {$/;"	m	namespace:mods::date_time	file:
phase_ring_buffer_index	mods/date-time.cpp	/^	static uint8_t phase_ring_buffer_index;$/;"	m	namespace:mods::date_time	file:
pk_allowed	config.cpp	/^int pk_allowed = YES;$/;"	v
pkey	mods/skills.cpp	/^	std::string pkey(std::string player_name,std::string key){$/;"	f	namespace:mods::skills
player	mods/js-player-scaffolding.cpp	/^namespace mods::js::player {$/;"	n	class:mods::js	file:
player	mods/js-player-scaffolding.hpp	/^namespace mods::js::player {$/;"	n	class:mods::js
player	mods/js.cpp	/^				player_ptr_t player;$/;"	m	struct:mods::js::utils::find_player_payload_t	file:
player	mods/player.cpp	/^	player::player(){$/;"	f	class:mods::player
player	mods/player.cpp	/^	player::player(char_data* ch) {$/;"	f	class:mods::player
player	mods/player.cpp	/^	player::player(mods::player* ptr) {$/;"	f	class:mods::player
player	mods/player.cpp	/^	player::player(player_type_enum_t type){$/;"	f	class:mods::player
player	mods/player.hpp	/^	struct player {$/;"	s	namespace:mods
player_bits	constants.cpp	/^const char *player_bits[] = {$/;"	v
player_bits	constants.hpp	/^const char *player_bits[] = {$/;"	v
player_can	mods/skills.cpp	/^	bool player_can(player_ptr_t& player,int e_name){$/;"	f	namespace:mods::skills
player_can_do_range_modifier	mods/sensor-grenade.cpp	/^	bool player_can_do_range_modifier(player_ptr_t& player){$/;"	f	namespace:mods::sensor_grenade
player_can_see_obj	mods/calc_visibility.cpp	/^	bool player_can_see_obj(player_ptr_t& player,obj_ptr_t & obj){$/;"	f	namespace:mods::calc::visibility
player_chmap	globals.cpp	/^		std::map<char_data*,std::shared_ptr<mods::player>> player_chmap;$/;"	m	namespace:mods::globals	file:
player_class_t	structs.h	/^enum player_class_t {$/;"	g
player_exists	db.cpp	/^bool player_exists(player_ptr_t player_ptr){$/;"	f
player_index_element	db.h	/^struct player_index_element {$/;"	s
player_key	mods/db.cpp	/^std::string player_key(std::string player_name,std::string prefix, std::string type){$/;"	f
player_key_count	mods/db.cpp	/^std::string player_key_count(std::string player_name,std::string prefix, std::string type){$/;"	f
player_key_index	mods/db.cpp	/^std::string player_key_index(std::string player_name,std::string prefix, std::string type){$/;"	f
player_level	structs.h	/^enum player_level {$/;"	g
player_list	globals.cpp	/^		player_list_t player_list;$/;"	m	namespace:mods::globals	file:
player_map	globals.cpp	/^		std::map<uuid_t,player_ptr_t> player_map;$/;"	m	namespace:mods::globals	file:
player_name	mods/js.cpp	/^				std::string player_name;$/;"	m	struct:mods::js::utils::find_player_payload_t	file:
player_name_map	globals.cpp	/^		std::map<std::string,player_ptr_t> player_name_map;$/;"	m	namespace:mods::globals	file:
player_nobody	globals.cpp	/^		player_ptr_t player_nobody;$/;"	m	namespace:mods::globals	file:
player_ptr	mods/npc.cpp	/^	player_ptr_t& npc::player_ptr(){ return m_player_ptr; }$/;"	f	class:mods::npc
player_scaffolding	mods/player-scaffolding.hpp	/^	struct player_scaffolding {$/;"	s	namespace:mods
player_table	db.cpp	/^std::deque<player_index_element> player_table;	\/* index to plr file	 *\/$/;"	v
player_type_enum_t	mods/player.hpp	/^		enum player_type_enum_t { $/;"	g	struct:mods::player
player_utils	mods/player-utils.hpp	/^namespace mods::player_utils {$/;"	n	class:mods
player_uuid	globals.cpp	/^		uuid_t player_uuid() {$/;"	f	namespace:mods::globals
player_uuid	mods/camera.hpp	/^			uuid_t player_uuid() const { return m_player; }$/;"	f	class:mods::camera
player_uuid	mods/deferred.hpp	/^		uuid_t player_uuid;$/;"	m	struct:mods::chunk_affect_t
players	mods/events.cpp	/^		namespace players {$/;"	n	namespace:mods::events::publish	file:
players	mods/events.hpp	/^		namespace players {$/;"	n	namespace:mods::events::publish
plr	mods/flags.hpp	/^	enum plr {$/;"	g	namespace:mods::flags
plural	spells.h	/^	const char	*plural;$/;"	m	struct:attack_hit_type
pluralise	mods/catch.hpp	/^	struct pluralise {$/;"	s	namespace:Catch
point_update	limits.cpp	/^void point_update(void) {$/;"	f
policies	db.cpp	/^char *policies = NULL;		\/* policies page		 *\/$/;"	v
pop	shop.cpp	/^int pop(struct stack_data *stack) {$/;"	f
pop_free_list	mail.cpp	/^long pop_free_list(void) {$/;"	f
popular_distributions	mods/rand.hpp	/^	static std::map<int,std::uniform_int_distribution<int>> popular_distributions;$/;"	m	namespace:mods::rand
position	mail.h	/^	long	position;$/;"	m	struct:position_list_type_d
position	mods/player.hpp	/^		byte& position(){$/;"	f	struct:mods::player
position_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,9> position_flags = { {$/;"	m	namespace:mods::builder	file:
position_list_type	mail.h	/^typedef struct position_list_type_d position_list_type;$/;"	t	typeref:struct:position_list_type_d
position_list_type_d	mail.h	/^struct position_list_type_d {$/;"	s
position_types	constants.cpp	/^const char *position_types[] = {$/;"	v
position_types	constants.hpp	/^const char *position_types[] = {$/;"	v
post_boot_db	globals.cpp	/^		void post_boot_db() {$/;"	f	namespace:mods::globals
post_feed	structs.h	/^		void post_feed(T fed_object){$/;"	f	struct:obj_data
post_modify_callback	mods/builder_util.hpp	/^	typedef std::function<std::pair<bool,std::string>()> post_modify_callback;$/;"	t	namespace:mods::builder_util
postgres_dbname	mods/conf.hpp	/^	static std::string postgres_dbname = "postgres_mud";$/;"	m	namespace:mods::conf
postgres_host	mods/conf.hpp	/^	static std::string postgres_host = "localhost";$/;"	m	namespace:mods::conf
postgres_password	mods/conf.hpp	/^	static std::string postgres_password = "postgresmudpassword";$/;"	m	namespace:mods::conf
postgres_port	mods/conf.hpp	/^	static std::string postgres_port = "5432";$/;"	m	namespace:mods::conf
postgres_user	mods/conf.hpp	/^	static std::string postgres_user = "postgres";$/;"	m	namespace:mods::conf
postmaster	mail.cpp	/^SPECIAL(postmaster);$/;"	v
postmaster	spec_assign.cpp	/^SPECIAL(postmaster);$/;"	v
postmaster_check_mail	mail.cpp	/^void postmaster_check_mail(char_data *ch, char_data *mailman,$/;"	f
postmaster_receive_mail	mail.cpp	/^void postmaster_receive_mail(char_data *ch, char_data *mailman,$/;"	f
postmaster_send_mail	mail.cpp	/^void postmaster_send_mail(char_data *ch, char_data *mailman,$/;"	f
pow10	bsd-snprintf.cpp	/^pow10(int exp) {$/;"	f	file:
pq	mods/lmdb.hpp	/^namespace mods::pq {$/;"	n	class:mods
pq	mods/pq.cpp	/^namespace mods::pq {$/;"	n	class:mods	file:
pq	mods/pq.hpp	/^namespace mods::pq {$/;"	n	class:mods
pq	mods/pqxx-types.hpp	/^namespace mods::pq {$/;"	n	class:mods
pq_con	globals.cpp	/^		std::unique_ptr<pqxx::connection> pq_con;$/;"	m	namespace:mods::globals	file:
pq_connection	mods/conf.cpp	/^	std::string pq_connection(std::map<std::string,std::string> values){$/;"	f	namespace:mods::conf
prac_params	class.cpp	/^int prac_params[4][NUM_CLASSES] = {$/;"	v
prac_types	spec_procs.cpp	/^const char *prac_types[] = {$/;"	v
pre_game	mods/debug-pre-game.hpp	/^namespace mods::debug::pre_game {$/;"	n	class:mods::debug
pre_game_loop	globals.cpp	/^		void pre_game_loop() {$/;"	f	namespace:mods::globals
preference_bits	constants.cpp	/^const char *preference_bits[] = {$/;"	v
preference_bits	constants.hpp	/^const char *preference_bits[] = {$/;"	v
prefs	mods/prefs.hpp	/^	class prefs {$/;"	c	namespace:mods
preg_match	mods/util.cpp	/^		bool preg_match(std::string_view regex,std::string_view haystack) {$/;"	f	namespace:mods::util
pregame	mods/pregame.cpp	/^namespace mods::pregame {$/;"	n	class:mods	file:
pregame	mods/pregame.hpp	/^namespace mods::pregame {$/;"	n	class:mods
present_action	mods/builder.cpp	/^void present_action(player_ptr_t & player, std::size_t index){$/;"	f
present_mob_specials	mods/builder.cpp	/^void present_mob_specials(player_ptr_t & player, std::size_t index){$/;"	f
primary	mods/player.cpp	/^	obj_data_ptr_t player::primary(){$/;"	f	class:mods::player
primary_choice_t	mods/weapon.hpp	/^		enum primary_choice_t {$/;"	g	namespace:mods::weapon::sentinel
primary_weapon_menu	mods/chargen.cpp	/^	std::string_view primary_weapon_menu(player_class_t class_type){$/;"	f	namespace:mods::chargen
print_group	act.other.cpp	/^void print_group(char_data *ch) {$/;"	f
print_object_location	act.informative.cpp	/^void print_object_location(int num, struct obj_data *obj, char_data *ch,$/;"	f
print_zone_to_buf	act.wizard.cpp	/^size_t print_zone_to_buf(char *bufptr, size_t left, zone_rnum zone) {$/;"	f
process	mods/affects.cpp	/^	void process(){$/;"	f	namespace:mods::affects
process	mods/rooms.cpp	/^		void process(){$/;"	f	namespace:mods::rooms::affects
process_affect	mods/affects.hpp	/^			void process_affect(TAffects affect){$/;"	f	struct:mods::affects::dissolver
process_fire_damage	mods/rooms.cpp	/^	void process_fire_damage() {$/;"	f	namespace:mods::rooms
process_input	comm.cpp	/^int process_input(mods::descriptor_data & t) {$/;"	f
process_output	comm.cpp	/^int process_output(mods::descriptor_data &in_t) {$/;"	f
producing	shop.h	/^	obj_vnum *producing;		\/* Which item to produce (virtual)	*\/$/;"	m	struct:shop_data
proficiencies	mods/skills.hpp	/^	namespace proficiencies {$/;"	n	namespace:mods::skills
proficiency_name_t	mods/skills.hpp	/^		enum proficiency_name_t {$/;"	g	namespace:mods::skills::proficiencies
proficiency_t	mods/skills.hpp	/^		struct proficiency_t {$/;"	s	namespace:mods::skills::proficiencies
profit_buy	shop.h	/^	float profit_buy;		\/* Factor to multiply cost with		*\/$/;"	m	struct:shop_data
profit_sell	shop.h	/^	float profit_sell;		\/* Factor to multiply cost with		*\/$/;"	m	struct:shop_data
projectile	fight.cpp	/^namespace mods::projectile {$/;"	n	class:mods	file:
projectile	mods/projectile.cpp	/^	namespace projectile {$/;"	n	namespace:mods	file:
projectile	mods/projectile.hpp	/^	namespace projectile {$/;"	n	namespace:mods
projectile	mods/sensor-grenade.cpp	/^namespace mods::projectile {$/;"	n	class:mods	file:
projectile_event_t	mods/projectile.hpp	/^		enum projectile_event_t {$/;"	g	namespace:mods::projectile
projectile_lands	mods/projectile.cpp	/^		void projectile_lands(room_rnum room_id,obj_ptr_t object,int from_direction) {$/;"	f	namespace:mods::projectile
propagate_chemical_blast	mods/projectile.cpp	/^		void propagate_chemical_blast(room_rnum& room_id,obj_ptr_t device){$/;"	f	namespace:mods::projectile
propagate_chemical_blast	mods/projectile.cpp	/^		void propagate_chemical_blast(room_rnum& room_id,obj_ptr_t device,std::size_t depth){$/;"	f	namespace:mods::projectile
prune_crlf	utils.cpp	/^void prune_crlf(char *txt) {$/;"	f
psendln	mods/player.cpp	/^	void player::psendln(mods::string& str) {$/;"	f	class:mods::player
psendln	mods/player.cpp	/^	void player::psendln(std::string_view str) {$/;"	f	class:mods::player
psg1	mods/weapon.cpp	/^	obj_data_ptr_t psg1(){$/;"	f	namespace:mods::weapon
psm_debug	db.cpp	1039;"	d	file:
psyop_skillset	class.cpp	/^std::string psyop_skillset() {$/;"	f
pt_allowed	config.cpp	/^int pt_allowed = NO;$/;"	v
ptr	globals.cpp	/^player_ptr_t ptr(char_data* in_ch){$/;"	f
ptr	globals.cpp	/^player_ptr_t ptr(const char_data* in_ch){$/;"	f
ptr	mods/string.hpp	/^		char* ptr() {$/;"	f	struct:mods::string
ptr_by_uuid	globals.cpp	/^player_ptr_t ptr_by_uuid(uuid_t id){$/;"	f
ptr_opt	globals.cpp	/^std::optional<player_ptr_t> ptr_opt(char_data* ch){$/;"	f
ptr_opt	globals.cpp	/^std::optional<player_ptr_t> ptr_opt(uuid_t plr_uuid){$/;"	f
ptrptr	mods/string.hpp	/^		char** ptrptr(){$/;"	f	struct:mods::string
publish	mods/events.cpp	/^	namespace publish {$/;"	n	namespace:mods::events	file:
publish	mods/events.hpp	/^	namespace publish {$/;"	n	namespace:mods::events
publish_event	mods/events.cpp	/^	void publish_event(event_t event,const uuid_t& entity_uuid,void* data,int data2){$/;"	f	namespace:mods::events
puff	spec_assign.cpp	/^SPECIAL(puff);$/;"	v
puff	spec_procs.cpp	/^SPECIAL(puff);$/;"	v
push	mods/deferred.cpp	/^	deferred::lambda_queue_iterator deferred::push(uint64_t ticks_in_future,std::function<void()> lambda) {$/;"	f	class:mods::deferred
push	mods/jx.hpp	/^			compositor& push(bool value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const char* value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, const std::string& value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, double value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, float value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, int value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& key, unsigned int value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(const std::string& value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(double value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(float value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(int value) {$/;"	f	struct:mods::jx::compositor
push	mods/jx.hpp	/^			compositor& push(std::nullptr_t value) {$/;"	f	struct:mods::jx::compositor
push	shop.cpp	/^void push(struct stack_data *stack, int pushval) {$/;"	f
push_chunk_affect	mods/deferred.cpp	/^	void deferred::push_chunk_affect($/;"	f	class:mods::deferred
push_free_list	mail.cpp	/^void push_free_list(long pos) {$/;"	f
push_ticks_event	mods/deferred.cpp	/^	deferred::event_queue_iterator  deferred::push_ticks_event(uint32_t ticks, std::tuple<uuid_t,uint32_t> type){$/;"	f	class:mods::deferred
push_ticks_event	mods/deferred.cpp	/^	void push_ticks_event(uint32_t ticks, std::tuple<uuid_t,uint32_t> type){$/;"	f	namespace:mods
put	mods/lmdb.cpp	/^	int _db_handle::put(std::string key,std::string value){$/;"	f	class:mods::lmdb::_db_handle
put	mods/lmdb.cpp	/^	int _db_handle::put(std::string key,std::string value,bool renew){$/;"	f	class:mods::lmdb::_db_handle
put_player_map	mods/db.cpp	/^int put_player_map(std::string_view player_name,std::string prefix, std::map<std::string,std::string> values){$/;"	f
put_player_vector	mods/db.cpp	/^int put_player_vector(std::string_view player_name,std::string prefix, std::vector<std::string> values){$/;"	f
q	random.cpp	46;"	d	file:
query_parts	mods/sql.hpp	/^			constexpr static int query_parts = 5;$/;"	m	struct:mods::sql::compositor
quest_abort	mods/quests.cpp	/^		static duk_ret_t quest_abort(duk_context *ctx) {$/;"	f	namespace:mods::quests
quest_complete	mods/quests.cpp	/^		static duk_ret_t quest_complete(duk_context *ctx) {$/;"	f	namespace:mods::quests
quests	mods/quests.cpp	/^	namespace quests {$/;"	n	namespace:mods	file:
quests	mods/quests.hpp	/^	namespace quests {$/;"	n	namespace:mods
quests_file_to_lmdb	mods/quests.cpp	/^		int quests_file_to_lmdb(char_data* ch,const std::string& quests_file,const std::string& lmdb_key) {$/;"	f	namespace:mods::quests
queue_affect_on_room	mods/projectile.cpp	/^			void queue_affect_on_room(T affects,room_rnum room_id){$/;"	f	namespace:mods::projectile
queue_head	graph.cpp	/^static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;$/;"	v	typeref:struct:bfs_queue_struct	file:
queue_item_to_be_erased	mods/affects.hpp	/^			void queue_item_to_be_erased(TAffects affect){$/;"	f	struct:mods::affects::dissolver
queue_object_destruct	globals.cpp	/^		void queue_object_destruct(uuid_t obj_uuid, uint16_t ticks){$/;"	f	namespace:mods::globals
queue_object_destruct	mods/camera.cpp	/^	void camera::queue_object_destruct() {$/;"	f	class:mods::camera
queue_on_room	mods/affects.cpp	/^void queue_on_room(std::vector<mods::affects::affect_t> affects,int room_id){$/;"	f
queue_on_room	mods/affects.cpp	/^void queue_on_room(std::vector<mods::affects::affect_t> affects,player_ptr_t player){$/;"	f
queue_output	structs.cpp	/^			void descriptor_data::queue_output(std::string_view msg, bool newline, bool plain) {$/;"	f	class:mods::descriptor_data
queue_page_fragment	mods/player.hpp	/^		void                queue_page_fragment(std::string_view fragment) {$/;"	f	struct:mods::player
queue_remove_texture	mods/projectile.cpp	/^		void queue_remove_texture(uint64_t ticks_in_future,room_rnum& room_id,room_data::texture_type_t texture){$/;"	f	namespace:mods::projectile
queue_tail	graph.cpp	/^static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;$/;"	v	typeref:struct:	file:
quitting	mods/player.hpp	/^		bool quitting(){ return m_quitting; }$/;"	f	struct:mods::player
quitting	mods/player.hpp	/^		void quitting(bool s){ m_quitting = true; }$/;"	f	struct:mods::player
r	random.cpp	49;"	d	file:
r	structs.h	/^		room_data(const room_data& r);$/;"	v
r_error	mods/builder.cpp	/^void r_error(const player_ptr_t & player,std::string_view msg){$/;"	f
r_frozen_start_room	db.cpp	/^room_rnum r_frozen_start_room;	\/* rnum of frozen start room	 *\/$/;"	v
r_idle_room	db.cpp	/^room_rnum r_idle_room;$/;"	v
r_immort_start_room	db.cpp	/^room_rnum r_immort_start_room;	\/* rnum of immort start room	 *\/$/;"	v
r_mortal_start_room	db.cpp	/^room_rnum r_mortal_start_room;	\/* rnum of mortal start room	 *\/$/;"	v
r_status	mods/builder.cpp	/^void r_status(const player_ptr_t & player,std::string_view msg){$/;"	f
r_success	mods/builder.cpp	/^void r_success(const player_ptr_t & player,std::string_view msg){$/;"	f
ram_db	globals.cpp	/^		std::unordered_map<std::string,std::string> ram_db;$/;"	m	namespace:mods::globals	file:
rand	mods/rand.hpp	/^namespace mods::rand {$/;"	n	class:mods
rand_number	mods/rand.cpp	/^int rand_number(int from, int to) {$/;"	f
random_element	globals.cpp	/^			I random_element(I begin, I end) {$/;"	f	namespace:mods::globals
randomized_items	mods/randomized-items.cpp	/^	randomized_items::randomized_items(){$/;"	f	class:mods::randomized_items
randomized_items	mods/randomized-items.hpp	/^	class randomized_items{$/;"	c	namespace:mods
range_multiplier	mods/weapon.hpp	/^			float range_multiplier;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
rarity	mods/rarity.hpp	/^namespace mods::rarity {$/;"	n	class:mods
rarity_enum_t	mods/randomized-items.hpp	/^enum rarity_enum_t {$/;"	g	namespace:mods
rarity_segment	mods/yaml.cpp	/^	std::string rarity_segment(){$/;"	f	namespace:mods::yaml
rarity_strings	mods/yaml.cpp	/^	std::vector<std::pair<std::string,float>> rarity_strings() {$/;"	f	namespace:mods::yaml
rarity_to_string	mods/yaml.cpp	/^	std::string rarity_to_string(float val){$/;"	f	namespace:mods::yaml
rawMemoryToString	mods/catch.hpp	/^		inline std::string rawMemoryToString(const T& object) {$/;"	f	namespace:Catch::Detail
raw_kill	fight.cpp	/^void raw_kill(char_data *ch) {$/;"	f
raw_send	mods/player.cpp	/^	void player::raw_send(const mods::string& str){$/;"	f	class:mods::player
rb_debug	mods/builder.cpp	/^	void rb_debug(T s){$/;"	f	namespace:mods::builder
rb_map_debug	mods/builder.cpp	/^	void rb_map_debug(T & t){$/;"	f	namespace:mods::builder
rd	mods/rand.hpp	/^	static std::random_device rd;$/;"	m	namespace:mods::rand
read_aliases	alias.cpp	/^void read_aliases(char_data *ch) {$/;"	f
read_delete	mail.cpp	/^char *read_delete(long recipient) {$/;"	f
read_from_file	mail.cpp	/^void read_from_file(void *buf, int size, long filepos) {$/;"	f
read_line	shop.cpp	/^void read_line(FILE *shop_f, const char *string, void *data) {$/;"	f
read_list	shop.cpp	/^int read_list(FILE *shop_f, struct shop_buy_data *list, int new_format,$/;"	f
read_lvl	boards.h	/^	int	read_lvl;	\/* min level to read messages on this board *\/$/;"	m	struct:board_info_type
read_mobile	db.cpp	/^char_data *read_mobile(mob_vnum nr, int type) { \/* and mob_rnum *\/$/;"	f
read_mobile	globals.cpp	/^		char_data* read_mobile(const mob_vnum & nr,const int & type){$/;"	f	namespace:mods::globals
read_mobile	mods/js.cpp	/^		static duk_ret_t read_mobile(duk_context *ctx){$/;"	f	namespace:mods::js
read_mobile_ptr	globals.cpp	/^		std::shared_ptr<mods::npc> read_mobile_ptr(const mob_vnum & nr,const int & type){$/;"	f	namespace:mods::globals
read_object	db.cpp	/^struct obj_data *read_object(obj_vnum nr, int type) { \/* and obj_rnum *\/$/;"	f
read_object_ptr	db.cpp	/^obj_ptr_t read_object_ptr(obj_vnum nr, int type) { \/* and obj_rnum *\/$/;"	f
read_shop_message	shop.cpp	/^char *read_shop_message(int mnum, room_vnum shr, FILE *shop_f, const char *why) {$/;"	f
read_type_list	shop.cpp	/^int read_type_list(FILE *shop_f, struct shop_buy_data *list,$/;"	f
real_abils	mods/player.hpp	/^		char_ability_data& real_abils(){	 \/* Abilities without modifiers   *\/$/;"	f	struct:mods::player
real_carrying	mods/player.hpp	/^		std::deque<obj_ptr_t>& real_carrying(){ return m_char_data->m_carrying; }$/;"	f	struct:mods::player
real_frozen	mods/world-configuration.cpp	/^		int real_frozen(){$/;"	f	namespace:mods::world_conf
real_idle	mods/world-configuration.cpp	/^		int real_idle(){$/;"	f	namespace:mods::world_conf
real_immortal_start	mods/world-configuration.cpp	/^		int real_immortal_start(){$/;"	f	namespace:mods::world_conf
real_mobile	db.cpp	/^mob_rnum real_mobile(mob_vnum vnum) {$/;"	f
real_mobile	mods/js.cpp	/^		static duk_ret_t real_mobile(duk_context *ctx){$/;"	f	namespace:mods::js
real_mortal_start	mods/world-configuration.cpp	/^		int real_mortal_start(){$/;"	f	namespace:mods::world_conf
real_object	db.cpp	/^obj_rnum real_object(obj_vnum vnum) {$/;"	f
real_room	db.cpp	/^room_rnum real_room(room_vnum vnum) {$/;"	f
real_room	mods/rooms.hpp	/^	inline room_rnum real_room(room_vnum room_id){$/;"	f	namespace:mods::rooms
real_time_passed	utils.cpp	/^struct time_info_data *real_time_passed(time_t t2, time_t t1) {$/;"	f
real_zone	db.cpp	/^room_rnum real_zone(room_vnum vnum) {$/;"	f
reap	comm.cpp	/^RETSIGTYPE reap(int sig) {$/;"	f
reboot_wizlists	db.cpp	/^void reboot_wizlists(void) {$/;"	f
receptionist	objsave.cpp	/^SPECIAL(receptionist);$/;"	v
receptionist	spec_assign.cpp	/^SPECIAL(receptionist);$/;"	v
recipient	mail.h	/^	long recipient;			\/* who is this mail for?	*\/$/;"	m	struct:mail_index_type_d
reconstructExpression	mods/catch.hpp	/^		std::string const& reconstructExpression() const {$/;"	f	class:Catch::AssertionResultData::std
reconstructedExpression	mods/catch.hpp	/^		mutable std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData
record_usage	comm.cpp	/^void record_usage(void) {$/;"	f
refresh_player_states	globals.cpp	/^		void refresh_player_states() {$/;"	f	namespace:mods::globals
refresh_skill_name_list	mods/skills.cpp	/^	void refresh_skill_name_list() {$/;"	f	namespace:mods::skills
register_authenticated_player	globals.cpp	/^		void register_authenticated_player(player_ptr_t player){$/;"	f	namespace:mods::globals
register_callback	mods/events.cpp	/^	void register_callback(event_t event,callback_t cb){$/;"	f	namespace:mods::events
register_mob	mods/behaviour_tree_impl.cpp	/^	int8_t register_mob(argument_type mob,std::string tree_name){$/;"	f	namespace:mods::behaviour_tree_impl
register_object	globals.cpp	/^		void register_object(obj_ptr_t obj) {$/;"	f	namespace:mods::globals
register_object_db_id	globals.cpp	/^		void register_object_db_id(uint64_t db_id,uuid_t uuid){$/;"	f	namespace:mods::globals
register_object_list	globals.cpp	/^		void register_object_list() {$/;"	f	namespace:mods::globals
register_player	globals.cpp	/^		void register_player(player_ptr_t player){$/;"	f	namespace:mods::globals
register_room	globals.cpp	/^		void register_room(const room_rnum& r) {$/;"	f	namespace:mods::globals
register_shop	globals.hpp	/^		void register_shop(TShopPtr shop){$/;"	f	namespace:mods::globals
release	mods/catch.hpp	/^		virtual void release() const {$/;"	f	struct:Catch::SharedImpl
release_zone	mods/builder.cpp	/^void release_zone(int zone){$/;"	f
reload	mods/object-utils.hpp	/^	void reload(T& player, obj_ptr_t& weapon) {$/;"	f	namespace:mods::object_utils
reload_object	mods/weapon.cpp	/^	void reload_object(player_ptr_t & player, obj_ptr_t weapon,std::string_view with){$/;"	f	namespace:mods::weapon
reload_primary_with	mods/weapon.cpp	/^	void reload_primary_with(player_ptr_t& player,std::string_view with_clip){$/;"	f	namespace:mods::weapon
reload_secondary_with	mods/weapon.cpp	/^	void reload_secondary_with(player_ptr_t& player,std::string_view with_clip){$/;"	f	namespace:mods::weapon
reload_time	mods/weapon.hpp	/^			int reload_time;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
remember	mobact.cpp	/^void remember(char_data *ch,char_data *victim) {$/;"	f
remove	mods/affects.hpp	/^			void remove(TAffects id){$/;"	f	struct:mods::affects::dissolver
remove_affect	mods/player.cpp	/^	void player::remove_affect(uint64_t flag){$/;"	f	class:mods::player
remove_affect_plr	mods/player.cpp	/^	void player::remove_affect_plr(uint64_t flag){$/;"	f	class:mods::player
remove_dark	mods/rooms.hpp	/^			static inline void remove_dark(TRoom room) {$/;"	f	namespace:mods::rooms::gods
remove_flag	mods/player.hpp	/^		aligned_int_t remove_flag(chunk_type_t chunk,aligned_int_t bit){$/;"	f	struct:mods::player
remove_flag	mods/rooms.hpp	/^	static inline void remove_flag(room_rnum room, int flag){$/;"	f	namespace:mods::rooms
remove_if_exists	mods/util-map.hpp	/^			static inline void remove_if_exists(TMapType* in_map,TKeyType key){$/;"	f	namespace:mods::util::maps
remove_lvl	boards.h	/^	int	remove_lvl;	\/* min level to remove messages from this board *\/$/;"	m	struct:board_info_type
remove_room_dissolve_affect	mods/rooms.cpp	/^		void remove_room_dissolve_affect(room_rnum room, affect_t item){$/;"	f	namespace:mods::rooms::affects
remove_subscriber	mods/chat.cpp	/^	void channel::remove_subscriber(const socket_t& sock) {$/;"	f	class:mods::chat::channel
remove_texture	structs.cpp	/^		void room_data::remove_texture(texture_type_t t){$/;"	f	class:room_data
remove_type	mods/object.cpp	/^	object& object::remove_type(object_type_enum_t type){$/;"	f	class:mods::object
renew_txn	mods/lmdb.cpp	/^	_db_handle::tuple_return_type_t _db_handle::renew_txn(){$/;"	f	class:mods::lmdb::_db_handle
rent_file_timeout	config.cpp	/^int rent_file_timeout = 30;$/;"	v
rent_info	structs.h	/^	struct rent_info {$/;"	s
rentcode	structs.h	/^		int	rentcode;$/;"	m	struct:rent_info
renum_world	db.cpp	/^void renum_world(void) {$/;"	f
renum_zone_table	db.cpp	/^void renum_zone_table(void) {$/;"	f
replace_all	globals.cpp	/^		std::string replace_all(std::string str, const std::string& from, const std::string& to) {$/;"	f	namespace:mods::globals
replace_string	fight.cpp	/^char *replace_string(const char *str, const char *weapon_singular, const char *weapon_plural) {$/;"	f
replacement	interpreter.h	/^	char *replacement;$/;"	m	struct:alias_data
report	mods/player.cpp	/^	void player::report(){$/;"	f	class:mods::player
report_error	mods/builder.hpp	/^	void report_error(T player,std::string_view message) {$/;"	f	namespace:mods::builder
report_status	mods/builder.hpp	/^	void report_status(T player,std::string_view message) {$/;"	f	namespace:mods::builder
report_success	mods/builder.hpp	/^	void report_success(T player,std::string_view message) {$/;"	f	namespace:mods::builder
report_yaml_exception	mods/object-utils.hpp	/^	static inline void report_yaml_exception(TException& e,std::vector<std::string>& items_fed){$/;"	f	namespace:mods::object_utils
require_js	mods/js.cpp	/^		static duk_ret_t require_js(duk_context *ctx) {$/;"	f	namespace:mods::js
require_test	mods/js.cpp	/^			static duk_ret_t require_test(duk_context *ctx) {$/;"	f	namespace:mods::js::test
reread_wizlist	comm.cpp	/^byte reread_wizlist;		\/* signal: SIGUSR1 *\/$/;"	v
reread_wizlists	comm.cpp	/^RETSIGTYPE reread_wizlists(int sig) {$/;"	f
reserved	interpreter.cpp	/^const char *reserved[] = {$/;"	v
reserved	mods/lmdb.hpp	/^		uint32_t reserved;$/;"	m	struct:mods::lmdb::_selector
reserved_mobs	act.builder.cpp	/^	static std::vector<int> reserved_mobs;$/;"	m	namespace:mods::adhoc	file:
reserved_objects	act.builder.cpp	/^	static std::vector<int> reserved_objects;$/;"	m	namespace:mods::adhoc	file:
reserved_rooms	act.builder.cpp	/^	static std::vector<int> reserved_rooms;$/;"	m	namespace:mods::adhoc	file:
reserved_word	interpreter.cpp	/^int reserved_word(char *argument) {$/;"	f
reserved_zones	act.builder.cpp	/^	static std::vector<int> reserved_zones;$/;"	m	namespace:mods::adhoc	file:
reset	mods/catch.hpp	/^			void reset() {$/;"	f	class:Catch::Ptr
reset_char	db.cpp	/^void reset_char(char_data *ch) {$/;"	f
reset_com	db.h	/^	reset_com() : command('X'),$/;"	f	struct:reset_com
reset_com	db.h	/^struct reset_com {$/;"	s
reset_mode	db.h	/^	int	reset_mode;         \/* conditions for reset (see below)   *\/$/;"	m	struct:zone_data
reset_points	mods/player-scaffolding.cpp	/^	void player_scaffolding::reset_points(player_ptr_t player,std::map<std::string_view,int> * points_map){$/;"	f	class:mods::player_scaffolding
reset_q	db.cpp	/^struct reset_q_type reset_q;	\/* queue of zones to be reset	 *\/$/;"	v	typeref:struct:reset_q_type
reset_q_element	db.h	/^struct reset_q_element {$/;"	s
reset_q_type	db.h	/^struct reset_q_type {$/;"	s
reset_time	db.cpp	/^void reset_time(void) {$/;"	f
reset_zone	db.cpp	/^void reset_zone(zone_rnum zone) {$/;"	f
resolve_room	mods/projectile.cpp	/^		room_rnum resolve_room(room_rnum source_room,int direction,std::size_t depth) {$/;"	f	namespace:mods::projectile
resultDisposition	mods/catch.hpp	/^		ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo
resultType	mods/catch.hpp	/^		ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData
return_codes	mods/meta_utils.cpp	/^	enum return_codes {$/;"	g	namespace:mods::meta_utils	file:
returning	mods/sql.hpp	/^			compositor<T>& returning(str_object column) {$/;"	f	struct:mods::sql::compositor
rev_dir	constants.cpp	/^int rev_dir[] = {$/;"	v
rev_dir	constants.hpp	/^int rev_dir[] =$/;"	v
revert_to_default	mods/values.cpp	/^		void revert_to_default(std::string in_key){$/;"	f	namespace:mods::values
rifle	mods/injure.cpp	/^	namespace rifle {$/;"	n	namespace:mods::injure	file:
rifle	mods/injure.hpp	/^	namespace rifle {$/;"	n	namespace:mods::injure
rifle	mods/item-types.hpp	/^	enum rifle {$/;"	g	namespace:mods::weapon::type
rifle	mods/player.cpp	/^	rifle_data_t* player::rifle() {$/;"	f	class:mods::player
rifle	mods/weapon.cpp	/^	mw_rifle rifle(obj_data_ptr_t& object){$/;"	f	namespace:mods::weapon
rifle_description_t	mods/weapon.hpp	/^			rifle_description_t() : $/;"	f	struct:mods::weapon::yaml::rifle_description_t
rifle_description_t	mods/weapon.hpp	/^		struct rifle_description_t {$/;"	s	namespace:mods::weapon::yaml
rifle_description_t	mods/yaml.hpp	/^		rifle_description_t() : $/;"	f	struct:mods::yaml::rifle_description_t
rifle_description_t	mods/yaml.hpp	/^	struct rifle_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
rifle_instance	structs.h	/^		std::unique_ptr<rifle_instance_data> rifle_instance;$/;"	m	struct:obj_data
rifle_instance_data	structs.h	/^		rifle_instance_data() : ammo(0) {$/;"	f	struct:rifle_instance_data
rifle_instance_data	structs.h	/^	struct rifle_instance_data {$/;"	s
right_join	mods/sql.hpp	/^			compositor<T>& right_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
right_outer_join	mods/sql.hpp	/^			compositor<T>& right_outer_join(std::string_view table) {$/;"	f	struct:mods::sql::compositor
rnum	boards.h	/^	obj_rnum rnum;	\/* rnum of this board *\/$/;"	m	struct:board_info_type
roll	mods/rand.hpp	/^	static inline int roll(int number, int size) {$/;"	f	namespace:mods::rand
roll_real_abils	class.cpp	/^void roll_real_abils(char_data *ch) {$/;"	f
room	graph.cpp	/^	room_rnum room;$/;"	m	struct:bfs_queue_struct	file:
room	mods/camera.cpp	/^	int camera::room() {$/;"	f	class:mods::camera
room	mods/js.cpp	/^		static duk_ret_t room(duk_context *ctx){$/;"	f	namespace:mods::js
room	mods/player.hpp	/^		room_rnum& room(){$/;"	f	struct:mods::player
room_bits	constants.cpp	/^const char *room_bits[] = {$/;"	v
room_bits	constants.hpp	/^const char *room_bits[] = {$/;"	v
room_bits_count	constants.cpp	/^size_t	room_bits_count = sizeof(room_bits) \/ sizeof(room_bits[0]) - 1,$/;"	v
room_bits_count	constants.hpp	/^size_t	room_bits_count = sizeof(room_bits) \/ sizeof(room_bits[0]) - 1,$/;"	v
room_data	structs.cpp	/^		room_data::room_data() {$/;"	f	class:room_data
room_data	structs.cpp	/^		room_data::room_data(const room_data& r){$/;"	f	class:room_data
room_data	structs.h	/^	struct room_data {$/;"	s
room_direction_data	structs.h	/^	struct room_direction_data {$/;"	s
room_distance	mods/scan.cpp	/^	std::tuple<bool,distance_t> room_distance(room_rnum& source,room_rnum& dest){$/;"	f	namespace:mods::scan
room_event	globals.cpp	/^		void room_event(room_vnum room,mods::ai_state::event_type_t event) {$/;"	f	namespace:mods::globals
room_flag_from_string	mods/rooms.hpp	/^	static inline std::optional<int> room_flag_from_string(std::string& s){$/;"	f	namespace:mods::rooms
room_flag_strings	mods/rooms.hpp	/^	static const std::map<int,std::string> room_flag_strings = {$/;"	m	namespace:mods::rooms
room_flags	structs.h	/^		int room_flags;		\/* DEATH,DARK ... etc *\/$/;"	v
room_info	shop.h	/^	TRoomInfo room_info;$/;"	m	struct:shop_data
room_is_dark	utils.cpp	/^int room_is_dark(room_rnum room) {$/;"	f
room_list	globals.cpp	/^		room_list_t room_list;$/;"	m	namespace:mods::globals	file:
room_list	globals.hpp	/^inline mods::globals::player_list_t& room_list(room_rnum r){ return mods::globals::get_room_list(r); }$/;"	f
room_mappings	mods/builder.cpp	/^	static std::map<int,int> room_mappings;$/;"	m	namespace:mods::builder	file:
room_pave_mode	mods/player.cpp	/^	bool player::room_pave_mode(){$/;"	f	class:mods::player
room_rnum	structs.h	/^	typedef IDXTYPE room_rnum;$/;"	t
room_shopmap	shop.cpp	/^	std::map<room_rnum,std::shared_ptr<shop_data_t>> room_shopmap;$/;"	m	namespace:mods::globals	file:
room_vnum	structs.h	/^	typedef IDXTYPE room_vnum;$/;"	t
rooms	db.cpp	/^namespace mods::rooms {$/;"	n	class:mods	file:
rooms	globals.cpp	/^		namespace rooms {$/;"	n	namespace:mods::globals	file:
rooms	globals.hpp	/^		namespace rooms {$/;"	n	namespace:mods::globals
rooms	mods/events.cpp	/^		namespace rooms {$/;"	n	namespace:mods::events::publish	file:
rooms	mods/events.hpp	/^		namespace rooms {$/;"	n	namespace:mods::events::publish
rooms	mods/rooms.cpp	/^namespace mods::rooms {$/;"	n	class:mods	file:
rooms	mods/rooms.hpp	/^namespace mods::rooms {$/;"	n	class:mods
rooms	mods/world-configuration.cpp	/^	rooms_t rooms;$/;"	m	namespace:mods::world_conf	file:
round	bsd-snprintf.cpp	/^round(long double value) {$/;"	f	file:
rounds_per_minute	mods/weapon.hpp	/^			int rounds_per_minute;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
routines	spells.h	/^	int routines;$/;"	m	struct:spell_info_type
row_id	mods/lmdb.hpp	/^		uint64_t row_id;$/;"	m	struct:mods::lmdb::_selector
run	mods/behaviour_tree.hpp	/^		run_status run(LambdaArgument arg) {$/;"	f	struct:mods::behaviour_tree
run	mods/behaviour_tree_node.hpp	/^		run_status_t run(LambdaArgument & arg){$/;"	f	struct:mods::behaviour_tree_node
run	mods/debug-pre-game.hpp	/^	bool run(){$/;"	f	namespace:mods::debug::pre_game
run_autowiz	limits.cpp	/^void run_autowiz(void) {$/;"	f
run_profile_scripts	config.cpp	/^	bool run_profile_scripts;$/;"	m	namespace:config	file:
run_profile_scripts	mods/js.cpp	/^		void run_profile_scripts(const std::string& player_name){$/;"	f	namespace:mods::js
run_status_t	mods/behaviour_tree_node.hpp	/^		} run_status_t;$/;"	t	struct:mods::behaviour_tree_node	typeref:struct:mods::behaviour_tree_node::__anon2
run_test_suite	mods/js.cpp	/^		bool run_test_suite(mods::player& player,std::string_view suite) {$/;"	f	namespace:mods::js
run_trees	mods/behaviour_tree_impl.cpp	/^	void run_trees(){$/;"	f	namespace:mods::behaviour_tree_impl
run_trigger	mods/quests.cpp	/^		int run_trigger(char_data* ch) {$/;"	f	namespace:mods::quests
s	mods/catch.hpp	/^			static std::ostream& s;$/;"	m	struct:Catch::Detail::IsStreamInsertable
s_addr	sysdep.h	/^	unsigned long int s_addr;	\/* for inet_addr, etc. *\/$/;"	m	struct:in_addr
same_obj	shop.cpp	/^int same_obj(struct obj_data *obj1, struct obj_data *obj2) {$/;"	f
sandbox_data_t	mods/builder.cpp	/^	sandbox_data_t::sandbox_data_t($/;"	f	class:mods::builder::sandbox_data_t
sandbox_data_t	mods/builder.cpp	/^	sandbox_data_t::sandbox_data_t() : m_name("") {}$/;"	f	class:mods::builder::sandbox_data_t
sandbox_data_t	mods/builder.hpp	/^	struct sandbox_data_t {$/;"	s	namespace:mods::builder
sandboxes	mods/builder.cpp	/^	sandbox_list_t sandboxes;$/;"	m	namespace:mods::builder	file:
sanitize	mods/util.cpp	/^		std::function<void(const std::string&,std::string&)> sanitize = [](const std::string & command,std::string& sanitized){$/;"	m	namespace:mods::util	file:
sanitize_key	mods/lmdb.cpp	/^std::string sanitize_key(std::string key){$/;"	f
save	shop.cpp	/^std::tuple<bool,uint64_t,std::string> shop_data<mods::orm::shop,mods::orm::shop_rooms,mods::orm::shop_objects>::save(){$/;"	f	class:shop_data
save_char	mods/db.cpp	/^tuple_status_t save_char($/;"	f	namespace:mods::db
save_char_data	db.cpp	/^	int16_t save_char_data(player_ptr_t& player,std::map<std::string,std::string> values){$/;"	f	namespace:db
save_char_prefs	db.cpp	/^	int16_t save_char_prefs(player_ptr_t& player){$/;"	f	namespace:db
save_etext	db.cpp	/^void save_etext(char_data *ch) {$/;"	f
save_mud_time	db.cpp	/^void save_mud_time(struct time_info_data *when) {$/;"	f
save_new_char	db.cpp	/^	int16_t save_new_char(player_ptr_t& player){$/;"	f	namespace:db
save_new_char	mods/db.cpp	/^tuple_status_t save_new_char($/;"	f	namespace:mods::db
save_object	mods/builder.cpp	/^	std::pair<bool,std::string> save_object(int item_number,int obj_type,std::string feed_file) {$/;"	f	namespace:mods::builder
save_object_vector	mods/builder_util.hpp	/^	void save_object_vector($/;"	f	namespace:mods::builder_util
save_player	db.cpp	/^		void save_player(player_ptr_t& player){$/;"	f	namespace:db::extraction
save_player	mods/builder.cpp	/^	std::pair<bool,std::string> save_player(char_data* obj) {$/;"	f	namespace:mods::builder
save_record	mods/db.cpp	/^tuple_status_t save_record(const std::string& table,mutable_map_t* values,std::string pk_id){$/;"	f	namespace:mods::db
save_record_get_id	mods/db.cpp	/^aligned_int_t save_record_get_id($/;"	f	namespace:mods::db
save_room_distance_to_cache	mods/scan.cpp	/^	void save_room_distance_to_cache(const room_rnum& hunters_room,$/;"	f	namespace:mods::scan
save_to_db	mods/builder.cpp	/^	int save_to_db(room_rnum in_room,std::string & error_string) {$/;"	f	namespace:mods::builder
save_to_db	mods/builder_util.hpp	/^	std::pair<bool,std::string> save_to_db($/;"	f	namespace:mods::builder_util
save_to_lmdb	mods/values.cpp	/^		void save_to_lmdb(std::string key,std::string value){$/;"	f	namespace:mods::values
save_yaml_exceptions_to_disk	mods/object-utils.hpp	/^	static inline std::tuple<int32_t,std::string> save_yaml_exceptions_to_disk(){$/;"	f	namespace:mods::object_utils
save_zone_to_db	mods/builder.cpp	/^	std::tuple<bool,zone_pkid_t> save_zone_to_db(int virtual_number,std::string_view zone_name,int zone_start,int zone_end,int lifespan,int reset_mode) {$/;"	f	namespace:mods::builder
saved	mods/player.hpp	/^		char_special_data_saved& saved(){$/;"	f	struct:mods::player
saving_throws	class.cpp	/^byte saving_throws(int class_num, int type, int level) {$/;"	f
say_random	globals.cpp	/^		const char* say_random(const mods::ai_state::event_type_t& event) {$/;"	f	namespace:mods::globals
say_spell	spell_parser.cpp	/^void say_spell(char_data *ch, int spellnum, char_data *tch,$/;"	f
sbyte	structs.h	/^	typedef signed char		sbyte;$/;"	t
scan	mods/scan.cpp	/^namespace mods::scan {$/;"	n	class:mods	file:
scan	mods/scan.hpp	/^	namespace scan {$/;"	n	namespace:mods
scan_file	mail.cpp	/^int scan_file(void) {$/;"	f
scan_file	mods/hell.hpp	/^	constexpr inline bool scan_file = false;$/;"	m	namespace:mods::hell
scan_from_room	mods/sensor-grenade.cpp	/^	std::vector<int> scan_from_room(int blast_radius,const room_rnum& room_number){$/;"	f	namespace:mods::sensor_grenade
scheck	comm.cpp	/^int scheck = 0;			\/* for syntax checking mode *\/$/;"	v
schema	mods/schema.hpp	/^namespace mods::schema { $/;"	n	class:mods
scope_t	mods/weapon.hpp	/^	enum scope_t {$/;"	g	namespace:mods::weapon
search_block	interpreter.cpp	/^int search_block(char *arg, const char **list, int exact) { \/** FIXME: arg 2  *\/$/;"	f
secondary	mods/player.cpp	/^	obj_data_ptr_t player::secondary(){$/;"	f	class:mods::player
sector_from_string	mods/rooms.cpp	/^	std::optional<sector_type_t> sector_from_string(std::string m){$/;"	f	namespace:mods::rooms
sector_type	structs.h	/^		uint16_t	sector_type;            \/* sector type (move\/hide)            *\/$/;"	v
sector_type_t	mods/rooms.hpp	/^	enum sector_type_t {$/;"	g	namespace:mods::rooms
sector_types	constants.cpp	/^const char *sector_types[] = {$/;"	v
sector_types	constants.hpp	/^const char *sector_types[] = {$/;"	v
seed	mods/ai_state.cpp	/^	void seed() {$/;"	f	namespace:mods
seed	random.cpp	/^static unsigned long seed;$/;"	v	file:
select	mods/sql.hpp	/^			compositor<T>& select(str_object fields) {$/;"	f	struct:mods::sql::compositor
select_randomly	globals.cpp	/^			Iter select_randomly(Iter start, Iter end) {$/;"	f	namespace:mods::globals
select_randomly	globals.cpp	/^			Iter select_randomly(Iter start, Iter end, RandomGenerator& g) {$/;"	f	namespace:mods::globals
select_value	mods/world-configuration.cpp	/^	std::pair<bool,std::string> select_value(std::string_view table,$/;"	f	namespace:mods::world_conf
selector	mods/lmdb.cpp	/^	selector_type_t transaction_t::selector(const key_type_t & column,const uint64_t & row_id){$/;"	f	class:mods::lmdb::transaction_t
sell_price	shop.cpp	/^int sell_price(struct obj_data *obj, int shop_nr, char_data *keeper, char_data *seller) {$/;"	f
send	mods/js.cpp	/^		static duk_ret_t send(duk_context *ctx) {$/;"	f	namespace:mods::js
send	mods/player.cpp	/^	size_t player::send(const char *messg, ...) {$/;"	f	class:mods::player
send_results	mods/sensor-grenade.cpp	/^	void send_results(uuid_t nade_uuid,uuid_t player_uuid){$/;"	f	namespace:mods::sensor_grenade
send_results_multi	mods/sensor-grenade.cpp	/^	void send_results_multi(uuid_t nade_uuid,const std::vector<uuid_t>& players){$/;"	f	namespace:mods::sensor_grenade
send_to_all	comm.cpp	/^void send_to_all(const char *messg, ...) {$/;"	f
send_to_char	comm.cpp	/^size_t send_to_char(char_data *ch, const char *messg, ...) {$/;"	f
send_to_char	mods/js.cpp	/^		static duk_ret_t send_to_char(duk_context *ctx) {$/;"	f	namespace:mods::js
send_to_outdoor	comm.cpp	/^void send_to_outdoor(const char *messg, ...) {$/;"	f
send_to_room	comm.cpp	/^void send_to_room(room_rnum room, const char *messg, ...) {$/;"	f
send_to_room_except	comm.cpp	/^void send_to_room_except(room_rnum room, const std::vector<char_data*>& except, const char *messg, ...) {$/;"	f
send_to_room_except	comm.cpp	/^void send_to_room_except(room_rnum room, player_ptr_t except_me, const char *messg, ...) {$/;"	f
send_to_room_except	comm.cpp	/^void send_to_room_except(room_rnum room, std::vector<uuid_t> except, const char *messg, ...) {$/;"	f
send_to_uuid	mods/js.cpp	/^		static duk_ret_t send_to_uuid(duk_context *ctx) {$/;"	f	namespace:mods::js
send_yaml_exceptions_to	mods/object-utils.hpp	/^	static inline void send_yaml_exceptions_to(TPlayerPointer& player){$/;"	f	namespace:mods::object_utils
sendln	mods/player.cpp	/^	void player::sendln(mods::string& str) {$/;"	f	class:mods::player
sendln	mods/player.cpp	/^	void player::sendln(std::string_view str) {$/;"	f	class:mods::player
sense_player	mods/calc_visibility.cpp	/^	bool sense_player(obj_ptr_t& device, player_ptr_t& target){$/;"	f	namespace:mods::calc::visibility
sensor_grenade	mods/sensor-grenade.cpp	/^namespace mods::sensor_grenade {$/;"	n	class:mods	file:
sensor_grenade	mods/sensor-grenade.hpp	/^namespace mods::sensor_grenade {$/;"	n	class:mods
sentinel	mods/weapon.hpp	/^	namespace sentinel {$/;"	n	namespace:mods::weapon
sentinel_skillset	class.cpp	/^std::string sentinel_skillset() {$/;"	f
set	mods/prefs.cpp	/^	void prefs::set(const std::string& key,const std::string& value,char_data* ch) {$/;"	f	class:mods::prefs
set	mods/sql.hpp	/^			compositor<T>& set(const value_map& values) {$/;"	f	struct:mods::sql::compositor
set_access_rights	mods/acl_list.cpp	/^	void set_access_rights(player_ptr_t player,$/;"	f	namespace:mods::acl_list
set_affect_max_amount	mods/rooms.cpp	/^		void set_affect_max_amount(room_rnum room,affect_t affect,affect_amount_t amount){$/;"	f	namespace:mods::rooms::affects
set_affect_to_decrement	mods/rooms.cpp	/^		void set_affect_to_decrement(room_rnum room,affect_t affect){$/;"	f	namespace:mods::rooms::affects
set_affect_to_increment	mods/rooms.cpp	/^		void set_affect_to_increment(room_rnum room,affect_t affect){$/;"	f	namespace:mods::rooms::affects
set_ammo	mods/object-utils.hpp	/^		void set_ammo(obj_ptr_t& weapon,uint16_t ammo){$/;"	f	namespace:mods::object_utils::gods
set_ammo	mods/player.hpp	/^		uint16_t set_ammo(uint16_t value){$/;"	f	struct:mods::player
set_attacking_with	mods/player.hpp	/^		void set_attacking_with(obj_ptr_t weapon){ m_attacking_with = weapon; }$/;"	f	struct:mods::player
set_attacking_with_primary	mods/player.cpp	/^	void player::set_attacking_with_primary(){$/;"	f	class:mods::player
set_attacking_with_secondary	mods/player.cpp	/^	void player::set_attacking_with_secondary(){$/;"	f	class:mods::player
set_attribute_on_object_vector	mods/builder_util.hpp	/^	void set_attribute_on_object_vector($/;"	f	namespace:mods::builder_util
set_authenticated	mods/player.hpp	/^		void set_authenticated(bool b) { m_authenticated = b; }$/;"	f	struct:mods::player
set_bad_password_count	mods/player.cpp	/^	void player::set_bad_password_count(int i){$/;"	f	class:mods::player
set_behaviour_tree	structs.cpp	/^		void mob_special_data::set_behaviour_tree(std::string_view name){$/;"	f	class:mob_special_data
set_bui_mode	mods/player.cpp	/^	void player::set_bui_mode(bool b){$/;"	f	class:mods::player
set_callback	mods/affects.hpp	/^		void set_callback(TAffects affect, std::function<void(TEntityId,TAffects,uint32_t)> f){$/;"	f	struct:mods::affects::dissolver
set_camera	mods/player.cpp	/^	void player::set_camera(obj_data_ptr_t obj){$/;"	f	class:mods::player
set_camera_viewing	mods/player.cpp	/^	void player::set_camera_viewing(bool b){$/;"	f	class:mods::player
set_cd	mods/drone.hpp	/^			void set_cd(char_data* ch) {$/;"	f	class:mods::drone
set_cd	mods/player.cpp	/^	void player::set_cd(char_data* ch) {$/;"	f	class:mods::player
set_char_on_descriptor	mods/player.cpp	/^	void player::set_char_on_descriptor(std::deque<descriptor_data>::iterator it){$/;"	f	class:mods::player
set_char_pk_id	mods/js.cpp	/^		static duk_ret_t set_char_pk_id(duk_context *ctx){$/;"	f	namespace:mods::js
set_children	mods/behaviour_tree_node.hpp	/^		void set_children(const children_t & child_nodes){$/;"	f	struct:mods::behaviour_tree_node
set_class	mods/player.cpp	/^	void player::set_class(player_class_t pclass){$/;"	f	class:mods::player
set_context	mods/js.hpp	/^				inline void set_context(duk_context *ctx) {$/;"	f	struct:mods::js::include
set_db_id	mods/player.cpp	/^	void player::set_db_id(aligned_int_t id){$/;"	f	class:mods::player
set_db_id	structs.h	/^		void set_db_id(uint64_t i){ this->m_db_id = i; }$/;"	f	struct:obj_data
set_desc	mods/player.cpp	/^	void player::set_desc(std::deque<descriptor_data>::iterator it){ $/;"	f	class:mods::player
set_desc	mods/player.cpp	/^	void player::set_desc(std::shared_ptr<descriptor_data> it){ $/;"	f	class:mods::player
set_dir	mods/js.hpp	/^				inline void set_dir(const std::string& m) {$/;"	f	struct:mods::js::include
set_dir_option	structs.cpp	/^		void room_data::set_dir_option(byte i,$/;"	f	class:room_data
set_direction	mods/affects.hpp	/^			void set_direction(TAffects affect, bool direction){$/;"	f	struct:mods::affects::dissolver
set_done_breaching	mods/object-utils.hpp	/^		void set_done_breaching(T& obj){$/;"	f	namespace:mods::object_utils
set_done_installing	mods/object-utils.hpp	/^		void set_done_installing(T& obj){$/;"	f	namespace:mods::object_utils
set_feed_file	structs.h	/^		void set_feed_file(std::string f){ m_feed_file = f; }$/;"	f	struct:obj_data
set_fields	act.wizard.cpp	/^} set_fields[] = {$/;"	v	typeref:struct:set_struct
set_fight_timestamp	mods/player.hpp	/^		void set_fight_timestamp(){ m_char_data->last_fight_timestamp = std::time(NULL); }$/;"	f	struct:mods::player
set_fighting	fight.cpp	/^void set_fighting(char_data *ch, char_data *vict) {$/;"	f
set_file	mods/js.hpp	/^				inline void set_file(const std::string& m) {$/;"	f	struct:mods::js::include
set_fire	mods/rooms.cpp	/^		void set_fire(room_rnum room,bool on,std::string& level,player_ptr_t& player) {$/;"	f	namespace:mods::rooms::gods
set_flag	mods/player.hpp	/^		aligned_int_t set_flag(chunk_type_t chunk,aligned_int_t bit){$/;"	f	struct:mods::player
set_flag	mods/rooms.hpp	/^	static inline void set_flag(room_rnum room, int flag){$/;"	f	namespace:mods::rooms
set_flag_absolute	mods/rooms.cpp	/^	void set_flag_absolute(room_rnum room, int flag){$/;"	f	namespace:mods::rooms
set_frozen_room	mods/world-configuration.cpp	/^	std::pair<bool,std::string> set_frozen_room(room_vnum room_id){$/;"	f	namespace:mods::world_conf
set_god_mode	mods/player.cpp	/^	void player::set_god_mode(bool b){$/;"	f	class:mods::player
set_host	mods/player.cpp	/^	void player::set_host(std::string host){$/;"	f	class:mods::player
set_id	db.h	/^	void set_id(int64_t i){ m_id = i; }$/;"	f	struct:zone_data
set_idle_room	mods/world-configuration.cpp	/^	std::pair<bool,std::string> set_idle_room(room_vnum room_id){$/;"	f	namespace:mods::world_conf
set_immortal_start_room	mods/world-configuration.cpp	/^	std::pair<bool,std::string> set_immortal_start_room(room_vnum room_id){$/;"	f	namespace:mods::world_conf
set_imp_mode	mods/player.cpp	/^	void player::set_imp_mode(bool b){$/;"	f	class:mods::player
set_is_breaching	mods/object-utils.hpp	/^		void set_is_breaching(T& obj, P& player,int direction){$/;"	f	namespace:mods::object_utils
set_is_installing	mods/object-utils.hpp	/^		void set_is_installing(T& obj, P& player,int direction){$/;"	f	namespace:mods::object_utils
set_lense	mods/player.hpp	/^		void set_lense(const lense_type_t& lense){ m_lense_type = lense; }$/;"	f	struct:mods::player
set_location_data	structs.h	/^		void set_location_data(location_data_t i){ m_location_data = i; }$/;"	f	struct:obj_data
set_logic	mods/behaviour_tree_node.hpp	/^		void set_logic(const callback_t & logic){$/;"	f	struct:mods::behaviour_tree_node
set_max_amount	mods/affects.hpp	/^			void set_max_amount(TAffects affect, uint32_t max){$/;"	f	struct:mods::affects::dissolver
set_misc_pref	mods/player.hpp	/^		void set_misc_pref(misc_pref_enum_t bit,bool on_off){$/;"	f	struct:mods::player
set_mortal_start_room	mods/world-configuration.cpp	/^	std::pair<bool,std::string> set_mortal_start_room(room_vnum room_id){$/;"	f	namespace:mods::world_conf
set_name	mods/builder.cpp	/^	void sandbox_data_t::set_name(std::string_view n){$/;"	f	class:mods::builder::sandbox_data_t
set_name	mods/chat.cpp	/^	void channel::set_name(std::string_view name) {$/;"	f	class:mods::chat::channel
set_name	mods/player.cpp	/^	void player::set_name(std::string n){$/;"	f	class:mods::player
set_node	mods/behaviour_tree.hpp	/^		void set_node(const node & btree_node){$/;"	f	struct:mods::behaviour_tree
set_node_type	mods/behaviour_tree_node.hpp	/^		void set_node_type(const node_type_t & n){ $/;"	f	struct:mods::behaviour_tree_node
set_obj_from_room	mods/world-configuration.cpp	/^		void set_obj_from_room(bool b){ mods::world_conf::toggle::status_obj_from_room = b; }$/;"	f	namespace:mods::world_conf::toggle
set_overhead_map_height	mods/player.hpp	/^		void set_overhead_map_height(uint8_t h){ m_overhead_map_height = h; }$/;"	f	struct:mods::player
set_overhead_map_width	mods/player.hpp	/^		void set_overhead_map_width(uint8_t w){ m_overhead_map_width = w; }$/;"	f	struct:mods::player
set_owner	structs.h	/^		void set_owner(uuid_t p){ m_owner = p; }$/;"	f	struct:obj_data
set_password	mods/auto-login.cpp	/^	void set_password(std::string_view pass){$/;"	f	namespace:mods::auto_login
set_password	mods/player.cpp	/^	void player::set_password(std::string pw){$/;"	f	class:mods::player
set_players	mods/player-scaffolding.cpp	/^	int player_scaffolding::set_players(player_ptr_t ch,$/;"	f	class:mods::player_scaffolding
set_players	mods/player-scaffolding.cpp	/^	int player_scaffolding::set_players(std::string_view main_player,$/;"	f	class:mods::player_scaffolding
set_players	mods/player-scaffolding.cpp	/^	std::vector<player_ptr_t>& player_scaffolding::set_players(std::string_view main_player,$/;"	f	class:mods::player_scaffolding
set_pluck_filter	mods/lmdb.cpp	/^	void _db_handle::set_pluck_filter(const std::vector<std::string> & cols){$/;"	f	class:mods::lmdb::_db_handle
set_points	mods/js.cpp	/^		static duk_ret_t set_points(duk_context *ctx) {$/;"	f	namespace:mods::js
set_prefs	mods/player.hpp	/^		void set_prefs(long prefs){ cd()->player_specials->saved.pref = prefs; }$/;"	f	struct:mods::player
set_private	mods/chat.hpp	/^			void set_private(bool b_private) {$/;"	f	struct:mods::mods::chat::channel
set_room	mods/player.hpp	/^		void set_room(room_rnum r){$/;"	f	struct:mods::player
set_sector_type	mods/rooms.cpp	/^	void set_sector_type(room_rnum room_id, int sector_type){$/;"	f	namespace:mods::rooms
set_sendbuf	comm.cpp	/^int set_sendbuf(socket_t s) {$/;"	f
set_sentinel	mods/player.hpp	/^		void set_sentinel(std::shared_ptr<mods::classes::sentinel> s){$/;"	f	struct:mods::player
set_sex	mods/player.hpp	/^		void set_sex(byte s){$/;"	f	struct:mods::player
set_shared_ptr	mods/object.cpp	/^	object& object::set_shared_ptr(std::shared_ptr<obj_data>& ptr){$/;"	f	class:mods::object
set_shared_ptr	mods/player.cpp	/^	void player::set_shared_ptr(player_ptr_t& self_ptr) {$/;"	f	class:mods::player
set_skill	mods/player.cpp	/^		void player::set_skill(int skill,uint16_t proficiency){$/;"	f	class:mods::player
set_socket	mods/player.cpp	/^	void player::set_socket(socket_t d){$/;"	f	class:mods::player
set_state	mods/player.cpp	/^	void player::set_state(int state){$/;"	f	class:mods::player
set_str_table	mods/lmdb.hpp	/^		void set_str_table(table_type_t e_table){$/;"	f	struct:mods::lmdb::transaction_t
set_struct	act.wizard.cpp	/^struct set_struct {$/;"	s	file:
set_time_birth	mods/player.cpp	/^	void player::set_time_birth(time_t b){$/;"	f	class:mods::player
set_time_logon	mods/player.cpp	/^	void player::set_time_logon(time_t t){$/;"	f	class:mods::player
set_time_played	mods/player.cpp	/^	void player::set_time_played(int t){$/;"	f	class:mods::player
set_title	limits.cpp	/^void set_title(char_data* ch, const char* title) {$/;"	f
set_title	limits.cpp	/^void set_title(player_ptr_t player, const char* title) {$/;"	f
set_title	mods/player.hpp	/^		void set_title(const std::string& t){$/;"	f	struct:mods::player
set_type	mods/player.cpp	/^	void player::set_type(player_type_enum_t type){$/;"	f	class:mods::player
set_user	mods/auto-login.cpp	/^	void set_user(std::string_view user){$/;"	f	namespace:mods::auto_login
set_value	mods/world-configuration.cpp	/^	std::pair<bool,std::string> set_value(std::string_view column, room_vnum room_id){$/;"	f	namespace:mods::world_conf
set_verb	mods/chat.cpp	/^	void channel::set_verb(std::string_view verb) {$/;"	f	class:mods::chat::channel
set_yaml_initiator	mods/object-utils.hpp	/^	static inline void set_yaml_initiator($/;"	f	namespace:mods::object_utils
set_yaml_transaction_id	mods/object-utils.hpp	/^	static inline void set_yaml_transaction_id(uint32_t i){$/;"	f	namespace:mods::object_utils
setup_log	comm.cpp	/^void setup_log(const char *filename, int fd) {$/;"	f
sex	mods/player.hpp	/^		byte& sex(){$/;"	f	struct:mods::player
sex_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,3> sex_flags = { {$/;"	m	namespace:mods::builder	file:
shop	mods/shop.cpp	/^namespace mods::shop {$/;"	n	class:mods	file:
shop	mods/shop.hpp	/^namespace mods::shop  {$/;"	n	class:mods
shop_bits	shop.cpp	/^const char *shop_bits[] = {$/;"	v
shop_buy_data	shop.h	/^struct shop_buy_data {$/;"	s
shop_data	shop.cpp	/^shop_data<mods::orm::shop,mods::orm::shop_rooms,mods::orm::shop_objects>::shop_data(){$/;"	f	class:shop_data
shop_data	shop.h	/^struct shop_data {$/;"	s
shop_keeper	act.other.cpp	/^SPECIAL(shop_keeper);$/;"	v
shop_keeper	shop.cpp	/^SPECIAL(shop_keeper);$/;"	v
shop_list	db.cpp	/^std::deque<std::shared_ptr<shop_data_t>> shop_list;$/;"	v
shop_producing	shop.cpp	/^int shop_producing(struct obj_data *item, int shop_nr) {$/;"	f
shop_proto	db.cpp	/^std::vector<shop_data_t> shop_proto;	\/* prototypes for objs		 *\/$/;"	v
shop_rnum	structs.h	/^	typedef IDXTYPE shop_rnum;$/;"	t
shop_type	shop.h	/^	int shop_type;$/;"	m	struct:shop_data
shop_view_item	shop.cpp	/^void shop_view_item(player_ptr_t& player, int16_t item_number){$/;"	f
shop_vnum	structs.h	/^	typedef IDXTYPE shop_vnum;$/;"	t
shopping_buy	shop.cpp	/^void shopping_buy(char *arg, char_data *ch, char_data *keeper, int shop_nr) {$/;"	f
shopping_list	shop.cpp	/^void shopping_list(char *arg, char_data *ch, char_data *keeper, int shop_nr) {$/;"	f
shopping_sell	shop.cpp	/^void shopping_sell(char *arg, char_data *ch, char_data *keeper, int shop_nr) {$/;"	f
shopping_value	shop.cpp	/^void shopping_value(char *arg, char_data *ch, char_data *keeper, int shop_nr) {$/;"	f
short_descr	mods/player.hpp	/^		mods::string& short_descr(){$/;"	f	struct:mods::player
short_description	structs.h	/^		mods::string short_description;       \/* when worn\/carry\/in cont.         *\/$/;"	m	struct:obj_data
shouldContinueOnFailure	mods/catch.hpp	/^	inline bool shouldContinueOnFailure(int flags)    {$/;"	f	namespace:Catch
shouldSuppressFailure	mods/catch.hpp	/^	inline bool shouldSuppressFailure(int flags)      {$/;"	f	namespace:Catch
should_continue	mods/help.cpp	/^	bool should_continue(std::string_view from,std::string_view argument, std::shared_ptr<mods::player>& player){$/;"	f	namespace:mods::help
show_finalized_chargen_screen	mods/chargen.cpp	/^	void show_finalized_chargen_screen(player_ptr_t p){$/;"	f	namespace:mods::chargen
show_item	mods/shop.hpp	/^	static inline void show_item(player_ptr_t& player,TShopMap& shop_map, int16_t item_number){$/;"	f	namespace:mods::shop
show_nonconst_vector	mods/builder_util.hpp	/^	void show_nonconst_vector($/;"	f	namespace:mods::builder_util
show_obj_modifiers	act.informative.cpp	/^void show_obj_modifiers(struct obj_data *obj, char_data *ch) {$/;"	f
show_obj_to_char	act.informative.cpp	/^void show_obj_to_char(struct obj_data *obj, char_data *ch, int mode) {$/;"	f
show_object_vector	mods/builder_util.hpp	/^	void show_object_vector($/;"	f	namespace:mods::builder_util
show_shops	shop.cpp	/^void show_shops(char_data *ch, char *arg) {$/;"	f
show_string	modify.cpp	/^void show_string(mods::descriptor_data d, char *input) {$/;"	f
show_tics	mods/debug.cpp	/^	bool state::show_tics() { return m_show_tics; }$/;"	f	class:mods::debug::state
show_tics	mods/debug.cpp	/^	void state::show_tics(bool b){ m_show_tics = b; }$/;"	f	class:mods::debug::state
shptr	mods/loops.hpp	/^	namespace shptr {$/;"	n	namespace:mods::loops
shutdown	globals.cpp	/^		void shutdown(void){$/;"	f	namespace:mods::globals
siderail_t	mods/weapon.hpp	/^	enum siderail_t {$/;"	g	namespace:mods::weapon
sigfunc	comm.h	/^typedef RETSIGTYPE sigfunc(int);$/;"	t
signal_setup	comm.cpp	/^void signal_setup(void) {$/;"	f
simulate	mods/drone.cpp	/^	 void drone::simulate(char_data* owner,bool value) {$/;"	f	class:mods::drone
singular	spells.h	/^	const char	*singular;$/;"	m	struct:attack_hit_type
site	db.h	/^	char	site[BANNED_SITE_LENGTH+1];$/;"	m	struct:ban_list_element
siteok_everyone	config.cpp	/^int siteok_everyone = TRUE;$/;"	v
sizer	mods/catch.hpp	/^			char sizer[1];$/;"	m	struct:Catch::Detail::TrueType
sizer	mods/catch.hpp	/^			char sizer[2];$/;"	m	struct:Catch::Detail::FalseType
skill	mods/player.cpp	/^		uint16_t player::skill(int t){$/;"	f	class:mods::player
skill_message	fight.cpp	/^int skill_message(int dam, char_data *ch, char_data *vict,$/;"	f
skill_name	spell_parser.cpp	/^const char *skill_name(int num) {$/;"	f
skill_name_list	mods/skills.cpp	/^	static std::vector<std::string> skill_name_list;$/;"	m	namespace:mods::skills	file:
skillo	spell_parser.cpp	831;"	d	file:
skills	db.cpp	/^namespace mods::skills {$/;"	n	class:mods	file:
skills	globals.cpp	/^namespace mods::skills {$/;"	n	class:mods	file:
skills	globals.hpp	/^namespace mods::skills {$/;"	n	class:mods
skills	mods/skills.cpp	/^namespace mods::skills {$/;"	n	class:mods	file:
skills	mods/skills.hpp	/^namespace mods::skills {$/;"	n	class:mods
skip_spaces	interpreter.cpp	/^void skip_spaces(char **string) {$/;"	f
slc_names	telnet.h	/^char *slc_names[] = {$/;"	v
slide_obj	shop.cpp	/^struct obj_data *slide_obj(struct obj_data *obj, char_data *keeper,$/;"	f
slot_num	boards.h	/^	int	slot_num;     \/* pos of message in "master index" *\/$/;"	m	struct:board_msginfo
smash_tilde	modify.cpp	/^void smash_tilde(char *str) {$/;"	f
smoke_room	mods/projectile.cpp	/^		void smoke_room(room_rnum room){$/;"	f	namespace:mods::projectile
snake	spec_assign.cpp	/^SPECIAL(snake);$/;"	v
snake	spec_procs.cpp	/^SPECIAL(snake);$/;"	v
snipe	mods/weapon.hpp	/^		static constexpr uint64_t snipe = (1 << 0);$/;"	m	struct:mods::weapon::mask
snipe_tracking	mods/behaviour_tree_impl.hpp	/^			snipe_tracking = 1,$/;"	e	enum:mods::behaviour_tree_impl::type
sniper_rifle	mods/player.cpp	/^	obj_data_ptr_t player::sniper_rifle(){$/;"	f	class:mods::player
sniper_skillset	class.cpp	/^std::string sniper_skillset() {$/;"	f
sniping	mods/skills.hpp	/^		static std::vector<proficiency_t> sniping = {$/;"	m	namespace:mods::skills::proficiencies
snoop_check	act.wizard.cpp	/^void snoop_check(char_data *ch) {$/;"	f
snprintf	bsd-snprintf.cpp	/^snprintf(char *str,size_t count,const char *fmt,...) {$/;"	f
snprintf	sysdep.h	350;"	d
soc_mess_list	act.social.cpp	/^} *soc_mess_list;$/;"	v	typeref:struct:social_messg
social_messg	act.social.cpp	/^struct social_messg {$/;"	s	file:
socket	mods/player.cpp	/^	socket_t player::socket(){$/;"	f	class:mods::player
socket_map	globals.cpp	/^		socket_map_t socket_map;$/;"	m	namespace:mods::globals	file:
socket_t	mods/ban_system.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/builder.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/chat.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/conf.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/immortal.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/js.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/pq.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/projectile.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/quests.hpp	/^typedef int socket_t;$/;"	t
socket_t	mods/scan.hpp	/^typedef int socket_t;$/;"	t
socket_t	sysdep.h	/^typedef SOCKET		socket_t;$/;"	t
solo_gain	fight.cpp	/^void solo_gain(char_data *ch, char_data *victim) {$/;"	f
sort_commands	act.informative.cpp	/^void sort_commands(void) {$/;"	f
sort_commands	mods/hell.hpp	/^	constexpr inline bool sort_commands = false;$/;"	m	namespace:mods::hell
sort_commands_helper	act.informative.cpp	/^int sort_commands_helper(const void *a, const void *b) {$/;"	f
sort_keeper_objs	shop.cpp	/^void sort_keeper_objs(char_data *keeper, int shop_nr) {$/;"	f
sort_spells	mods/hell.hpp	/^	constexpr inline bool sort_spells = false;$/;"	m	namespace:mods::hell
sort_spells	spec_procs.cpp	/^void sort_spells(void) {$/;"	f
spare0	house.h	/^	long spare0;$/;"	m	struct:house_control_rec
spare0	structs.h	/^		int	spare0;$/;"	m	struct:rent_info
spare1	house.h	/^	long spare1;$/;"	m	struct:house_control_rec
spare1	structs.h	/^		int	spare1;$/;"	m	struct:rent_info
spare2	house.h	/^	long spare2;$/;"	m	struct:house_control_rec
spare2	structs.h	/^		int	spare2;$/;"	m	struct:rent_info
spare3	house.h	/^	long spare3;$/;"	m	struct:house_control_rec
spare3	structs.h	/^		int	spare3;$/;"	m	struct:rent_info
spare4	house.h	/^	long spare4;$/;"	m	struct:house_control_rec
spare4	structs.h	/^		int	spare4;$/;"	m	struct:rent_info
spare5	house.h	/^	long spare5;$/;"	m	struct:house_control_rec
spare5	structs.h	/^		int	spare5;$/;"	m	struct:rent_info
spare6	house.h	/^	long spare6;$/;"	m	struct:house_control_rec
spare6	structs.h	/^		int	spare6;$/;"	m	struct:rent_info
spare7	house.h	/^	long spare7;$/;"	m	struct:house_control_rec
spare7	structs.h	/^		int	spare7;$/;"	m	struct:rent_info
special	interpreter.cpp	/^int special(char_data *ch, int cmd, char *arg) {$/;"	f
spell_charm	spells.h	/^ASPELL(spell_charm);$/;"	v
spell_create_water	spells.h	/^ASPELL(spell_create_water);$/;"	v
spell_detect_poison	spells.h	/^ASPELL(spell_detect_poison);$/;"	v
spell_enchant_weapon	spells.h	/^ASPELL(spell_enchant_weapon);$/;"	v
spell_identify	spells.h	/^ASPELL(spell_identify);$/;"	v
spell_info	spell_parser.cpp	/^struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];$/;"	v	typeref:struct:spell_info_type
spell_info_type	spells.h	/^struct spell_info_type {$/;"	s
spell_information	spells.h	/^ASPELL(spell_information);$/;"	v
spell_level	spell_parser.cpp	/^void spell_level(int spell, int chclass, int level) {$/;"	f
spell_locate_object	spells.h	/^ASPELL(spell_locate_object);$/;"	v
spell_recall	spells.h	/^ASPELL(spell_recall);$/;"	v
spell_sort_info	spec_procs.cpp	/^int spell_sort_info[MAX_SKILLS + 1];$/;"	v
spell_summon	spells.h	/^ASPELL(spell_summon);$/;"	v
spell_teleport	spells.h	/^ASPELL(spell_teleport);$/;"	v
spello	spell_parser.cpp	/^void spello(int spl, const char *name, int max_mana, int min_mana,$/;"	f
split	mods/util-conf.hpp	/^			std::vector<std::string> split(const std::string& in_string,const std::string& delimiter,unsigned int limit = 1024) {$/;"	f	namespace:mods::util::text
sprintbit	utils.cpp	/^size_t sprintbit(bitvector_t bitvector, const char *names[], char *result, size_t reslen) {$/;"	f
sprinttype	utils.cpp	/^size_t sprinttype(int type, const char *names[], char *result, size_t reslen) {$/;"	f
sql	mods/sql.hpp	/^			str_object sql() {$/;"	f	struct:mods::sql::compositor
sql	mods/sql.hpp	/^namespace mods::sql {$/;"	n	class:mods
sql_compositor	mods/builder_util.hpp	/^typedef mods::sql::compositor<mods::pq::transaction> sql_compositor;$/;"	t
stack_data	shop.h	/^struct stack_data {$/;"	s
start	mods/drone.cpp	/^	 void drone::start(char_data* owner) {$/;"	f	class:mods::drone
start_fire_dissolver	mods/rooms.cpp	/^	void start_fire_dissolver(room_rnum room) {$/;"	f	namespace:mods::rooms
start_histfile	mods/player.cpp	/^	void player::start_histfile(){$/;"	f	class:mods::player
start_quest	mods/quests.cpp	/^		void start_quest(char_data* ch,int quest_id) {$/;"	f	namespace:mods::quests
started	mods/drone.cpp	/^	 bool drone::started(char_data* owner) {$/;"	f	class:mods::drone
state	mods/ai_state.hpp	/^			enum state {$/;"	g	class:mods::ai_state
state	mods/debug.cpp	/^	state::state(bool _show_tics) : m_show_tics(_show_tics) {$/;"	f	class:mods::debug::state
state	mods/debug.hpp	/^	struct state {$/;"	s	namespace:mods::debug
state	mods/player.cpp	/^	int player::state(){$/;"	f	class:mods::player
state_fetch	globals.cpp	/^		std::unique_ptr<ai_state>& state_fetch(char_data* ch) {$/;"	f	namespace:mods::globals
states	globals.cpp	/^		ai_state_map states;$/;"	m	namespace:mods::globals	file:
status	mods/behaviour_tree_node.hpp	/^			behaviour_tree_status status;\\$/;"	m	struct:mods::behaviour_tree_node::__anon2
status_obj_from_room	mods/world-configuration.cpp	/^		bool status_obj_from_room;$/;"	m	namespace:mods::world_conf::toggle	file:
status_step_count	mods/lmdb.hpp	/^		constexpr static std::size_t status_step_count = 5;$/;"	m	struct:mods::lmdb::_db_handle
stc	mods/drone.hpp	/^			void stc(const char* m) {$/;"	f	class:mods::drone
stc	mods/drone.hpp	/^			void stc(const std::string m) {$/;"	f	class:mods::drone
stc	mods/drone.hpp	/^			void stc(int m) {$/;"	f	class:mods::drone
stc	mods/player.cpp	/^	void player::stc(const char* m) {$/;"	f	class:mods::player
stc	mods/player.cpp	/^	void player::stc(const mods::string& m){$/;"	f	class:mods::player
stc	mods/player.cpp	/^	void player::stc(const std::string m) {$/;"	f	class:mods::player
stc	mods/player.cpp	/^	void player::stc(int m) {$/;"	f	class:mods::player
stc	mods/player.cpp	/^	void player::stc(std::string_view sview) {$/;"	f	class:mods::player
stc_room	mods/player.cpp	/^	void player::stc_room(const room_rnum& rnum) {$/;"	f	class:mods::player
stc_room_desc	mods/player.cpp	/^	void player::stc_room_desc(const room_rnum& rnum) {$/;"	f	class:mods::player
stfu	mods/util-conf.hpp	/^			static bool stfu = true;$/;"	m	namespace:mods::util::conf
stoi	mods/util.cpp	/^		std::optional<int> stoi(std::string_view str) {$/;"	f	namespace:mods::util
stoi	mods/util.hpp	/^		T stoi(const pqxx::result::reference & i){$/;"	f	namespace:mods::util
stoi	mods/util.hpp	/^		T stoi(const std::string& i){$/;"	f	namespace:mods::util
stoi_optional	mods/util.hpp	/^		std::optional<T> stoi_optional(std::string_view str){$/;"	f	namespace:mods::util
stop	mods/drone.cpp	/^	 void drone::stop(char_data* owner) {$/;"	f	class:mods::drone
stop_fighting	fight.cpp	/^void stop_fighting(char_data *ch) {$/;"	f
stop_fire_dissolver	mods/rooms.hpp	/^	static inline void stop_fire_dissolver(room_rnum room) {$/;"	f	namespace:mods::rooms
stop_follower	utils.cpp	/^void stop_follower(char_data *ch) {$/;"	f
stop_histfile	mods/player.cpp	/^	void player::stop_histfile(){$/;"	f	class:mods::player
stop_snooping	act.wizard.cpp	/^void stop_snooping(char_data *ch) {$/;"	f
store_mail	mail.cpp	/^void store_mail(long to, long from, char *message_pointer) {$/;"	f
store_to_char	db.cpp	/^void store_to_char(struct char_file_u *st, char_data *ch) {$/;"	f
stoul	mods/util.cpp	/^		std::optional<unsigned> stoul(std::string_view str) {$/;"	f	namespace:mods::util
str	mods/string.cpp	/^	std::string string::str() const {$/;"	f	class:mods::string
str_affect_player	mods/affects.cpp	/^	void str_affect_player(std::vector<std::string> a,player_ptr_t p){$/;"	f	namespace:mods::affects
str_app	constants.cpp	/^cpp_extern const struct str_app_type str_app[] = {$/;"	v	typeref:struct:str_app_type
str_app	constants.hpp	/^cpp_extern const struct str_app_type str_app[] = {$/;"	v	typeref:struct:str_app_type
str_cmp	sysdep.h	326;"	d
str_cmp	utils.cpp	/^int str_cmp(const char *arg1, const char *arg2) {$/;"	f
str_escape	mods/jx.hpp	/^			std::string str_escape(const std::string& value) {$/;"	f	struct:mods::jx::compositor
str_object	mods/sql.hpp	/^typedef std::string str_object;$/;"	t
str_object	mods/sql.hpp	/^typedef std::string_view str_object;$/;"	t
str_or	mods/string.cpp	/^	std::string string::str_or(std::string f) const {$/;"	f	class:mods::string
str_queue_on_player	mods/affects.cpp	/^void str_queue_on_player(std::vector<std::string> affects,player_ptr_t player){$/;"	f
str_queue_on_room	mods/affects.cpp	/^void str_queue_on_room(std::vector<std::string> affects,int room_id){$/;"	f
str_sub_type	structs.h	/^		std::string str_sub_type;	\/\/i.e.: SENSOR_GRENADE$/;"	m	struct:obj_data
str_type	structs.h	/^		std::string str_type;	\/\/i.e.: explosive$/;"	m	struct:obj_data
strategy	mods/skills.hpp	/^		static std::vector<proficiency_t> strategy = {$/;"	m	namespace:mods::skills::proficiencies
strdup	utils.cpp	/^char *strdup(const char *source) {$/;"	f
string	mods/string.cpp	/^	string::string(){$/;"	f	class:mods::string
string	mods/string.cpp	/^	string::string(const char* str){$/;"	f	class:mods::string
string	mods/string.cpp	/^	string::string(const string& str){$/;"	f	class:mods::string
string	mods/string.cpp	/^	string::string(mentoc_pqxx_result_t str) {$/;"	f	class:mods::string
string	mods/string.cpp	/^	string::string(mentoc_pqxx_result_t::reference other) {$/;"	f	class:mods::string
string	mods/string.hpp	/^	struct string {$/;"	s	namespace:mods
string_add	modify.cpp	/^void string_add(mods::descriptor_data d, char *str) {$/;"	f
string_fields	modify.cpp	/^const char *string_fields[] = {$/;"	v
string_map	mods/affects.hpp	/^	const static std::map<std::string,affect_t> string_map = {$/;"	m	namespace:mods::affects
string_types	mods/values.cpp	/^			static const std::vector<std::string> string_types = {$/;"	m	namespace:mods::values	file:
string_write	modify.cpp	/^void string_write(mods::descriptor_data d, char **writeto, size_t len, long mailto, void *data) {$/;"	f
strlcpy	utils.cpp	/^size_t strlcpy(char *dest, const char *source, size_t totalsize) {$/;"	f
strn_cmp	sysdep.h	333;"	d
strn_cmp	utils.cpp	/^int strn_cmp(const char *arg1, const char *arg2, int n) {$/;"	f
subcmd	interpreter.h	/^	int	subcmd;$/;"	m	struct:command_info
subcmd_args	mods/util.hpp	/^		inline std::optional<Container> subcmd_args(std::string argument,const char* subcmd) {$/;"	f	namespace:mods::util
success	mods/db.hpp	/^	constexpr static int_status_t success = 0;$/;"	m	namespace:mods::lmdb::error
super_users	globals.cpp	/^		const std::vector<std::string> super_users = {$/;"	m	namespace:mods::globals	file:
suspicious_roaming	mods/behaviour_tree_impl.hpp	/^			suspicious_roaming,$/;"	e	enum:mods::behaviour_tree_impl::type
svtostr	globals.hpp	75;"	d
swap	mods/catch.hpp	/^			void swap(Ptr& other) {$/;"	f	class:Catch::Ptr
syllable	spell_parser.cpp	/^struct syllable {$/;"	s	file:
syls	spell_parser.cpp	/^struct syllable syls[] = {$/;"	v	typeref:struct:syllable
t	mods/catch.hpp	/^			static T  const& t;$/;"	m	struct:Catch::Detail::IsStreamInsertable
table	mods/lmdb.hpp	/^		table_type_t table() const { return m_table; }$/;"	f	struct:mods::lmdb::transaction_t
table	mods/lmdb.hpp	/^		table_type_t table;$/;"	m	struct:mods::lmdb::_selector
table	mods/sql.hpp	/^			compositor<T>& table(str_object table) {$/;"	f	struct:mods::sql::compositor
table_cstr	mods/lmdb.hpp	/^		std::string table_cstr() const { return m_str_table; }$/;"	f	struct:mods::lmdb::transaction_t
tail	db.h	/^	struct reset_q_element *tail;$/;"	m	struct:reset_q_type	typeref:struct:reset_q_type::reset_q_element
target_dead	mods/values.hpp	/^			static inline void target_dead(T& p){$/;"	f	namespace:mods::values::msg
targets	spells.h	/^	int targets;         \/* See below for use with TAR_XXX  *\/$/;"	m	struct:spell_info_type
telcmds	telnet.h	/^char *telcmds[] = {$/;"	v
telopts	telnet.h	/^char *telopts[NTELOPTS+1] = {$/;"	v
temper1	shop.h	/^	int	 temper1;		\/* How does keeper react if no money	*\/$/;"	m	struct:shop_data
test	mods/js.cpp	/^		namespace test {$/;"	n	namespace:mods::js	file:
text	mods/util-conf.hpp	/^		namespace text {$/;"	n	namespace:mods::util
text_overflow	comm.cpp	/^const char *text_overflow = "**OVERFLOW**\\r\\n";$/;"	v
texture_from_string	mods/rooms.hpp	/^	static inline std::optional<txt> texture_from_string(std::string& s){$/;"	f	namespace:mods::rooms
texture_level	structs.h	/^		texture_level_t& texture_level(texture_type_t type){$/;"	f
texture_strings	mods/rooms.hpp	/^	static std::map<txt,std::string> texture_strings = {$/;"	m	namespace:mods::rooms
texture_to_string	mods/rooms.hpp	/^	static inline std::optional<std::string> texture_to_string(txt t){$/;"	f	namespace:mods::rooms
textures	structs.cpp	/^		std::set<room_data::texture_type_t>& room_data::textures() { $/;"	f	class:room_data
textures_that_have_levels	structs.h	/^		constexpr static std::array<texture_type_t,5> textures_that_have_levels = {$/;"	v
texturize_room	mods/deferred.hpp	/^			void texturize_room(uint64_t ticks_in_future,room_rnum& room_id,TTextureList& textures){$/;"	f	class:mods::deferred
texturize_room	mods/util.hpp	/^	static inline void texturize_room(room_rnum room_id, room_data::texture_type_t texture_type){$/;"	f	namespace:mods::util
thaco	class.cpp	/^int thaco(int class_num, int level) {$/;"	f
thermite_breached	mods/doors.hpp	/^	static inline void thermite_breached(const room_rnum room,int direction){$/;"	f	namespace:mods::doors
thief	spec_assign.cpp	/^SPECIAL(thief);$/;"	v
thief	spec_procs.cpp	/^SPECIAL(thief);$/;"	v
three_arguments	interpreter.cpp	/^char* three_arguments(char* argument,char *first_arg,char* second_arg,char* third_arg) {$/;"	f
throw_object	mods/projectile.cpp	/^		void throw_object(player_ptr_t& player, int direction, std::size_t depth,$/;"	f	namespace:mods::projectile
tick	mods/affects.hpp	/^			std::size_t tick(){$/;"	f	struct:mods::affects::dissolver
tick	mods/deferred.cpp	/^	void deferred::tick() {$/;"	f	class:mods::deferred
ticks_per_minute	mods/affects.cpp	/^	static uint32_t ticks_per_minute = 0;$/;"	m	namespace:mods::affects	file:
ticks_per_minute_sample	mods/affects.cpp	/^	static uint32_t ticks_per_minute_sample = 0;$/;"	m	namespace:mods::affects	file:
tics	comm.cpp	/^uint64_t tics = 0;			\/* for extern checkpointing *\/$/;"	v
tim	castle.cpp	/^SPECIAL(tim);$/;"	v
time	mods/object-utils.hpp	/^		time_t time;$/;"	m	struct:mods::object_utils::YamlFeedExceptionInfo
time	mods/player.cpp	/^	player::time_type_t player::time() const {$/;"	f	class:mods::player
time	structs.h	/^		int	time;$/;"	m	struct:rent_info
time_info	db.cpp	/^struct time_info_data time_info;\/* the infomation about the time    *\/$/;"	v	typeref:struct:time_info_data
time_log_file_handle	mods/date-time.cpp	/^	static FILE* time_log_file_handle = nullptr;$/;"	m	namespace:mods::date_time	file:
time_tracker_per_minute	mods/affects.cpp	/^	static time_t time_tracker_per_minute = time(nullptr);$/;"	m	namespace:mods::affects	file:
timeadd	comm.cpp	/^void timeadd(struct timeval *rslt, struct timeval *a, struct timeval *b) {$/;"	f
timediff	comm.cpp	/^void timediff(struct timeval *rslt, struct timeval *a, struct timeval *b) {$/;"	f
timelog	mods/date-time.cpp	/^	void timelog(const std::string& msg) {$/;"	f	namespace:mods::date_time
timer	mods/player.hpp	/^		int&	timer(){$/;"	f	struct:mods::player
timer	structs.h	/^		int	timer;		\/* Timer for object                 *\/$/;"	m	struct:obj_flag_data
timer	structs.h	/^		int	timer;$/;"	m	struct:obj_file_elem
times_message	shop.cpp	/^char *times_message(struct obj_data *obj, char *name, int num) {$/;"	f
title	mods/builder.cpp	/^	bool title(room_rnum room_id,std::string_view str_title) {$/;"	f	namespace:mods::builder
title	mods/player.hpp	/^		mods::string& title(){$/;"	f	struct:mods::player
title	shop.h	/^	mods::string title;$/;"	m	struct:shop_data
title_female	class.cpp	/^const char *title_female(int chclass, int level) {$/;"	f
title_male	class.cpp	/^const char *title_male(int chclass, int level) {$/;"	f
to	mail.h	/^	long to;			\/* idnum of mail's recipient		*\/$/;"	m	struct:header_data_type
toString	mods/catch.hpp	/^					std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::MatcherUntypedBase
toString	mods/catch.hpp	/^	std::string toString(std::vector<T,Allocator> const& v) {$/;"	f	namespace:Catch
to_affect	mods/affects.cpp	/^	affect_t to_affect(std::string str){$/;"	f	namespace:mods::affects
to_affect	mods/affects.cpp	/^	mods::affects::affect_vector_t to_affect(std::vector<std::string> strings) {$/;"	f	namespace:mods::affects
to_direction	mods/projectile.cpp	/^		int to_direction(const std::string & str){$/;"	f	namespace:mods::projectile
to_direction	mods/util.hpp	/^		int to_direction(TStringObject str){$/;"	f	namespace:mods::util
to_dirstr	mods/doors.hpp	/^	static inline std::string to_dirstr(const int& direction){$/;"	f	namespace:mods::doors
to_durability_profile	mods/yaml.hpp	/^static inline durability_profile_type_t to_durability_profile(std::string_view dp){$/;"	f	namespace:mods::yaml
to_hex_digit	mods/util-conf.hpp	/^			char to_hex_digit(unsigned int target) {$/;"	f	namespace:mods::util::conf
to_room	structs.h	/^		room_rnum to_room;		\/* Where direction leads (NOWHERE)	*\/$/;"	m	struct:room_direction_data
to_string	mods/aoe.hpp	/^	static inline std::string to_string(const types_t& type) {$/;"	f	namespace:mods::aoe
to_string	mods/object-utils.hpp	/^		std::string to_string() {$/;"	f	struct:mods::object_utils::YamlFeedExceptionInfo
to_string	mods/rooms.hpp	/^	static inline std::string to_string(room_data::fire_status_t stat){$/;"	f	namespace:mods::rooms
to_string	mods/skills.cpp	/^	std::string to_string(int e_name){$/;"	f	namespace:mods::skills
to_string	mods/weapon.hpp	/^		static inline std::string_view to_string(primary_choice_t s){$/;"	f	namespace:mods::weapon::sentinel
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_armor_t armor_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_attachment_t attachment_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_consumable_t consumable_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_drone_t drone_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_explosive_t explosive_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_gadget_t gadget_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_rifle_t rifle_type){$/;"	f	namespace:mods::weapon
to_string	mods/weapon.hpp	/^	static inline std::string to_string(weapon_trap_t trap_type){$/;"	f	namespace:mods::weapon
to_string_from_durability_profile	mods/yaml.hpp	/^static inline std::string to_string_from_durability_profile(durability_profile_type_t dp){$/;"	f	namespace:mods::yaml
to_string_mappings	mods/skills.cpp	/^	static std::map<int,std::string> to_string_mappings;$/;"	m	namespace:mods::skills	file:
todirstr	mods/projectile.cpp	/^		std::string todirstr(int direction,bool prefix,bool suffix) {$/;"	f	namespace:mods::projectile
toggle	mods/world-configuration.cpp	/^	namespace toggle {$/;"	n	namespace:mods::world_conf	file:
toggle	mods/world-configuration.hpp	/^	namespace toggle {$/;"	n	namespace:mods::world_conf
toggle_flag	mods/player.hpp	/^		aligned_int_t toggle_flag(chunk_type_t chunk,aligned_int_t bit){$/;"	f	struct:mods::player
tohex	mods/util-conf.hpp	/^			std::string tohex(char c) {$/;"	f	namespace:mods::util::conf
tom	castle.cpp	/^SPECIAL(tom);$/;"	v
top	db.h	/^	uint64_t top;           \/* upper limit for rooms in this zone *\/$/;"	m	struct:zone_data
top	shop.cpp	/^int top(struct stack_data *stack) {$/;"	f
top_idnum	db.cpp	/^long top_idnum = 0;		\/* highest idnum in use		 *\/$/;"	v
top_of_helpt	db.cpp	/^int top_of_helpt = 0;		\/* top of help index table	 *\/$/;"	v
top_of_mobt	db.cpp	/^mob_rnum top_of_mobt = 0;	\/* top of mobile index table	 *\/$/;"	v
top_of_objt	db.cpp	/^obj_rnum top_of_objt = 0;	\/* top of object index table	 *\/$/;"	v
top_of_p_table	db.cpp	/^int top_of_p_table = 0;		\/* ref to top of table		 *\/$/;"	v
top_of_world	db.cpp	/^room_rnum top_of_world = 0;	\/* ref to top element of world	 *\/$/;"	v
top_of_zone_table	db.cpp	/^zone_rnum top_of_zone_table = 0;\/* top element of zone tab	 *\/$/;"	v
top_shop	shop.cpp	/^int top_shop = -1;$/;"	v
tostr	globals.hpp	74;"	d
tostr	mods/yaml.cpp	7;"	d	file:
touch	utils.cpp	/^int touch(const char *path) {$/;"	f
track_through_doors	config.cpp	/^int track_through_doors = YES;$/;"	v
trade_letters	shop.cpp	/^const char *trade_letters[] = {$/;"	v
trade_with	shop.cpp	/^int trade_with(struct obj_data *item, int shop_nr) {$/;"	f
training_master	castle.cpp	/^SPECIAL(training_master);$/;"	v
transact_type_t	mods/lmdb.hpp	/^	enum transact_type_t {$/;"	g	namespace:mods::lmdb
transaction_amt	shop.cpp	/^int transaction_amt(char *arg) {$/;"	f
transaction_id	mods/object-utils.hpp	/^		uint32_t transaction_id;$/;"	m	struct:mods::object_utils::YamlFeedExceptionInfo
transaction_t	mods/lmdb.cpp	/^	transaction_t::transaction_t(std::string ce_table,transact_type_t type) : m_type(type){$/;"	f	class:mods::lmdb::transaction_t
transaction_t	mods/lmdb.cpp	/^	transaction_t::transaction_t(table_type_t e_table,transact_type_t type) : m_table(e_table), m_type(type){$/;"	f	class:mods::lmdb::transaction_t
transaction_t	mods/lmdb.hpp	/^	struct transaction_t {$/;"	s	namespace:mods::lmdb
transmit	mods/chat.cpp	/^	void channel::transmit(std::string_view user,std::string_view message) {$/;"	f	class:mods::chat::channel
trap	mods/item-types.hpp	/^	enum trap {$/;"	g	namespace:mods::weapon::type
trap_description_t	mods/yaml.hpp	/^		trap_description_t() :$/;"	f	struct:mods::yaml::trap_description_t
trap_description_t	mods/yaml.hpp	/^	struct trap_description_t : public yaml_description_t {$/;"	s	namespace:mods::yaml
travel_to	mods/projectile.cpp	/^		int travel_to(room_rnum from, int direction, std::size_t depth, std::shared_ptr<obj_data> object){$/;"	f	namespace:mods::projectile
tree_mapping	mods/behaviour_tree_impl.cpp	/^	container_mapping_t tree_mapping;$/;"	m	namespace:mods::behaviour_tree_impl	file:
trees	mods/behaviour_tree_impl.cpp	/^	container_t trees;$/;"	m	namespace:mods::behaviour_tree_impl	file:
trigger_callback	mods/affects.hpp	/^			void trigger_callback(TAffects affect){$/;"	f	struct:mods::affects::dissolver
trigger_callback_for_affect	mods/rooms.cpp	/^		void trigger_callback_for_affect(room_rnum room,affect_t affect){$/;"	f	namespace:mods::rooms::affects
trigger_exists	mods/quests.cpp	/^		bool trigger_exists(char_data *ch,int quest_id) {$/;"	f	namespace:mods::quests
trigger_key	mods/quests.cpp	/^		std::string trigger_key(char_data *ch,room_rnum room,int n_index) {$/;"	f	namespace:mods::quests
trueValue	mods/catch.hpp	/^			void trueValue() const {}$/;"	f	class:Catch::SafeBool
tunnel_size	config.cpp	/^int tunnel_size = 2;$/;"	v
two_arguments	interpreter.cpp	/^char *two_arguments(char *argument, char *first_arg, char *second_arg) {$/;"	f
txn	mods/pq.hpp	/^inline mods::pq::transaction txn() { $/;"	f
txt	globals.hpp	/^namespace txt {$/;"	n
txt	mail.h	/^	char	txt[DATA_BLOCK_DATASIZE+1]; \/* actual text plus 1 for null	*\/$/;"	m	struct:data_block_type_d
txt	mail.h	/^	char	txt[HEADER_BLOCK_DATASIZE+1]; \/* actual text plus 1 for null	*\/$/;"	m	struct:header_block_type_d
type	act.wizard.cpp	/^	const char type;$/;"	m	struct:set_struct	file:
type	db.h	/^	int	type;$/;"	m	struct:ban_list_element
type	interpreter.h	/^	int type;$/;"	m	struct:alias_data
type	mods/behaviour_tree_impl.hpp	/^		enum type { $/;"	g	namespace:mods::behaviour_tree_impl
type	mods/item-types.hpp	/^namespace mods::weapon::type {$/;"	n	class:mods::weapon
type	mods/lmdb.hpp	/^		transact_type_t type() const { return m_type; }$/;"	f	struct:mods::lmdb::transaction_t
type	mods/player.hpp	/^		player_type_enum_t type(){$/;"	f	struct:mods::player
type	mods/weapon.hpp	/^			mw_rifle type;$/;"	m	struct:mods::weapon::yaml::rifle_description_t
type	shop.h	/^	int type;$/;"	m	struct:shop_buy_data
type	shop.h	/^	struct shop_buy_data *type;	\/* Which items to trade			*\/$/;"	m	struct:shop_data	typeref:struct:shop_data::shop_buy_data
type	structs.h	/^		int type;$/;"	m	struct:obj_flag_data
type	structs.h	/^		int16_t type;$/;"	m	struct:obj_data
type2_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,3> type2_flags = { {$/;"	m	namespace:mods::builder	file:
type_flag	structs.h	/^		int type_flag;	\/* Type of item			    *\/$/;"	m	struct:obj_flag_data
type_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,24> type_flags = { {$/;"	m	namespace:mods::builder	file:
type_list	mods/item-types.hpp	/^	enum type_list {$/;"	g	namespace:mods::weapon::type
types_t	mods/aoe.hpp	/^	enum types_t {$/;"	g	namespace:mods::aoe
ubyte	structs.h	/^	typedef unsigned char		ubyte;$/;"	t
ucname	mods/player.cpp	/^	std::string player::ucname(){ return m_ucname; }$/;"	f	class:mods::player
uint16_types	mods/values.cpp	/^		static const std::vector<std::string> uint16_types = {$/;"	m	namespace:mods::values	file:
uint8_t	structs.h	/^		enum fire_status_t : uint8_t {$/;"	g
uint8_types	mods/values.cpp	/^		static const std::vector<std::string> uint8_types = {$/;"	m	namespace:mods::values	file:
unblock_event	mods/player.cpp	/^	void player::unblock_event(uint32_t unblock){$/;"	f	class:mods::player
uncarry	mods/player.cpp	/^	void player::uncarry(obj_ptr_t obj){$/;"	f	class:mods::player
unequip	mods/player.cpp	/^	void player::unequip(int pos) {$/;"	f	class:mods::player
unequip_char	handler.cpp	/^obj_ptr_t unequip_char(player_ptr_t player, int pos){$/;"	f
unequip_into_inventory	mods/player.cpp	/^	void player::unequip_into_inventory(int pos) {$/;"	f	class:mods::player
unregister_mob	mods/behaviour_tree_impl.cpp	/^	int8_t unregister_mob(argument_type mob){$/;"	f	namespace:mods::behaviour_tree_impl
unrestrict_game	comm.cpp	/^RETSIGTYPE unrestrict_game(int sig) {$/;"	f
unsafe_code	mods/js.cpp	/^		static duk_ret_t unsafe_code(duk_context *ctx,void* udata) {$/;"	f	namespace:mods::js
until_zero	mods/deferred.hpp	/^		bool until_zero;$/;"	m	struct:mods::chunk_affect_t
unused_spell	spell_parser.cpp	/^void unused_spell(int spl) {$/;"	f
unused_spellname	spell_parser.cpp	/^const char *unused_spellname = "!UNUSED!"; \/* So we can get &unused_spellname *\/$/;"	v
update	mods/sql.hpp	/^			compositor<T>& update(str_object table) {$/;"	f	struct:mods::sql::compositor
update_char_objects	handler.cpp	/^void update_char_objects(char_data *ch) {$/;"	f
update_obj_file	mods/hell.hpp	/^	constexpr inline bool update_obj_file = false;$/;"	m	namespace:mods::hell
update_obj_file	objsave.cpp	/^void update_obj_file(void) {$/;"	f
update_object	handler.cpp	/^void update_object(struct obj_data *obj, int use) {$/;"	f
update_or_insert	mods/world-configuration.cpp	/^	std::pair<bool,std::string> update_or_insert(std::string_view table,$/;"	f	namespace:mods::world_conf
update_player_affected_by	magic.cpp	/^void update_player_affected_by(player_ptr_t& player){$/;"	f
update_pos	fight.cpp	/^void update_pos(char_data *victim) {$/;"	f
update_schema_for_player	mods/skills.cpp	/^	int update_schema_for_player(std::string player_name) {$/;"	f	namespace:mods::skills
update_zone_commands	mods/builder.cpp	/^	std::pair<bool,std::string> update_zone_commands(zone_rnum zone_id) {$/;"	f	namespace:mods::builder
update_zone_with_placements	mods/builder.cpp	/^	std::tuple<bool,zone_pkid_t,std::string> update_zone_with_placements(int virtual_number,player_ptr_t player) {$/;"	f	namespace:mods::builder
use_autowiz	config.cpp	/^int use_autowiz = YES;$/;"	v
use_pluck_filter	mods/lmdb.cpp	/^		void _db_handle::use_pluck_filter(bool b){$/;"	f	class:mods::lmdb::_db_handle
user	mods/auto-login.hpp	/^	static std::string user;$/;"	m	namespace:mods::auto_login
util	mods/deferred.hpp	/^namespace mods::util {$/;"	n	class:mods
util	mods/help.hpp	/^namespace mods::util {$/;"	n	class:mods
util	mods/util-conf.hpp	/^	namespace util {$/;"	n	namespace:mods
util	mods/util-map.hpp	/^	namespace util {$/;"	n	namespace:mods
util	mods/util.cpp	/^namespace mods::util {$/;"	n	class:mods	file:
util	mods/util.hpp	/^namespace mods::util {$/;"	n	class:mods
utils	mods/js.cpp	/^		namespace utils {$/;"	n	namespace:mods::js	file:
uuid	mods/drone.hpp	/^			uuid_t uuid() const {$/;"	f	class:mods::drone
uuid	mods/js.cpp	/^		static duk_ret_t uuid(duk_context *ctx) {$/;"	f	namespace:mods::js
uuid	mods/player.hpp	/^		uuid_t& uuid() const {$/;"	f	struct:mods::player
uuid	mods/scan.hpp	/^			uuid_t uuid;$/;"	m	struct:mods::scan::__anon4
uuid	shop.h	/^	uint64_t uuid;$/;"	m	struct:shop_data
uuid	structs.h	/^		uuid_t uuid;$/;"	m	struct:obj_data
value	mods/catch.hpp	/^			enum { value = sizeof(testStreamable(s << t)) == sizeof(TrueType) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon3
value	structs.h	/^		int	value[4];	\/* Values of the item (see list)    *\/$/;"	m	struct:obj_flag_data
value	structs.h	/^		int	value[4];$/;"	m	struct:obj_file_elem
value_callback	mods/builder_util.hpp	/^	typedef std::function<void(sql_compositor::value_map&)> value_callback;$/;"	t	namespace:mods::builder_util
value_map	mods/sql.hpp	/^			typedef std::map<std::string, std::string> value_map;$/;"	t	struct:mods::sql::compositor
values	mods/sql.hpp	/^			compositor<T>& values(const value_map& values) {$/;"	f	struct:mods::sql::compositor
values	mods/values.cpp	/^namespace mods::values {$/;"	n	class:mods	file:
values	mods/values.hpp	/^namespace mods::values {$/;"	n	class:mods
vec_player_data_element	mods/scan.hpp	/^		} vec_player_data_element;$/;"	t	namespace:mods::scan	typeref:struct:mods::scan::__anon4
vict_found	act.social.cpp	/^	char *vict_found;$/;"	m	struct:social_messg	file:
view	mods/string.cpp	/^	std::string_view string::view() const {$/;"	f	class:mods::string
view	mods/string.cpp	/^	std::string_view string::view(){$/;"	f	class:mods::string
viewing_room	mods/player.cpp	/^	int player::viewing_room(){$/;"	f	class:mods::player
violent	spells.h	/^	byte violent;$/;"	m	struct:spell_info_type
visibility	mods/calc_visibility.cpp	/^namespace mods::calc::visibility {$/;"	n	class:mods::calc	file:
visibility	mods/calc_visibility.hpp	/^namespace mods::calc::visibility {$/;"	n	class:mods::calc
vnum	boards.h	/^	obj_vnum vnum;	\/* vnum of this board *\/$/;"	m	struct:board_info_type
vnum	house.h	/^	room_vnum vnum;		\/* vnum of this house		*\/$/;"	m	struct:house_control_rec
vnum	mods/npc.cpp	/^	const mob_vnum& npc::vnum() const { return cd()->nr; }$/;"	f	class:mods::npc
vnum	shop.h	/^	room_vnum vnum;		\/* Virtual number of this shop		*\/$/;"	m	struct:shop_data
vnum_mobile	db.cpp	/^int vnum_mobile(char *searchname, char_data *ch) {$/;"	f
vnum_object	db.cpp	/^int vnum_object(char *searchname, char_data *ch) {$/;"	f
vsnprintf	bsd-snprintf.cpp	/^vsnprintf(char *str, size_t count, const char *fmt, va_list args) {$/;"	f
vsnprintf	sysdep.h	351;"	d
vwrite_to_output	comm.cpp	/^size_t vwrite_to_output(mods::descriptor_data &t, const char *format, va_list args) {$/;"	f
warn_thermite_room	mods/doors.hpp	/^	static inline void warn_thermite_room(const room_rnum room,int direction){$/;"	f	namespace:mods::doors
weapon	mods/weapon-types.hpp	/^namespace mods::weapon {$/;"	n	class:mods
weapon	mods/weapon.cpp	/^namespace mods::weapon {$/;"	n	class:mods	file:
weapon	mods/weapon.hpp	/^namespace mods::weapon {$/;"	n	class:mods
weapon	mods/yaml.hpp	/^namespace mods::weapon {$/;"	n	class:mods
weapon_attack_types_t	spells.h	/^enum weapon_attack_types_t {$/;"	g
weapon_cooldown_expired	mods/player.cpp	/^	bool player::weapon_cooldown_expired(weapon_set set) {$/;"	f	class:mods::player
weapon_cooldown_start	mods/player.cpp	/^	void player::weapon_cooldown_start(uint16_t duration,weapon_set set) {$/;"	f	class:mods::player
weapon_flags	structs.h	/^		uint64_t weapon_flags;$/;"	m	struct:obj_flag_data
weapon_handling	mods/skills.hpp	/^		static std::vector<proficiency_t> weapon_handling = {$/;"	m	namespace:mods::skills::proficiencies
weapon_name	mods/player.cpp	/^	mods::string player::weapon_name(){$/;"	f	class:mods::player
weapon_set	mods/drone.hpp	/^			typedef short weapon_set;$/;"	t	class:mods::drone
weapon_stats	mods/weapon-stat-list.hpp	/^	static inline weapon_stat_list_t* weapon_stats(int type){$/;"	f
weapon_type_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,13> weapon_type_flags = { {$/;"	m	namespace:mods::builder	file:
weapon_type_statistics_t	mods/weapon-types.hpp	/^	struct weapon_type_statistics_t {$/;"	s	namespace:mods::weapon
weapon_types	mods/weapon-types.hpp	/^namespace mods::weapon_types {$/;"	n	class:mods
wear_bits	constants.cpp	/^const char *wear_bits[] = {$/;"	v
wear_bits	constants.hpp	/^const char *wear_bits[] = {$/;"	v
wear_bits_count	constants.cpp	/^        wear_bits_count = sizeof(wear_bits) \/ sizeof(wear_bits[0]) - 1;$/;"	v
wear_bits_count	constants.hpp	/^	wear_bits_count = sizeof(wear_bits) \/ sizeof(wear_bits[0]) - 1;$/;"	v
wear_flags	mods/builder.cpp	/^	std::array<std::pair<int,std::string>,15> wear_flags = { {$/;"	m	namespace:mods::builder	file:
wear_flags	structs.h	/^		int \/*bitvector_t*\/	wear_flags;	\/* Where you can wear it	    *\/$/;"	m	struct:obj_flag_data
wear_message	act.item.cpp	/^void wear_message(char_data *ch, struct obj_data *obj, int where) {$/;"	f
wear_off_msg	spells.h	/^	const char *wear_off_msg;	\/* Input size not limited. Originates from string constants. *\/$/;"	m	struct:spell_info_type
wear_where	constants.cpp	/^const char *wear_where[] = {$/;"	v
wear_where	constants.hpp	/^const char *wear_where[] = {$/;"	v
weather_and_time	weather.cpp	/^void weather_and_time(int mode) {$/;"	f
weather_change	weather.cpp	/^void weather_change(void) {$/;"	f
weather_info	db.cpp	/^struct weather_data weather_info;	\/* the infomation about the weather *\/$/;"	v	typeref:struct:weather_data
weekdays	constants.cpp	/^const char *weekdays[] = {$/;"	v
weekdays	constants.hpp	/^const char *weekdays[] = {$/;"	v
weight	mods/player.hpp	/^		ubyte& weight(){$/;"	f	struct:mods::player
weight	structs.h	/^		int	weight;		\/* Weigt what else                  *\/$/;"	m	struct:obj_flag_data
weight	structs.h	/^		int	weight;$/;"	m	struct:obj_file_elem
weight_change_object	act.item.cpp	/^void weight_change_object(struct obj_data *obj, int weight) {$/;"	f
where	mods/sql.hpp	/^			compositor<T>& where(str_object lhs,$/;"	f	struct:mods::sql::compositor
where_in	mods/sql.hpp	/^			compositor<T>& where_in(str_object lhs,$/;"	f	struct:mods::sql::compositor
width	mods/overhead_map.hpp	/^	constexpr static uint8_t width = 48;$/;"	m	namespace:mods::overhead_map
wis_app	constants.cpp	/^cpp_extern const struct wis_app_type wis_app[] = {$/;"	v	typeref:struct:wis_app_type
wis_app	constants.hpp	/^cpp_extern const struct wis_app_type wis_app[] = {$/;"	v	typeref:struct:wis_app_type
with_who	shop.h	/^	int	 with_who;		\/* Who does the shop trade with?	*\/$/;"	m	struct:shop_data
wizlist	db.cpp	/^char *wizlist = NULL;		\/* list of higher gods		 *\/$/;"	v
word_wrap	mods/util.cpp	/^	std::string&& word_wrap(std::string_view paragraph,int width) {$/;"	f	namespace:mods::util
world	db.cpp	/^std::deque<room_data> world;	\/* array of rooms		 *\/$/;"	v
world_conf	mods/world-configuration.cpp	/^namespace mods::world_conf {$/;"	n	class:mods	file:
world_conf	mods/world-configuration.hpp	/^namespace mods::world_conf {$/;"	n	class:mods
worn_by	structs.h	/^		char_data *worn_by;	  \/* Worn by?			      *\/$/;"	m	struct:obj_data
worn_on	structs.h	/^		sh_int worn_on;		  \/* Worn where?		      *\/$/;"	m	struct:obj_data
write	comm.cpp	1502;"	d	file:
write_aliases	alias.cpp	/^void write_aliases(char_data *ch) {$/;"	f
write_ban_list	ban.cpp	/^void write_ban_list(void) {$/;"	f
write_example_file	mods/yaml.cpp	/^	int16_t armor_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::armor_description_t
write_example_file	mods/yaml.cpp	/^	int16_t attachment_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::attachment_description_t
write_example_file	mods/yaml.cpp	/^	int16_t consumable_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::consumable_description_t
write_example_file	mods/yaml.cpp	/^	int16_t drone_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::drone_description_t
write_example_file	mods/yaml.cpp	/^	int16_t explosive_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::explosive_description_t
write_example_file	mods/yaml.cpp	/^	int16_t gadget_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::gadget_description_t
write_example_file	mods/yaml.cpp	/^	int16_t rifle_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::rifle_description_t
write_example_file	mods/yaml.cpp	/^	int16_t trap_description_t::write_example_file(std::string_view file){$/;"	f	class:mods::yaml::trap_description_t
write_histfile	mods/player.cpp	/^	void player::write_histfile(std::string_view line){$/;"	f	class:mods::player
write_lvl	boards.h	/^	int	write_lvl;	\/* min level to write messages on this board *\/$/;"	m	struct:board_info_type
write_meta	mods/meta_utils.cpp	/^	void write_meta(std::string table,mutable_map_t* values){$/;"	f	namespace:mods::meta_utils
write_to_char	comm.cpp	/^void write_to_char(char_data *ch, std::string_view msg, bool newline,bool plain) {$/;"	f
write_to_descriptor	comm.cpp	/^int write_to_descriptor(socket_t desc, const char *txt) {$/;"	f
write_to_file	mail.cpp	/^void write_to_file(void *buf, int size, long filepos) {$/;"	f
write_to_output	comm.cpp	/^size_t write_to_output(mods::descriptor_data &t, const char *txt, ...) {$/;"	f
write_to_q	comm.cpp	/^void	write_to_q(std::string_view txt, mods::descriptor_data& d, int aliased){$/;"	f
xEOF	telnet.h	61;"	d
yaml	mods/weapon.hpp	/^	namespace yaml {$/;"	n	namespace:mods::weapon
yaml	mods/yaml.cpp	/^namespace mods::yaml {$/;"	n	class:mods	file:
yaml	mods/yaml.hpp	/^namespace mods::yaml {$/;"	n	class:mods
yaml_caps_to_lower	mods/util.cpp	/^	std::string yaml_caps_to_lower(std::string type){$/;"	f	namespace:mods::util
yaml_description_t	mods/yaml.hpp	/^	struct yaml_description_t {$/;"	s	namespace:mods::yaml
yaml_feed_exceptions	mods/object-utils.hpp	/^	static yaml_exception_list_t yaml_feed_exceptions;$/;"	m	namespace:mods::object_utils
yaml_file_doesnt_exist	mods/object-utils.hpp	/^	static inline void yaml_file_doesnt_exist(std::string from_where){$/;"	f	namespace:mods::object_utils
yaml_file_path_is_sane	mods/util.cpp	/^	bool yaml_file_path_is_sane(std::string path){$/;"	f	namespace:mods::util
yaml_import	mods/object-utils.hpp	/^	static inline obj_ptr_t yaml_import(std::string object_type,std::string in_yaml_file){$/;"	f	namespace:mods::object_utils
yaml_initiator	mods/object-utils.hpp	/^	static std::string yaml_initiator = "";$/;"	m	namespace:mods::object_utils
yaml_int_to_string	mods/util.cpp	/^	std::string yaml_int_to_string(int type){$/;"	f	namespace:mods::util
yaml_string_to_int	mods/util.cpp	/^	int yaml_string_to_int(std::string type){$/;"	f	namespace:mods::util
yaml_transaction_id	mods/object-utils.hpp	/^	static uint32_t yaml_transaction_id = 0;$/;"	m	namespace:mods::object_utils
year	mods/date-time.cpp	/^	static uint8_t year;$/;"	m	namespace:mods::date_time	file:
youre_injured	mods/values.hpp	/^			static inline void youre_injured(T& p){$/;"	f	namespace:mods::values::msg
zone	structs.h	/^		zone_rnum zone;              \/* Room zone (for resetting)          *\/$/;"	v
zone_data	db.h	/^	zone_data() : name(nullptr),$/;"	f	struct:zone_data
zone_data	db.h	/^struct zone_data {$/;"	s
zone_id_blacklist	db.cpp	/^std::vector<int> zone_id_blacklist;$/;"	v
zone_pave_mode	mods/player.cpp	/^	bool player::zone_pave_mode(){$/;"	f	class:mods::player
zone_place	mods/builder.cpp	/^	std::pair<bool,std::string> zone_place(int zone_id,std::string_view zone_command,std::string_view if_flag,std::string_view arg1,std::string_view arg2,std::string_view arg3) {$/;"	f	namespace:mods::builder
zone_rnum	structs.h	/^	typedef IDXTYPE zone_rnum;$/;"	t
zone_table	db.cpp	/^std::vector<zone_data> zone_table;	\/* zone table			 *\/$/;"	v
zone_to_reset	db.h	/^	zone_rnum zone_to_reset;            \/* ref to zone_data *\/$/;"	m	struct:reset_q_element
zone_update	db.cpp	/^void zone_update() {$/;"	f
zone_vnum	structs.h	/^	typedef IDXTYPE zone_vnum;$/;"	t
~DecomposedExpression	mods/catch.hpp	/^			virtual ~DecomposedExpression() {}$/;"	f	struct:Catch::DecomposedExpression
~MethodTestCase	mods/catch.hpp	/^			virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase
~Ptr	mods/catch.hpp	/^			~Ptr() {$/;"	f	class:Catch::Ptr
~_db_handle	mods/lmdb.cpp	/^	_db_handle::~_db_handle(){$/;"	f	class:mods::lmdb::_db_handle
~char_data	structs.cpp	/^		char_data::~char_data(){$/;"	f	class:char_data
~mob_special_data	structs.cpp	/^		mob_special_data::~mob_special_data(){$/;"	f	class:mob_special_data
~npc	mods/npc.cpp	/^	npc::~npc(){$/;"	f	class:mods::npc
~object	mods/object.cpp	/^	object::~object(){$/;"	f	class:mods::object
~player	mods/player.cpp	/^	player::~player() {$/;"	f	class:mods::player
~room_data	structs.cpp	/^		room_data::~room_data() {$/;"	f	class:room_data
~string	mods/string.cpp	/^	string::~string(){$/;"	f	class:mods::string
~yaml_description_t	mods/yaml.hpp	/^		virtual ~yaml_description_t(){};$/;"	f	struct:mods::yaml::yaml_description_t
